var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[1.34308, 0.936371, 0.504235, 0, 1.78571], "total":[1026, 1105, 0, 2], "name":"System", "max_resources":[109572, 219144, 514, 112], "children":[{"name":"imgOffSet", "compute_units":1, "type":"function", "total_percent":[1.34308, 0.936371, 0.504235, 0, 1.78571], "total_kernel_resources":[1026, 1105, 0, 2], "details":[{"type":"text", "text":"Number of compute units: 1"}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 192 bits wide with a buffer size of 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}]}, {"name":"Variable: \\n - \'x\' (image.cpp:30)", "type":"resource", "data":[24, 101, 0, 0], "debug":[[{"filename":"image.cpp", "line":30}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'y\' (image.cpp:29)", "type":"resource", "data":[7, 36, 0, 0], "debug":[[{"filename":"image.cpp", "line":29}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"imgOffSet.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[0, 227, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[0, 33, 0, 0]}, {"name":"image.cpp:29", "type":"resource", "data":[0, 66, 0, 0], "debug":[[{"filename":"image.cpp", "line":29}]]}, {"name":"image.cpp:33 > hls.h:521", "type":"resource", "data":[0, 64, 0, 0], "debug":[[{"filename":"image.cpp", "line":33}, {"filename":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/hls.h", "line":521}]]}, {"name":"image.cpp:35 > hls.h:521", "type":"resource", "data":[0, 64, 0, 0], "debug":[[{"filename":"image.cpp", "line":35}, {"filename":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/hls.h", "line":521}]]}]}, {"name":"Feedback", "type":"resource", "data":[5, 2, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 2, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[36, 1, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Channel Read", "type":"resource", "count":1, "data":[1, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0]}]}, {"name":"image.cpp:29", "type":"resource", "data":[67, 0, 0, 0], "debug":[[{"filename":"image.cpp", "line":29}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"33-bit Integer Add", "type":"resource", "count":1, "data":[34, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"imgOffSet.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[55, 107, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[55, 107, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[23, 80, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0]}, {"name":"image.cpp:29", "type":"resource", "data":[22, 80, 0, 0], "debug":[[{"filename":"image.cpp", "line":29}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[104, 52, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[27, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[27, 0, 0, 0]}]}, {"name":"image.cpp:29", "type":"resource", "data":[67, 0, 0, 0], "debug":[[{"filename":"image.cpp", "line":29}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"33-bit Integer Add", "type":"resource", "count":2, "data":[34, 0, 0, 0]}], "replace_name":"true"}, {"name":"image.cpp:31 > image.cpp:21", "type":"resource", "data":[66, 0, 0, 2], "debug":[[{"filename":"image.cpp", "line":31}, {"filename":"image.cpp", "line":21}]], "children":[{"name":"32-bit Integer Multiply", "type":"resource", "count":1, "data":[66, 0, 0, 2]}], "replace_name":"true"}]}]}, {"name":"imgOffSet.B3", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[173, 161, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[173, 161, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[74, 254, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0]}, {"name":"image.cpp:29", "type":"resource", "data":[9, 8, 0, 0], "debug":[[{"filename":"image.cpp", "line":29}]]}, {"name":"image.cpp:30", "type":"resource", "data":[39, 145, 0, 0], "debug":[[{"filename":"image.cpp", "line":30}]]}, {"name":"image.cpp:31 > image.cpp:21", "type":"resource", "data":[25, 101, 0, 0], "debug":[[{"filename":"image.cpp", "line":31}, {"filename":"image.cpp", "line":21}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[45, 32, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[27, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[27, 0, 0, 0]}]}, {"name":"image.cpp:30", "type":"resource", "data":[67, 0, 0, 0], "debug":[[{"filename":"image.cpp", "line":30}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"33-bit Integer Add", "type":"resource", "count":2, "data":[34, 0, 0, 0]}], "replace_name":"true"}, {"name":"image.cpp:31 > image.cpp:21", "type":"resource", "data":[33, 0, 0, 0], "debug":[[{"filename":"image.cpp", "line":31}, {"filename":"image.cpp", "line":21}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}], "replace_name":"true"}, {"name":"image.cpp:33", "type":"resource", "data":[47, 17, 0, 0], "debug":[[{"filename":"image.cpp", "line":33}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[14, 17, 0, 0], "details":[{"type":"text", "text":"Load uses a Local-pipelined never-stall LSU"}]}], "replace_name":"true"}, {"name":"image.cpp:34", "type":"resource", "data":[35, 1, 0, 0], "debug":[[{"filename":"image.cpp", "line":34}]], "children":[{"name":"Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0]}], "replace_name":"true"}, {"name":"image.cpp:35", "type":"resource", "data":[17, 12, 0, 0], "debug":[[{"filename":"image.cpp", "line":35}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[17, 12, 0, 0], "details":[{"type":"text", "text":"Store uses a Local-pipelined never-stall LSU"}]}], "replace_name":"true"}, {"name":"image.cpp:37", "type":"resource", "data":[21, 12, 0, 0], "debug":[[{"filename":"image.cpp", "line":37}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[4, 0, 0, 0]}, {"name":"Store", "type":"resource", "count":1, "data":[17, 12, 0, 0], "details":[{"type":"text", "text":"Store uses a Local-pipelined never-stall LSU"}]}], "replace_name":"true"}]}]}, {"name":"imgOffSet.B5", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[3, 8, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3, 8, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[3, 2, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Channel Write", "type":"resource", "count":1, "data":[3, 2, 0, 0]}]}]}]}]}]}';
var area_srcJSON='{"max_resources":[109572,219144,514,112],"name":"System","children":[{"debug":[[{"filename":"image.cpp","line":29}]],"total_kernel_resources":[1026,1105,0,2],"name":"imgOffSet","data":[1026,1105,0,2],"children":[{"detail":[{"text":"Feedback + Cluster logic","type":"text"}],"name":"Data control overhead","type":"resource","data":[254,428,0,0]},{"name":"Component call","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 192 bits wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Component return","type":"resource","data":[0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"}]},{"name":"Variable: \\n - \'x\' (image.cpp:30)","type":"resource","data":[24,101,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}]},{"name":"Variable: \\n - \'y\' (image.cpp:29)","type":"resource","data":[7,36,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}]},{"name":"No Source Line","data":[321,304,0,0],"type":"resource","children":[{"count":3,"name":"State","debug":[[{"filename":"","line":0}]],"type":"resource","data":[228,301,0,0]},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Channel Read","data":[1,0,0,0],"type":"resource"},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Integer Compare","data":[35,1,0,0],"type":"resource"},{"count":2,"name":"Select","debug":[[{"filename":"","line":0}]],"type":"resource","data":[54,0,0,0]},{"count":1,"debug":[[{"filename":"","line":0}]],"name":"Channel Write","data":[3,2,0,0],"type":"resource"}]},{"debug":[[{"filename":"image.cpp","line":29}]],"name":"image.cpp:29","data":[134,66,0,0],"type":"resource","children":[{"count":1,"name":"State","debug":[[{"filename":"image.cpp","line":29}]],"type":"resource","data":[0,66,0,0]},{"count":2,"debug":[[{"filename":"image.cpp","line":29}]],"name":"32-bit Integer Add","data":[66,0,0,0],"type":"resource"},{"count":3,"debug":[[{"filename":"image.cpp","line":29}]],"name":"33-bit Integer Add","data":[68,0,0,0],"type":"resource"}]},{"debug":[[{"filename":"image.cpp","line":33}]],"name":"image.cpp:33","data":[47,81,0,0],"type":"resource","children":[{"replace_name":true,"debug":[[{"filename":"image.cpp","line":33},{"filename":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/hls.h","line":521}]],"name":"image.cpp:33 > hls.h:521","type":"resource","data":[0,64,0,0],"children":[{"count":1,"name":"State","debug":[[{"filename":"image.cpp","line":33}]],"type":"resource","data":[0,64,0,0]}]},{"count":1,"debug":[[{"filename":"image.cpp","line":33}]],"name":"32-bit Integer Add","data":[33,0,0,0],"type":"resource"},{"count":1,"debug":[[{"filename":"image.cpp","line":33}]],"name":"Load","data":[14,17,0,0],"type":"resource"}]},{"debug":[[{"filename":"image.cpp","line":35}]],"name":"image.cpp:35","data":[17,76,0,0],"type":"resource","children":[{"replace_name":true,"debug":[[{"filename":"image.cpp","line":35},{"filename":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/hls.h","line":521}]],"name":"image.cpp:35 > hls.h:521","type":"resource","data":[0,64,0,0],"children":[{"count":1,"name":"State","debug":[[{"filename":"image.cpp","line":35}]],"type":"resource","data":[0,64,0,0]}]},{"count":1,"debug":[[{"filename":"image.cpp","line":35}]],"name":"Store","data":[17,12,0,0],"type":"resource"}]},{"name":"image.cpp:31","debug":[[{"filename":"image.cpp","line":31}]],"replace_name":"true","type":"resource","data":[99,0,0,2],"children":[{"replace_name":true,"debug":[[{"filename":"image.cpp","line":31},{"filename":"image.cpp","line":21}]],"name":"image.cpp:31 > image.cpp:21","type":"resource","data":[99,0,0,2],"children":[{"count":1,"name":"32-bit Integer Multiply","debug":[[{"filename":"image.cpp","line":31}]],"type":"resource","data":[66,0,0,2]},{"count":1,"debug":[[{"filename":"image.cpp","line":31}]],"name":"32-bit Integer Add","data":[33,0,0,0],"type":"resource"}]}]},{"name":"image.cpp:30","debug":[[{"filename":"image.cpp","line":30}]],"replace_name":"true","type":"resource","data":[67,0,0,0],"children":[{"count":1,"name":"32-bit Integer Add","debug":[[{"filename":"image.cpp","line":30}]],"type":"resource","data":[33,0,0,0]},{"count":2,"name":"33-bit Integer Add","debug":[[{"filename":"image.cpp","line":30}]],"type":"resource","data":[34,0,0,0]}]},{"name":"image.cpp:34","debug":[[{"filename":"image.cpp","line":34}]],"replace_name":"true","type":"resource","data":[35,1,0,0],"children":[{"count":1,"name":"Integer Compare","debug":[[{"filename":"image.cpp","line":34}]],"type":"resource","data":[35,1,0,0]}]},{"name":"image.cpp:37","debug":[[{"filename":"image.cpp","line":37}]],"replace_name":"true","type":"resource","data":[21,12,0,0],"children":[{"count":1,"name":"Select","debug":[[{"filename":"image.cpp","line":37}]],"type":"resource","data":[4,0,0,0]},{"count":1,"name":"Store","debug":[[{"filename":"image.cpp","line":37}]],"type":"resource","data":[17,12,0,0]}]}],"total_percent":[1.34308,0.936371,0.504235,0,1.78571],"type":"function","details":[{"text":"Number of compute units: 1","type":"text"}],"compute_units":1}],"data":[1026,1105,0,2],"total_percent":[1.34308,0.936371,0.504235,0,1.78571],"total":[1026,1105,0,2],"debug_enabled":"true","columns":["","ALUTs","FFs","RAMs","DSPs","Details"],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"imgOffSet", "children":[{"type":"bb", "id":3, "name":"imgOffSet.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"imgOffSet.B1.start", "children":[{"type":"inst", "id":9, "name":"Channel Read", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"192 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"2", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":15, "name":"loop", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"20"}]}, {"type":"inst", "id":16, "name":"end", "details":[{"type":"table", "Start Cycle":"3", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"3", "II":"0", "Subloops":"Yes", "Pipelined":"No", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":5, "name":"imgOffSet.B2", "details":[{"type":"table", "Latency":"7", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"7"}]}, {"type":"bb", "id":6, "name":"imgOffSet.B3", "children":[{"type":"inst", "id":11, "name":"Load", "debug":[[{"filename":"image.cpp", "line":33}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Pipelined", "Stall-free":"Yes", "Start Cycle":"3", "Latency":"4", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":12, "name":"Store", "debug":[[{"filename":"image.cpp", "line":35}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Pipelined", "Stall-free":"Yes", "Start Cycle":"10", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":17, "name":"loop", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"18"}]}, {"type":"inst", "id":18, "name":"loop end", "details":[{"type":"table", "Start Cycle":"16", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"16", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":7, "name":"imgOffSet.B4", "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":8, "name":"imgOffSet.B5", "children":[{"type":"inst", "id":13, "name":"Channel Write", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"8 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":19, "name":"begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":20, "name":"loop end", "details":[{"type":"table", "Start Cycle":"1", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"1", "II":"0", "Subloops":"Yes", "Pipelined":"No", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}]}, {"type":"memtype", "id":1, "name":"System Memory", "children":[{"type":"memsys", "id":24, "name":"2", "details":[{"type":"table", "Number of banks":"1", "Arguments from imgOffSet":"imgOut"}]}, {"type":"memsys", "id":25, "name":"1", "details":[{"type":"table", "Number of banks":"1", "Arguments from imgOffSet":"imgIn"}]}]}, {"type":"stream", "id":10, "name":"do", "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"table", "Width":"192 bits", "Depth":"0", "Bits per symbol":"192 bits", "Uses Packets":"No", "Uses Valid":"Yes"}]}, {"type":"stream", "id":14, "name":"return", "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"table", "Width":"8 bits", "Depth":"0", "Bits per symbol":"8 bits", "Uses Packets":"No", "Uses Ready":"Yes"}]}, {"type":"interface", "id":23, "name":"N", "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Component":"imgOffSet"}]}, {"type":"interface", "id":21, "name":"imgIn", "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"table", "Stable":"No", "Data width":"8", "Address width":"32", "Address Space":"1", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"imgOffSet"}]}, {"type":"interface", "id":22, "name":"imgOut", "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"table", "Stable":"No", "Data width":"8", "Address width":"32", "Address Space":"2", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"imgOffSet"}]}], "links":[{"from":10, "to":9}, {"from":13, "to":14}, {"from":21, "to":9}, {"from":22, "to":9}, {"from":23, "to":9}, {"from":20, "to":15}, {"from":3, "to":15}, {"from":9, "to":16}, {"from":7, "to":5}, {"from":16, "to":5}, {"from":18, "to":17}, {"from":5, "to":17}, {"from":12, "to":18}, {"from":18, "to":7}, {"from":7, "to":19}, {"from":13, "to":20}, {"from":15, "to":9}, {"from":17, "to":11}, {"from":11, "to":12}, {"from":19, "to":13}, {"from":12, "to":24}, {"from":25, "to":11}]}';
var lmvJSON='{"nodes":[{"type":"interface", "id":23, "name":"N", "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Component":"imgOffSet"}]}, {"type":"interface", "id":21, "name":"imgIn", "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"table", "Stable":"No", "Data width":"8", "Address width":"32", "Address Space":"1", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"imgOffSet"}]}, {"type":"interface", "id":22, "name":"imgOut", "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"table", "Stable":"No", "Data width":"8", "Address width":"32", "Address Space":"2", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"imgOffSet"}]}], "links":[]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Bottleneck", "Details"], "children":[{"name":"Component: imgOffSet", "data":["", "", ""], "debug":[[{"filename":"image.cpp", "line":28}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}], "children":[{"name":"imgOffSet.B1.start", "data":["No", "n/a", "n/a"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":"Out-of-order inner loop"}, {"type":"text", "text":"Loop not pipelined due to:", "details":[{"type":"text", "text":"Loop iteration ordering: iterations of inner loop shown may get out of order with respect to the listed inner loop, as the number of iterations of the listed inner loop may be different for different iterations of this loop.", "details":[{"type":"text", "text":"imgOffSet.B2 (%L)", "links":[{"filename":"image.cpp", "line":"29"}]}, {"type":"text", "text":"imgOffSet.B3 (%L)", "links":[{"filename":"image.cpp", "line":"30"}]}]}]}, {"type":"text", "text":"See %L for more information"}], "children":[{"name":"imgOffSet.B2", "data":["Yes", ">=1", "n/a"], "debug":[[{"filename":"image.cpp", "line":29}], [{"filename":"image.cpp", "line":29}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Run simulation to verify component\'s dynamic II. Use the %L report to view results. II is an approximation due to variable inner loop trip count.", "links":[{"view":"Verification statistics"}]}], "children":[{"name":"imgOffSet.B3", "data":["Yes", "1", "n/a"], "debug":[[{"filename":"image.cpp", "line":30}], [{"filename":"image.cpp", "line":30}]], "children":[]}]}]}]}]}';
var summaryJSON='{"estimatedResources":{"name":"Estimated Resource Usage", "columns":["Component Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs "], "children":[{"name":"imgOffSet", "data":[1026, 1105, 0, 2], "debug":[[{"filename":"image.cpp", "line":28}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[1026, 1105, 0, 2], "data_percent":[0.936371, 0.504235, 0, 1.78571]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[109572, 219144, 514, 112]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var infoJSON='{"name":"Info","rows":[{"name":"Project Name","data":["./image-CycloneV"],"classes":["info-table"]},{"name":"Target Family, Device","data":["Cyclone V, 5CEFA9F23I7"]},{"name":"i++ Version","data":["18.1.0 Build 625"]},{"name":"Quartus Version","data":["18.1.0 Build 625"]},{"name":"Command","data":["i++ image.cpp -march=CycloneV -o image-CycloneV"]},{"name":"Reports Generated At", "data":["Mon Nov 11 20:14:42 2019"]}]}';
var warningsJSON='{"rows":[]}';
var quartusJSON='{"quartusFitClockSummary":{"name":"Quartus Fit Summary","children":[{"name":"Run Quartus compile to populate this section. See details for more information.","details":[{"type":"text", "text":"This section contains a summary of the area and fmax data generated by compiling the components through Quartus.  To generate the data, run a Quartus compile on the project created for this design. To run the Quartus compile:\\n  1) Change to the quartus directory (./image-CycloneV.prj/quartus)\\n  2) quartus_sh --flow compile quartus_compile\\n"}]}]}}';
var fileJSON=[{"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/allocator.h", "name":"allocator.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/allocator.h", "content":"// Allocators -*- C++ -*-\012\012// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/*\012 * Copyright (c) 1996-1997\012 * Silicon Graphics Computer Systems, Inc.\012 *\012 * Permission to use, copy, modify, distribute and sell this software\012 * and its documentation for any purpose is hereby granted without fee,\012 * provided that the above copyright notice appear in all copies and\012 * that both that copyright notice and this permission notice appear\012 * in supporting documentation.  Silicon Graphics makes no\012 * representations about the suitability of this software for any\012 * purpose.  It is provided \"as is\" without express or implied warranty.\012 */\012\012/** @file allocator.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012#ifndef _ALLOCATOR_H\012#define _ALLOCATOR_H 1\012\012// Define the base class to std::allocator.\012#include <bits/c++allocator.h>\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  /**\012   * @defgroup allocators Allocators\012   * @ingroup memory\012   *\012   * Classes encapsulating memory operations.\012   */\012\012  template<typename _Tp>\012    class allocator;\012\012  /// allocator<void> specialization.\012  template<>\012    class allocator<void>\012    {\012    public:\012      typedef size_t      size_type;\012      typedef ptrdiff_t   difference_type;\012      typedef void*       pointer;\012      typedef const void* const_pointer;\012      typedef void        value_type;\012\012      template<typename _Tp1>\012        struct rebind\012        { typedef allocator<_Tp1> other; };\012    };\012\012  /**\012   * @brief  The \"standard\" allocator, as per [20.4].\012   * @ingroup allocators\012   *\012   *  Further details:\012   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html\012   */\012  template<typename _Tp>\012    class allocator: public __glibcxx_base_allocator<_Tp>\012    {\012   public:\012      typedef size_t     size_type;\012      typedef ptrdiff_t  difference_type;\012      typedef _Tp*       pointer;\012      typedef const _Tp* const_pointer;\012      typedef _Tp&       reference;\012      typedef const _Tp& const_reference;\012      typedef _Tp        value_type;\012\012      template<typename _Tp1>\012        struct rebind\012        { typedef allocator<_Tp1> other; };\012\012      allocator() throw() { }\012\012      allocator(const allocator& __a) throw()\012      : __glibcxx_base_allocator<_Tp>(__a) { }\012\012      template<typename _Tp1>\012        allocator(const allocator<_Tp1>&) throw() { }\012\012      ~allocator() throw() { }\012\012      // Inherit everything else.\012    };\012\012  template<typename _T1, typename _T2>\012    inline bool\012    operator==(const allocator<_T1>&, const allocator<_T2>&)\012    { return true; }\012\012  template<typename _Tp>\012    inline bool\012    operator==(const allocator<_Tp>&, const allocator<_Tp>&)\012    { return true; }\012\012  template<typename _T1, typename _T2>\012    inline bool\012    operator!=(const allocator<_T1>&, const allocator<_T2>&)\012    { return false; }\012\012  template<typename _Tp>\012    inline bool\012    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)\012    { return false; }\012\012  // Inhibit implicit instantiations for required instantiations,\012  // which are defined via explicit instantiations elsewhere.\012  // NB: This syntax is a GNU extension.\012#if _GLIBCXX_EXTERN_TEMPLATE\012  extern template class allocator<char>;\012  extern template class allocator<wchar_t>;\012#endif\012\012  // Undefine.\012#undef __glibcxx_base_allocator\012\012  // To implement Option 3 of DR 431.\012  template<typename _Alloc, bool = __is_empty(_Alloc)>\012    struct __alloc_swap\012    { static void _S_do_it(_Alloc&, _Alloc&) { } };\012\012  template<typename _Alloc>\012    struct __alloc_swap<_Alloc, false>\012    {\012      static void\012      _S_do_it(_Alloc& __one, _Alloc& __two)\012      {\012	// Precondition: swappable allocators.\012	if (__one != __two)\012	  swap(__one, __two);\012      }\012    };\012\012  // Optimize for stateless allocators.\012  template<typename _Alloc, bool = __is_empty(_Alloc)>\012    struct __alloc_neq\012    {\012      static bool\012      _S_do_it(const _Alloc&, const _Alloc&)\012      { return false; }\012    };\012\012  template<typename _Alloc>\012    struct __alloc_neq<_Alloc, false>\012    {\012      static bool\012      _S_do_it(const _Alloc& __one, const _Alloc& __two)\012      { return __one != __two; }\012    };\012\012_GLIBCXX_END_NAMESPACE\012\012#endif\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/basic_string.h", "name":"basic_string.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/basic_string.h", "content":"// Components for manipulating sequences of characters -*- C++ -*-\012\012// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\012// 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file basic_string.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012//\012// ISO C++ 14882: 21 Strings library\012//\012\012#ifndef _BASIC_STRING_H\012#define _BASIC_STRING_H 1\012\012#pragma GCC system_header\012\012#include <ext/atomicity.h>\012#include <debug/debug.h>\012#include <initializer_list>\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  /**\012   *  @class basic_string basic_string.h <string>\012   *  @brief  Managing sequences of characters and character-like objects.\012   *\012   *  @ingroup sequences\012   *\012   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\012   *  <a href=\"tables.html#66\">reversible container</a>, and a\012   *  <a href=\"tables.html#67\">sequence</a>.  Of the\012   *  <a href=\"tables.html#68\">optional sequence requirements</a>, only\012   *  @c push_back, @c at, and array access are supported.\012   *\012   *  @doctodo\012   *\012   *\012   *  Documentation?  What's that?\012   *  Nathan Myers <ncm@cantrip.org>.\012   *\012   *  A string looks like this:\012   *\012   *  @code\012   *                                        [_Rep]\012   *                                        _M_length\012   *   [basic_string<char_type>]            _M_capacity\012   *   _M_dataplus                          _M_refcount\012   *   _M_p ---------------->               unnamed array of char_type\012   *  @endcode\012   *\012   *  Where the _M_p points to the first character in the string, and\012   *  you cast it to a pointer-to-_Rep and subtract 1 to get a\012   *  pointer to the header.\012   *\012   *  This approach has the enormous advantage that a string object\012   *  requires only one allocation.  All the ugliness is confined\012   *  within a single pair of inline functions, which each compile to\012   *  a single \"add\" instruction: _Rep::_M_data(), and\012   *  string::_M_rep(); and the allocation function which gets a\012   *  block of raw bytes and with room enough and constructs a _Rep\012   *  object at the front.\012   *\012   *  The reason you want _M_data pointing to the character array and\012   *  not the _Rep is so that the debugger can see the string\012   *  contents. (Probably we should add a non-inline member to get\012   *  the _Rep for the debugger to use, so users can check the actual\012   *  string length.)\012   *\012   *  Note that the _Rep object is a POD so that you can have a\012   *  static \"empty string\" _Rep object already \"constructed\" before\012   *  static constructors have run.  The reference-count encoding is\012   *  chosen so that a 0 indicates one reference, so you never try to\012   *  destroy the empty-string _Rep object.\012   *\012   *  All but the last paragraph is considered pretty conventional\012   *  for a C++ string implementation.\012  */\012  // 21.3  Template class basic_string\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    class basic_string\012    {\012      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;\012\012      // Types:\012    public:\012      typedef _Traits					    traits_type;\012      typedef typename _Traits::char_type		    value_type;\012      typedef _Alloc					    allocator_type;\012      typedef typename _CharT_alloc_type::size_type	    size_type;\012      typedef typename _CharT_alloc_type::difference_type   difference_type;\012      typedef typename _CharT_alloc_type::reference	    reference;\012      typedef typename _CharT_alloc_type::const_reference   const_reference;\012      typedef typename _CharT_alloc_type::pointer	    pointer;\012      typedef typename _CharT_alloc_type::const_pointer	    const_pointer;\012      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;\012      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>\012                                                            const_iterator;\012      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;\012      typedef std::reverse_iterator<iterator>		    reverse_iterator;\012\012    private:\012      // _Rep: string representation\012      //   Invariants:\012      //   1. String really contains _M_length + 1 characters: due to 21.3.4\012      //      must be kept null-terminated.\012      //   2. _M_capacity >= _M_length\012      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).\012      //   3. _M_refcount has three states:\012      //      -1: leaked, one reference, no ref-copies allowed, non-const.\012      //       0: one reference, non-const.\012      //     n>0: n + 1 references, operations require a lock, const.\012      //   4. All fields==0 is an empty string, given the extra storage\012      //      beyond-the-end for a null terminator; thus, the shared\012      //      empty string representation needs no constructor.\012\012      struct _Rep_base\012      {\012	size_type		_M_length;\012	size_type		_M_capacity;\012	_Atomic_word		_M_refcount;\012      };\012\012      struct _Rep : _Rep_base\012      {\012	// Types:\012	typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;\012\012	// (Public) Data members:\012\012	// The maximum number of individual char_type elements of an\012	// individual string is determined by _S_max_size. This is the\012	// value that will be returned by max_size().  (Whereas npos\012	// is the maximum number of bytes the allocator can allocate.)\012	// If one was to divvy up the theoretical largest size string,\012	// with a terminating character and m _CharT elements, it'd\012	// look like this:\012	// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)\012	// Solving for m:\012	// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1\012	// In addition, this implementation quarters this amount.\012	static const size_type	_S_max_size;\012	static const _CharT	_S_terminal;\012\012	// The following storage is init'd to 0 by the linker, resulting\012        // (carefully) in an empty string with one reference.\012        static size_type _S_empty_rep_storage[];\012\012        static _Rep&\012        _S_empty_rep()\012        { \012	  // NB: Mild hack to avoid strict-aliasing warnings.  Note that\012	  // _S_empty_rep_storage is never modified and the punning should\012	  // be reasonably safe in this case.\012	  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);\012	  return *reinterpret_cast<_Rep*>(__p);\012	}\012\012        bool\012	_M_is_leaked() const\012        { return this->_M_refcount < 0; }\012\012        bool\012	_M_is_shared() const\012        { return this->_M_refcount > 0; }\012\012        void\012	_M_set_leaked()\012        { this->_M_refcount = -1; }\012\012        void\012	_M_set_sharable()\012        { this->_M_refcount = 0; }\012\012	void\012	_M_set_length_and_sharable(size_type __n)\012	{\012#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING\012	  if (__builtin_expect(this != &_S_empty_rep(), false))\012#endif\012	    {\012	      this->_M_set_sharable();  // One reference.\012	      this->_M_length = __n;\012	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);\012	      // grrr. (per 21.3.4)\012	      // You cannot leave those LWG people alone for a second.\012	    }\012	}\012\012	_CharT*\012	_M_refdata() throw()\012	{ return reinterpret_cast<_CharT*>(this + 1); }\012\012	_CharT*\012	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)\012	{\012	  return (!_M_is_leaked() && __alloc1 == __alloc2)\012	          ? _M_refcopy() : _M_clone(__alloc1);\012	}\012\012	// Create & Destroy\012	static _Rep*\012	_S_create(size_type, size_type, const _Alloc&);\012\012	void\012	_M_dispose(const _Alloc& __a)\012	{\012#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING\012	  if (__builtin_expect(this != &_S_empty_rep(), false))\012#endif\012	    if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,\012						       -1) <= 0)\012	      _M_destroy(__a);\012	}  // XXX MT\012\012	void\012	_M_destroy(const _Alloc&) throw();\012\012	_CharT*\012	_M_refcopy() throw()\012	{\012#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING\012	  if (__builtin_expect(this != &_S_empty_rep(), false))\012#endif\012            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);\012	  return _M_refdata();\012	}  // XXX MT\012\012	_CharT*\012	_M_clone(const _Alloc&, size_type __res = 0);\012      };\012\012      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\012      struct _Alloc_hider : _Alloc\012      {\012	_Alloc_hider(_CharT* __dat, const _Alloc& __a)\012	: _Alloc(__a), _M_p(__dat) { }\012\012	_CharT* _M_p; // The actual data.\012      };\012\012    public:\012      // Data Members (public):\012      // NB: This is an unsigned type, and thus represents the maximum\012      // size that the allocator can hold.\012      ///  Value returned by various member functions when they fail.\012      static const size_type	npos = static_cast<size_type>(-1);\012\012    private:\012      // Data Members (private):\012      mutable _Alloc_hider	_M_dataplus;\012\012      _CharT*\012      _M_data() const\012      { return  _M_dataplus._M_p; }\012\012      _CharT*\012      _M_data(_CharT* __p)\012      { return (_M_dataplus._M_p = __p); }\012\012      _Rep*\012      _M_rep() const\012      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }\012\012      // For the internal use we have functions similar to `begin'/`end'\012      // but they do not call _M_leak.\012      iterator\012      _M_ibegin() const\012      { return iterator(_M_data()); }\012\012      iterator\012      _M_iend() const\012      { return iterator(_M_data() + this->size()); }\012\012      void\012      _M_leak()    // for use in begin() & non-const op[]\012      {\012	if (!_M_rep()->_M_is_leaked())\012	  _M_leak_hard();\012      }\012\012      size_type\012      _M_check(size_type __pos, const char* __s) const\012      {\012	if (__pos > this->size())\012	  __throw_out_of_range(__N(__s));\012	return __pos;\012      }\012\012      void\012      _M_check_length(size_type __n1, size_type __n2, const char* __s) const\012      {\012	if (this->max_size() - (this->size() - __n1) < __n2)\012	  __throw_length_error(__N(__s));\012      }\012\012      // NB: _M_limit doesn't check for a bad __pos value.\012      size_type\012      _M_limit(size_type __pos, size_type __off) const\012      {\012	const bool __testoff =  __off < this->size() - __pos;\012	return __testoff ? __off : this->size() - __pos;\012      }\012\012      // True if _Rep and source do not overlap.\012      bool\012      _M_disjunct(const _CharT* __s) const\012      {\012	return (less<const _CharT*>()(__s, _M_data())\012		|| less<const _CharT*>()(_M_data() + this->size(), __s));\012      }\012\012      // When __n = 1 way faster than the general multichar\012      // traits_type::copy/move/assign.\012      static void\012      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)\012      {\012	if (__n == 1)\012	  traits_type::assign(*__d, *__s);\012	else\012	  traits_type::copy(__d, __s, __n);\012      }\012\012      static void\012      _M_move(_CharT* __d, const _CharT* __s, size_type __n)\012      {\012	if (__n == 1)\012	  traits_type::assign(*__d, *__s);\012	else\012	  traits_type::move(__d, __s, __n);	  \012      }\012\012      static void\012      _M_assign(_CharT* __d, size_type __n, _CharT __c)\012      {\012	if (__n == 1)\012	  traits_type::assign(*__d, __c);\012	else\012	  traits_type::assign(__d, __n, __c);	  \012      }\012\012      // _S_copy_chars is a separate template to permit specialization\012      // to optimize for the common case of pointers as iterators.\012      template<class _Iterator>\012        static void\012        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\012        {\012	  for (; __k1 != __k2; ++__k1, ++__p)\012	    traits_type::assign(*__p, *__k1); // These types are off.\012	}\012\012      static void\012      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)\012      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\012\012      static void\012      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\012      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\012\012      static void\012      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)\012      { _M_copy(__p, __k1, __k2 - __k1); }\012\012      static void\012      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\012      { _M_copy(__p, __k1, __k2 - __k1); }\012\012      static int\012      _S_compare(size_type __n1, size_type __n2)\012      {\012	const difference_type __d = difference_type(__n1 - __n2);\012\012	if (__d > __gnu_cxx::__numeric_traits<int>::__max)\012	  return __gnu_cxx::__numeric_traits<int>::__max;\012	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)\012	  return __gnu_cxx::__numeric_traits<int>::__min;\012	else\012	  return int(__d);\012      }\012\012      void\012      _M_mutate(size_type __pos, size_type __len1, size_type __len2);\012\012      void\012      _M_leak_hard();\012\012      static _Rep&\012      _S_empty_rep()\012      { return _Rep::_S_empty_rep(); }\012\012    public:\012      // Construct/copy/destroy:\012      // NB: We overload ctors in some cases instead of using default\012      // arguments, per 17.4.4.4 para. 2 item 2.\012\012      /**\012       *  @brief  Default constructor creates an empty string.\012       */\012      inline\012      basic_string();\012\012      /**\012       *  @brief  Construct an empty string using allocator @a a.\012       */\012      explicit\012      basic_string(const _Alloc& __a);\012\012      // NB: per LWG issue 42, semantics different from IS:\012      /**\012       *  @brief  Construct string with copy of value of @a str.\012       *  @param  str  Source string.\012       */\012      basic_string(const basic_string& __str);\012      /**\012       *  @brief  Construct string as copy of a substring.\012       *  @param  str  Source string.\012       *  @param  pos  Index of first character to copy from.\012       *  @param  n  Number of characters to copy (default remainder).\012       */\012      basic_string(const basic_string& __str, size_type __pos,\012		   size_type __n = npos);\012      /**\012       *  @brief  Construct string as copy of a substring.\012       *  @param  str  Source string.\012       *  @param  pos  Index of first character to copy from.\012       *  @param  n  Number of characters to copy.\012       *  @param  a  Allocator to use.\012       */\012      basic_string(const basic_string& __str, size_type __pos,\012		   size_type __n, const _Alloc& __a);\012\012      /**\012       *  @brief  Construct string initialized by a character array.\012       *  @param  s  Source character array.\012       *  @param  n  Number of characters to copy.\012       *  @param  a  Allocator to use (default is default allocator).\012       *\012       *  NB: @a s must have at least @a n characters, '\\\\0' has no special\012       *  meaning.\012       */\012      basic_string(const _CharT* __s, size_type __n,\012		   const _Alloc& __a = _Alloc());\012      /**\012       *  @brief  Construct string as copy of a C string.\012       *  @param  s  Source C string.\012       *  @param  a  Allocator to use (default is default allocator).\012       */\012      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());\012      /**\012       *  @brief  Construct string as multiple characters.\012       *  @param  n  Number of characters.\012       *  @param  c  Character to use.\012       *  @param  a  Allocator to use (default is default allocator).\012       */\012      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      /**\012       *  @brief  Construct string from an initializer list.\012       *  @param  l  std::initializer_list of characters.\012       *  @param  a  Allocator to use (default is default allocator).\012       */\012      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());\012#endif // __GXX_EXPERIMENTAL_CXX0X__\012\012      /**\012       *  @brief  Construct string as copy of a range.\012       *  @param  beg  Start of range.\012       *  @param  end  End of range.\012       *  @param  a  Allocator to use (default is default allocator).\012       */\012      template<class _InputIterator>\012        basic_string(_InputIterator __beg, _InputIterator __end,\012		     const _Alloc& __a = _Alloc());\012\012      /**\012       *  @brief  Destroy the string instance.\012       */\012      ~basic_string()\012      { _M_rep()->_M_dispose(this->get_allocator()); }\012\012      /**\012       *  @brief  Assign the value of @a str to this string.\012       *  @param  str  Source string.\012       */\012      basic_string&\012      operator=(const basic_string& __str) \012      { return this->assign(__str); }\012\012      /**\012       *  @brief  Copy contents of @a s into this string.\012       *  @param  s  Source null-terminated string.\012       */\012      basic_string&\012      operator=(const _CharT* __s) \012      { return this->assign(__s); }\012\012      /**\012       *  @brief  Set value to string of length 1.\012       *  @param  c  Source character.\012       *\012       *  Assigning to a character makes this string length 1 and\012       *  (*this)[0] == @a c.\012       */\012      basic_string&\012      operator=(_CharT __c) \012      { \012	this->assign(1, __c); \012	return *this;\012      }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      /**\012       *  @brief  Set value to string constructed from initializer list.\012       *  @param  l  std::initializer_list.\012       */\012      basic_string&\012      operator=(initializer_list<_CharT> __l)\012      {\012	this->assign (__l.begin(), __l.end());\012	return *this;\012      }\012#endif // __GXX_EXPERIMENTAL_CXX0X__\012\012      // Iterators:\012      /**\012       *  Returns a read/write iterator that points to the first character in\012       *  the %string.  Unshares the string.\012       */\012      iterator\012      begin()\012      {\012	_M_leak();\012	return iterator(_M_data());\012      }\012\012      /**\012       *  Returns a read-only (constant) iterator that points to the first\012       *  character in the %string.\012       */\012      const_iterator\012      begin() const\012      { return const_iterator(_M_data()); }\012\012      /**\012       *  Returns a read/write iterator that points one past the last\012       *  character in the %string.  Unshares the string.\012       */\012      iterator\012      end()\012      {\012	_M_leak();\012	return iterator(_M_data() + this->size());\012      }\012\012      /**\012       *  Returns a read-only (constant) iterator that points one past the\012       *  last character in the %string.\012       */\012      const_iterator\012      end() const\012      { return const_iterator(_M_data() + this->size()); }\012\012      /**\012       *  Returns a read/write reverse iterator that points to the last\012       *  character in the %string.  Iteration is done in reverse element\012       *  order.  Unshares the string.\012       */\012      reverse_iterator\012      rbegin()\012      { return reverse_iterator(this->end()); }\012\012      /**\012       *  Returns a read-only (constant) reverse iterator that points\012       *  to the last character in the %string.  Iteration is done in\012       *  reverse element order.\012       */\012      const_reverse_iterator\012      rbegin() const\012      { return const_reverse_iterator(this->end()); }\012\012      /**\012       *  Returns a read/write reverse iterator that points to one before the\012       *  first character in the %string.  Iteration is done in reverse\012       *  element order.  Unshares the string.\012       */\012      reverse_iterator\012      rend()\012      { return reverse_iterator(this->begin()); }\012\012      /**\012       *  Returns a read-only (constant) reverse iterator that points\012       *  to one before the first character in the %string.  Iteration\012       *  is done in reverse element order.\012       */\012      const_reverse_iterator\012      rend() const\012      { return const_reverse_iterator(this->begin()); }\012\012    public:\012      // Capacity:\012      ///  Returns the number of characters in the string, not including any\012      ///  null-termination.\012      size_type\012      size() const\012      { return _M_rep()->_M_length; }\012\012      ///  Returns the number of characters in the string, not including any\012      ///  null-termination.\012      size_type\012      length() const\012      { return _M_rep()->_M_length; }\012\012      /// Returns the size() of the largest possible %string.\012      size_type\012      max_size() const\012      { return _Rep::_S_max_size; }\012\012      /**\012       *  @brief  Resizes the %string to the specified number of characters.\012       *  @param  n  Number of characters the %string should contain.\012       *  @param  c  Character to fill any new elements.\012       *\012       *  This function will %resize the %string to the specified\012       *  number of characters.  If the number is smaller than the\012       *  %string's current size the %string is truncated, otherwise\012       *  the %string is extended and new elements are set to @a c.\012       */\012      void\012      resize(size_type __n, _CharT __c);\012\012      /**\012       *  @brief  Resizes the %string to the specified number of characters.\012       *  @param  n  Number of characters the %string should contain.\012       *\012       *  This function will resize the %string to the specified length.  If\012       *  the new size is smaller than the %string's current size the %string\012       *  is truncated, otherwise the %string is extended and new characters\012       *  are default-constructed.  For basic types such as char, this means\012       *  setting them to 0.\012       */\012      void\012      resize(size_type __n)\012      { this->resize(__n, _CharT()); }\012\012      /**\012       *  Returns the total number of characters that the %string can hold\012       *  before needing to allocate more memory.\012       */\012      size_type\012      capacity() const\012      { return _M_rep()->_M_capacity; }\012\012      /**\012       *  @brief  Attempt to preallocate enough memory for specified number of\012       *          characters.\012       *  @param  res_arg  Number of characters required.\012       *  @throw  std::length_error  If @a res_arg exceeds @c max_size().\012       *\012       *  This function attempts to reserve enough memory for the\012       *  %string to hold the specified number of characters.  If the\012       *  number requested is more than max_size(), length_error is\012       *  thrown.\012       *\012       *  The advantage of this function is that if optimal code is a\012       *  necessity and the user can determine the string length that will be\012       *  required, the user can reserve the memory in %advance, and thus\012       *  prevent a possible reallocation of memory and copying of %string\012       *  data.\012       */\012      void\012      reserve(size_type __res_arg = 0);\012\012      /**\012       *  Erases the string, making it empty.\012       */\012      void\012      clear()\012      { _M_mutate(0, this->size(), 0); }\012\012      /**\012       *  Returns true if the %string is empty.  Equivalent to *this == \"\".\012       */\012      bool\012      empty() const\012      { return this->size() == 0; }\012\012      // Element access:\012      /**\012       *  @brief  Subscript access to the data contained in the %string.\012       *  @param  pos  The index of the character to access.\012       *  @return  Read-only (constant) reference to the character.\012       *\012       *  This operator allows for easy, array-style, data access.\012       *  Note that data access with this operator is unchecked and\012       *  out_of_range lookups are not defined. (For checked lookups\012       *  see at().)\012       */\012      const_reference\012      operator[] (size_type __pos) const\012      {\012	_GLIBCXX_DEBUG_ASSERT(__pos <= size());\012	return _M_data()[__pos];\012      }\012\012      /**\012       *  @brief  Subscript access to the data contained in the %string.\012       *  @param  pos  The index of the character to access.\012       *  @return  Read/write reference to the character.\012       *\012       *  This operator allows for easy, array-style, data access.\012       *  Note that data access with this operator is unchecked and\012       *  out_of_range lookups are not defined. (For checked lookups\012       *  see at().)  Unshares the string.\012       */\012      reference\012      operator[](size_type __pos)\012      {\012        // allow pos == size() as v3 extension:\012	_GLIBCXX_DEBUG_ASSERT(__pos <= size());\012        // but be strict in pedantic mode:\012	_GLIBCXX_DEBUG_PEDASSERT(__pos < size());\012	_M_leak();\012	return _M_data()[__pos];\012      }\012\012      /**\012       *  @brief  Provides access to the data contained in the %string.\012       *  @param n The index of the character to access.\012       *  @return  Read-only (const) reference to the character.\012       *  @throw  std::out_of_range  If @a n is an invalid index.\012       *\012       *  This function provides for safer data access.  The parameter is\012       *  first checked that it is in the range of the string.  The function\012       *  throws out_of_range if the check fails.\012       */\012      const_reference\012      at(size_type __n) const\012      {\012	if (__n >= this->size())\012	  __throw_out_of_range(__N(\"basic_string::at\"));\012	return _M_data()[__n];\012      }\012\012      /**\012       *  @brief  Provides access to the data contained in the %string.\012       *  @param n The index of the character to access.\012       *  @return  Read/write reference to the character.\012       *  @throw  std::out_of_range  If @a n is an invalid index.\012       *\012       *  This function provides for safer data access.  The parameter is\012       *  first checked that it is in the range of the string.  The function\012       *  throws out_of_range if the check fails.  Success results in\012       *  unsharing the string.\012       */\012      reference\012      at(size_type __n)\012      {\012	if (__n >= size())\012	  __throw_out_of_range(__N(\"basic_string::at\"));\012	_M_leak();\012	return _M_data()[__n];\012      }\012\012      // Modifiers:\012      /**\012       *  @brief  Append a string to this string.\012       *  @param str  The string to append.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      operator+=(const basic_string& __str)\012      { return this->append(__str); }\012\012      /**\012       *  @brief  Append a C string.\012       *  @param s  The C string to append.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      operator+=(const _CharT* __s)\012      { return this->append(__s); }\012\012      /**\012       *  @brief  Append a character.\012       *  @param c  The character to append.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      operator+=(_CharT __c)\012      { \012	this->push_back(__c);\012	return *this;\012      }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      /**\012       *  @brief  Append an initializer_list of characters.\012       *  @param l  The initializer_list of characters to be appended.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      operator+=(initializer_list<_CharT> __l)\012      { return this->append(__l.begin(), __l.end()); }\012#endif // __GXX_EXPERIMENTAL_CXX0X__\012\012      /**\012       *  @brief  Append a string to this string.\012       *  @param str  The string to append.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      append(const basic_string& __str);\012\012      /**\012       *  @brief  Append a substring.\012       *  @param str  The string to append.\012       *  @param pos  Index of the first character of str to append.\012       *  @param n  The number of characters to append.\012       *  @return  Reference to this string.\012       *  @throw  std::out_of_range if @a pos is not a valid index.\012       *\012       *  This function appends @a n characters from @a str starting at @a pos\012       *  to this string.  If @a n is is larger than the number of available\012       *  characters in @a str, the remainder of @a str is appended.\012       */\012      basic_string&\012      append(const basic_string& __str, size_type __pos, size_type __n);\012\012      /**\012       *  @brief  Append a C substring.\012       *  @param s  The C string to append.\012       *  @param n  The number of characters to append.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      append(const _CharT* __s, size_type __n);\012\012      /**\012       *  @brief  Append a C string.\012       *  @param s  The C string to append.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      append(const _CharT* __s)\012      {\012	__glibcxx_requires_string(__s);\012	return this->append(__s, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Append multiple characters.\012       *  @param n  The number of characters to append.\012       *  @param c  The character to use.\012       *  @return  Reference to this string.\012       *\012       *  Appends n copies of c to this string.\012       */\012      basic_string&\012      append(size_type __n, _CharT __c);\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      /**\012       *  @brief  Append an initializer_list of characters.\012       *  @param l  The initializer_list of characters to append.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      append(initializer_list<_CharT> __l)\012      { return this->append(__l.begin(), __l.end()); }\012#endif // __GXX_EXPERIMENTAL_CXX0X__\012\012      /**\012       *  @brief  Append a range of characters.\012       *  @param first  Iterator referencing the first character to append.\012       *  @param last  Iterator marking the end of the range.\012       *  @return  Reference to this string.\012       *\012       *  Appends characters in the range [first,last) to this string.\012       */\012      template<class _InputIterator>\012        basic_string&\012        append(_InputIterator __first, _InputIterator __last)\012        { return this->replace(_M_iend(), _M_iend(), __first, __last); }\012\012      /**\012       *  @brief  Append a single character.\012       *  @param c  Character to append.\012       */\012      void\012      push_back(_CharT __c)\012      { \012	const size_type __len = 1 + this->size();\012	if (__len > this->capacity() || _M_rep()->_M_is_shared())\012	  this->reserve(__len);\012	traits_type::assign(_M_data()[this->size()], __c);\012	_M_rep()->_M_set_length_and_sharable(__len);\012      }\012\012      /**\012       *  @brief  Set value to contents of another string.\012       *  @param  str  Source string to use.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      assign(const basic_string& __str);\012\012      /**\012       *  @brief  Set value to a substring of a string.\012       *  @param str  The string to use.\012       *  @param pos  Index of the first character of str.\012       *  @param n  Number of characters to use.\012       *  @return  Reference to this string.\012       *  @throw  std::out_of_range if @a pos is not a valid index.\012       *\012       *  This function sets this string to the substring of @a str consisting\012       *  of @a n characters at @a pos.  If @a n is is larger than the number\012       *  of available characters in @a str, the remainder of @a str is used.\012       */\012      basic_string&\012      assign(const basic_string& __str, size_type __pos, size_type __n)\012      { return this->assign(__str._M_data()\012			    + __str._M_check(__pos, \"basic_string::assign\"),\012			    __str._M_limit(__pos, __n)); }\012\012      /**\012       *  @brief  Set value to a C substring.\012       *  @param s  The C string to use.\012       *  @param n  Number of characters to use.\012       *  @return  Reference to this string.\012       *\012       *  This function sets the value of this string to the first @a n\012       *  characters of @a s.  If @a n is is larger than the number of\012       *  available characters in @a s, the remainder of @a s is used.\012       */\012      basic_string&\012      assign(const _CharT* __s, size_type __n);\012\012      /**\012       *  @brief  Set value to contents of a C string.\012       *  @param s  The C string to use.\012       *  @return  Reference to this string.\012       *\012       *  This function sets the value of this string to the value of @a s.\012       *  The data is copied, so there is no dependence on @a s once the\012       *  function returns.\012       */\012      basic_string&\012      assign(const _CharT* __s)\012      {\012	__glibcxx_requires_string(__s);\012	return this->assign(__s, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Set value to multiple characters.\012       *  @param n  Length of the resulting string.\012       *  @param c  The character to use.\012       *  @return  Reference to this string.\012       *\012       *  This function sets the value of this string to @a n copies of\012       *  character @a c.\012       */\012      basic_string&\012      assign(size_type __n, _CharT __c)\012      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }\012\012      /**\012       *  @brief  Set value to a range of characters.\012       *  @param first  Iterator referencing the first character to append.\012       *  @param last  Iterator marking the end of the range.\012       *  @return  Reference to this string.\012       *\012       *  Sets value of string to characters in the range [first,last).\012      */\012      template<class _InputIterator>\012        basic_string&\012        assign(_InputIterator __first, _InputIterator __last)\012        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      /**\012       *  @brief  Set value to an initializer_list of characters.\012       *  @param l  The initializer_list of characters to assign.\012       *  @return  Reference to this string.\012       */\012      basic_string&\012      assign(initializer_list<_CharT> __l)\012      { return this->assign(__l.begin(), __l.end()); }\012#endif // __GXX_EXPERIMENTAL_CXX0X__\012\012      /**\012       *  @brief  Insert multiple characters.\012       *  @param p  Iterator referencing location in string to insert at.\012       *  @param n  Number of characters to insert\012       *  @param c  The character to insert.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Inserts @a n copies of character @a c starting at the position\012       *  referenced by iterator @a p.  If adding characters causes the length\012       *  to exceed max_size(), length_error is thrown.  The value of the\012       *  string doesn't change if an error is thrown.\012      */\012      void\012      insert(iterator __p, size_type __n, _CharT __c)\012      {	this->replace(__p, __p, __n, __c);  }\012\012      /**\012       *  @brief  Insert a range of characters.\012       *  @param p  Iterator referencing location in string to insert at.\012       *  @param beg  Start of range.\012       *  @param end  End of range.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Inserts characters in range [beg,end).  If adding characters causes\012       *  the length to exceed max_size(), length_error is thrown.  The value\012       *  of the string doesn't change if an error is thrown.\012      */\012      template<class _InputIterator>\012        void\012        insert(iterator __p, _InputIterator __beg, _InputIterator __end)\012        { this->replace(__p, __p, __beg, __end); }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      /**\012       *  @brief  Insert an initializer_list of characters.\012       *  @param p  Iterator referencing location in string to insert at.\012       *  @param l  The initializer_list of characters to insert.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       */\012      void\012      insert(iterator __p, initializer_list<_CharT> __l)\012      { this->insert(__p, __l.begin(), __l.end()); }\012#endif // __GXX_EXPERIMENTAL_CXX0X__\012\012      /**\012       *  @brief  Insert value of a string.\012       *  @param pos1  Iterator referencing location in string to insert at.\012       *  @param str  The string to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Inserts value of @a str starting at @a pos1.  If adding characters\012       *  causes the length to exceed max_size(), length_error is thrown.  The\012       *  value of the string doesn't change if an error is thrown.\012      */\012      basic_string&\012      insert(size_type __pos1, const basic_string& __str)\012      { return this->insert(__pos1, __str, size_type(0), __str.size()); }\012\012      /**\012       *  @brief  Insert a substring.\012       *  @param pos1  Iterator referencing location in string to insert at.\012       *  @param str  The string to insert.\012       *  @param pos2  Start of characters in str to insert.\012       *  @param n  Number of characters to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *  @throw  std::out_of_range  If @a pos1 > size() or\012       *  @a pos2 > @a str.size().\012       *\012       *  Starting at @a pos1, insert @a n character of @a str beginning with\012       *  @a pos2.  If adding characters causes the length to exceed\012       *  max_size(), length_error is thrown.  If @a pos1 is beyond the end of\012       *  this string or @a pos2 is beyond the end of @a str, out_of_range is\012       *  thrown.  The value of the string doesn't change if an error is\012       *  thrown.\012      */\012      basic_string&\012      insert(size_type __pos1, const basic_string& __str,\012	     size_type __pos2, size_type __n)\012      { return this->insert(__pos1, __str._M_data()\012			    + __str._M_check(__pos2, \"basic_string::insert\"),\012			    __str._M_limit(__pos2, __n)); }\012\012      /**\012       *  @brief  Insert a C substring.\012       *  @param pos  Iterator referencing location in string to insert at.\012       *  @param s  The C string to insert.\012       *  @param n  The number of characters to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *  @throw  std::out_of_range  If @a pos is beyond the end of this\012       *  string.\012       *\012       *  Inserts the first @a n characters of @a s starting at @a pos.  If\012       *  adding characters causes the length to exceed max_size(),\012       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is\012       *  thrown.  The value of the string doesn't change if an error is\012       *  thrown.\012      */\012      basic_string&\012      insert(size_type __pos, const _CharT* __s, size_type __n);\012\012      /**\012       *  @brief  Insert a C string.\012       *  @param pos  Iterator referencing location in string to insert at.\012       *  @param s  The C string to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *  @throw  std::out_of_range  If @a pos is beyond the end of this\012       *  string.\012       *\012       *  Inserts the first @a n characters of @a s starting at @a pos.  If\012       *  adding characters causes the length to exceed max_size(),\012       *  length_error is thrown.  If @a pos is beyond end(), out_of_range is\012       *  thrown.  The value of the string doesn't change if an error is\012       *  thrown.\012      */\012      basic_string&\012      insert(size_type __pos, const _CharT* __s)\012      {\012	__glibcxx_requires_string(__s);\012	return this->insert(__pos, __s, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Insert multiple characters.\012       *  @param pos  Index in string to insert at.\012       *  @param n  Number of characters to insert\012       *  @param c  The character to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *  @throw  std::out_of_range  If @a pos is beyond the end of this\012       *  string.\012       *\012       *  Inserts @a n copies of character @a c starting at index @a pos.  If\012       *  adding characters causes the length to exceed max_size(),\012       *  length_error is thrown.  If @a pos > length(), out_of_range is\012       *  thrown.  The value of the string doesn't change if an error is\012       *  thrown.\012      */\012      basic_string&\012      insert(size_type __pos, size_type __n, _CharT __c)\012      { return _M_replace_aux(_M_check(__pos, \"basic_string::insert\"),\012			      size_type(0), __n, __c); }\012\012      /**\012       *  @brief  Insert one character.\012       *  @param p  Iterator referencing position in string to insert at.\012       *  @param c  The character to insert.\012       *  @return  Iterator referencing newly inserted char.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Inserts character @a c at position referenced by @a p.  If adding\012       *  character causes the length to exceed max_size(), length_error is\012       *  thrown.  If @a p is beyond end of string, out_of_range is thrown.\012       *  The value of the string doesn't change if an error is thrown.\012      */\012      iterator\012      insert(iterator __p, _CharT __c)\012      {\012	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());\012	const size_type __pos = __p - _M_ibegin();\012	_M_replace_aux(__pos, size_type(0), size_type(1), __c);\012	_M_rep()->_M_set_leaked();\012	return iterator(_M_data() + __pos);\012      }\012\012      /**\012       *  @brief  Remove characters.\012       *  @param pos  Index of first character to remove (default 0).\012       *  @param n  Number of characters to remove (default remainder).\012       *  @return  Reference to this string.\012       *  @throw  std::out_of_range  If @a pos is beyond the end of this\012       *  string.\012       *\012       *  Removes @a n characters from this string starting at @a pos.  The\012       *  length of the string is reduced by @a n.  If there are < @a n\012       *  characters to remove, the remainder of the string is truncated.  If\012       *  @a p is beyond end of string, out_of_range is thrown.  The value of\012       *  the string doesn't change if an error is thrown.\012      */\012      basic_string&\012      erase(size_type __pos = 0, size_type __n = npos)\012      { \012	_M_mutate(_M_check(__pos, \"basic_string::erase\"),\012		  _M_limit(__pos, __n), size_type(0));\012	return *this;\012      }\012\012      /**\012       *  @brief  Remove one character.\012       *  @param position  Iterator referencing the character to remove.\012       *  @return  iterator referencing same location after removal.\012       *\012       *  Removes the character at @a position from this string. The value\012       *  of the string doesn't change if an error is thrown.\012      */\012      iterator\012      erase(iterator __position)\012      {\012	_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()\012				 && __position < _M_iend());\012	const size_type __pos = __position - _M_ibegin();\012	_M_mutate(__pos, size_type(1), size_type(0));\012	_M_rep()->_M_set_leaked();\012	return iterator(_M_data() + __pos);\012      }\012\012      /**\012       *  @brief  Remove a range of characters.\012       *  @param first  Iterator referencing the first character to remove.\012       *  @param last  Iterator referencing the end of the range.\012       *  @return  Iterator referencing location of first after removal.\012       *\012       *  Removes the characters in the range [first,last) from this string.\012       *  The value of the string doesn't change if an error is thrown.\012      */\012      iterator\012      erase(iterator __first, iterator __last);\012 \012      /**\012       *  @brief  Replace characters with value from another string.\012       *  @param pos  Index of first character to replace.\012       *  @param n  Number of characters to be replaced.\012       *  @param str  String to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::out_of_range  If @a pos is beyond the end of this\012       *  string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [pos,pos+n) from this string.\012       *  In place, the value of @a str is inserted.  If @a pos is beyond end\012       *  of string, out_of_range is thrown.  If the length of the result\012       *  exceeds max_size(), length_error is thrown.  The value of the string\012       *  doesn't change if an error is thrown.\012      */\012      basic_string&\012      replace(size_type __pos, size_type __n, const basic_string& __str)\012      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\012\012      /**\012       *  @brief  Replace characters with value from another string.\012       *  @param pos1  Index of first character to replace.\012       *  @param n1  Number of characters to be replaced.\012       *  @param str  String to insert.\012       *  @param pos2  Index of first character of str to use.\012       *  @param n2  Number of characters from str to use.\012       *  @return  Reference to this string.\012       *  @throw  std::out_of_range  If @a pos1 > size() or @a pos2 >\012       *  str.size().\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [pos1,pos1 + n) from this\012       *  string.  In place, the value of @a str is inserted.  If @a pos is\012       *  beyond end of string, out_of_range is thrown.  If the length of the\012       *  result exceeds max_size(), length_error is thrown.  The value of the\012       *  string doesn't change if an error is thrown.\012      */\012      basic_string&\012      replace(size_type __pos1, size_type __n1, const basic_string& __str,\012	      size_type __pos2, size_type __n2)\012      { return this->replace(__pos1, __n1, __str._M_data()\012			     + __str._M_check(__pos2, \"basic_string::replace\"),\012			     __str._M_limit(__pos2, __n2)); }\012\012      /**\012       *  @brief  Replace characters with value of a C substring.\012       *  @param pos  Index of first character to replace.\012       *  @param n1  Number of characters to be replaced.\012       *  @param s  C string to insert.\012       *  @param n2  Number of characters from @a s to use.\012       *  @return  Reference to this string.\012       *  @throw  std::out_of_range  If @a pos1 > size().\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [pos,pos + n1) from this string.\012       *  In place, the first @a n2 characters of @a s are inserted, or all\012       *  of @a s if @a n2 is too large.  If @a pos is beyond end of string,\012       *  out_of_range is thrown.  If the length of result exceeds max_size(),\012       *  length_error is thrown.  The value of the string doesn't change if\012       *  an error is thrown.\012      */\012      basic_string&\012      replace(size_type __pos, size_type __n1, const _CharT* __s,\012	      size_type __n2);\012\012      /**\012       *  @brief  Replace characters with value of a C string.\012       *  @param pos  Index of first character to replace.\012       *  @param n1  Number of characters to be replaced.\012       *  @param s  C string to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::out_of_range  If @a pos > size().\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [pos,pos + n1) from this string.\012       *  In place, the first @a n characters of @a s are inserted.  If @a\012       *  pos is beyond end of string, out_of_range is thrown.  If the length\012       *  of result exceeds max_size(), length_error is thrown.  The value of\012       *  the string doesn't change if an error is thrown.\012      */\012      basic_string&\012      replace(size_type __pos, size_type __n1, const _CharT* __s)\012      {\012	__glibcxx_requires_string(__s);\012	return this->replace(__pos, __n1, __s, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Replace characters with multiple characters.\012       *  @param pos  Index of first character to replace.\012       *  @param n1  Number of characters to be replaced.\012       *  @param n2  Number of characters to insert.\012       *  @param c  Character to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::out_of_range  If @a pos > size().\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [pos,pos + n1) from this string.\012       *  In place, @a n2 copies of @a c are inserted.  If @a pos is beyond\012       *  end of string, out_of_range is thrown.  If the length of result\012       *  exceeds max_size(), length_error is thrown.  The value of the string\012       *  doesn't change if an error is thrown.\012      */\012      basic_string&\012      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\012      { return _M_replace_aux(_M_check(__pos, \"basic_string::replace\"),\012			      _M_limit(__pos, __n1), __n2, __c); }\012\012      /**\012       *  @brief  Replace range of characters with string.\012       *  @param i1  Iterator referencing start of range to replace.\012       *  @param i2  Iterator referencing end of range to replace.\012       *  @param str  String value to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [i1,i2).  In place, the value of\012       *  @a str is inserted.  If the length of result exceeds max_size(),\012       *  length_error is thrown.  The value of the string doesn't change if\012       *  an error is thrown.\012      */\012      basic_string&\012      replace(iterator __i1, iterator __i2, const basic_string& __str)\012      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\012\012      /**\012       *  @brief  Replace range of characters with C substring.\012       *  @param i1  Iterator referencing start of range to replace.\012       *  @param i2  Iterator referencing end of range to replace.\012       *  @param s  C string value to insert.\012       *  @param n  Number of characters from s to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [i1,i2).  In place, the first @a\012       *  n characters of @a s are inserted.  If the length of result exceeds\012       *  max_size(), length_error is thrown.  The value of the string doesn't\012       *  change if an error is thrown.\012      */\012      basic_string&\012      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)\012      {\012	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\012				 && __i2 <= _M_iend());\012	return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);\012      }\012\012      /**\012       *  @brief  Replace range of characters with C string.\012       *  @param i1  Iterator referencing start of range to replace.\012       *  @param i2  Iterator referencing end of range to replace.\012       *  @param s  C string value to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [i1,i2).  In place, the\012       *  characters of @a s are inserted.  If the length of result exceeds\012       *  max_size(), length_error is thrown.  The value of the string doesn't\012       *  change if an error is thrown.\012      */\012      basic_string&\012      replace(iterator __i1, iterator __i2, const _CharT* __s)\012      {\012	__glibcxx_requires_string(__s);\012	return this->replace(__i1, __i2, __s, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Replace range of characters with multiple characters\012       *  @param i1  Iterator referencing start of range to replace.\012       *  @param i2  Iterator referencing end of range to replace.\012       *  @param n  Number of characters to insert.\012       *  @param c  Character to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [i1,i2).  In place, @a n copies\012       *  of @a c are inserted.  If the length of result exceeds max_size(),\012       *  length_error is thrown.  The value of the string doesn't change if\012       *  an error is thrown.\012      */\012      basic_string&\012      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\012      {\012	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\012				 && __i2 <= _M_iend());\012	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);\012      }\012\012      /**\012       *  @brief  Replace range of characters with range.\012       *  @param i1  Iterator referencing start of range to replace.\012       *  @param i2  Iterator referencing end of range to replace.\012       *  @param k1  Iterator referencing start of range to insert.\012       *  @param k2  Iterator referencing end of range to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [i1,i2).  In place, characters\012       *  in the range [k1,k2) are inserted.  If the length of result exceeds\012       *  max_size(), length_error is thrown.  The value of the string doesn't\012       *  change if an error is thrown.\012      */\012      template<class _InputIterator>\012        basic_string&\012        replace(iterator __i1, iterator __i2,\012		_InputIterator __k1, _InputIterator __k2)\012        {\012	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\012				   && __i2 <= _M_iend());\012	  __glibcxx_requires_valid_range(__k1, __k2);\012	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\012	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());\012	}\012\012      // Specializations for the common case of pointer and iterator:\012      // useful to avoid the overhead of temporary buffering in _M_replace.\012      basic_string&\012      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\012      {\012	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\012				 && __i2 <= _M_iend());\012	__glibcxx_requires_valid_range(__k1, __k2);\012	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\012			     __k1, __k2 - __k1);\012      }\012\012      basic_string&\012      replace(iterator __i1, iterator __i2,\012	      const _CharT* __k1, const _CharT* __k2)\012      {\012	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\012				 && __i2 <= _M_iend());\012	__glibcxx_requires_valid_range(__k1, __k2);\012	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\012			     __k1, __k2 - __k1);\012      }\012\012      basic_string&\012      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\012      {\012	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\012				 && __i2 <= _M_iend());\012	__glibcxx_requires_valid_range(__k1, __k2);\012	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\012			     __k1.base(), __k2 - __k1);\012      }\012\012      basic_string&\012      replace(iterator __i1, iterator __i2,\012	      const_iterator __k1, const_iterator __k2)\012      {\012	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\012				 && __i2 <= _M_iend());\012	__glibcxx_requires_valid_range(__k1, __k2);\012	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\012			     __k1.base(), __k2 - __k1);\012      }\012      \012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      /**\012       *  @brief  Replace range of characters with initializer_list.\012       *  @param i1  Iterator referencing start of range to replace.\012       *  @param i2  Iterator referencing end of range to replace.\012       *  @param l  The initializer_list of characters to insert.\012       *  @return  Reference to this string.\012       *  @throw  std::length_error  If new length exceeds @c max_size().\012       *\012       *  Removes the characters in the range [i1,i2).  In place, characters\012       *  in the range [k1,k2) are inserted.  If the length of result exceeds\012       *  max_size(), length_error is thrown.  The value of the string doesn't\012       *  change if an error is thrown.\012      */\012      basic_string& replace(iterator __i1, iterator __i2,\012			    initializer_list<_CharT> __l)\012      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }\012#endif // __GXX_EXPERIMENTAL_CXX0X__\012\012    private:\012      template<class _Integer>\012	basic_string&\012	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,\012			    _Integer __val, __true_type)\012        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }\012\012      template<class _InputIterator>\012	basic_string&\012	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\012			    _InputIterator __k2, __false_type);\012\012      basic_string&\012      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\012		     _CharT __c);\012\012      basic_string&\012      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,\012		      size_type __n2);\012\012      // _S_construct_aux is used to implement the 21.3.1 para 15 which\012      // requires special behaviour if _InIter is an integral type\012      template<class _InIterator>\012        static _CharT*\012        _S_construct_aux(_InIterator __beg, _InIterator __end,\012			 const _Alloc& __a, __false_type)\012	{\012          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;\012          return _S_construct(__beg, __end, __a, _Tag());\012	}\012\012      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012      // 438. Ambiguity in the \"do the right thing\" clause\012      template<class _Integer>\012        static _CharT*\012        _S_construct_aux(_Integer __beg, _Integer __end,\012			 const _Alloc& __a, __true_type)\012        { return _S_construct(static_cast<size_type>(__beg), __end, __a); }\012\012      template<class _InIterator>\012        static _CharT*\012        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)\012	{\012	  typedef typename std::__is_integer<_InIterator>::__type _Integral;\012	  return _S_construct_aux(__beg, __end, __a, _Integral());\012        }\012\012      // For Input Iterators, used in istreambuf_iterators, etc.\012      template<class _InIterator>\012        static _CharT*\012         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\012		      input_iterator_tag);\012\012      // For forward_iterators up to random_access_iterators, used for\012      // string::iterator, _CharT*, etc.\012      template<class _FwdIterator>\012        static _CharT*\012        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,\012		     forward_iterator_tag);\012\012      static _CharT*\012      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);\012\012    public:\012\012      /**\012       *  @brief  Copy substring into C string.\012       *  @param s  C string to copy value into.\012       *  @param n  Number of characters to copy.\012       *  @param pos  Index of first character to copy.\012       *  @return  Number of characters actually copied\012       *  @throw  std::out_of_range  If pos > size().\012       *\012       *  Copies up to @a n characters starting at @a pos into the C string @a\012       *  s.  If @a pos is greater than size(), out_of_range is thrown.\012      */\012      size_type\012      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\012\012      /**\012       *  @brief  Swap contents with another string.\012       *  @param s  String to swap with.\012       *\012       *  Exchanges the contents of this string with that of @a s in constant\012       *  time.\012      */\012      void\012      swap(basic_string& __s);\012\012      // String operations:\012      /**\012       *  @brief  Return const pointer to null-terminated contents.\012       *\012       *  This is a handle to internal data.  Do not modify or dire things may\012       *  happen.\012      */\012      const _CharT*\012      c_str() const\012      { return _M_data(); }\012\012      /**\012       *  @brief  Return const pointer to contents.\012       *\012       *  This is a handle to internal data.  Do not modify or dire things may\012       *  happen.\012      */\012      const _CharT*\012      data() const\012      { return _M_data(); }\012\012      /**\012       *  @brief  Return copy of allocator used to construct this string.\012      */\012      allocator_type\012      get_allocator() const\012      { return _M_dataplus; }\012\012      /**\012       *  @brief  Find position of a C substring.\012       *  @param s  C string to locate.\012       *  @param pos  Index of character to search from.\012       *  @param n  Number of characters from @a s to search for.\012       *  @return  Index of start of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for the first @a n characters\012       *  in @a s within this string.  If found, returns the index where it\012       *  begins.  If not found, returns npos.\012      */\012      size_type\012      find(const _CharT* __s, size_type __pos, size_type __n) const;\012\012      /**\012       *  @brief  Find position of a string.\012       *  @param str  String to locate.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of start of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for value of @a str within\012       *  this string.  If found, returns the index where it begins.  If not\012       *  found, returns npos.\012      */\012      size_type\012      find(const basic_string& __str, size_type __pos = 0) const\012      { return this->find(__str.data(), __pos, __str.size()); }\012\012      /**\012       *  @brief  Find position of a C string.\012       *  @param s  C string to locate.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of start of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for the value of @a s within\012       *  this string.  If found, returns the index where it begins.  If not\012       *  found, returns npos.\012      */\012      size_type\012      find(const _CharT* __s, size_type __pos = 0) const\012      {\012	__glibcxx_requires_string(__s);\012	return this->find(__s, __pos, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Find position of a character.\012       *  @param c  Character to locate.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for @a c within this string.\012       *  If found, returns the index where it was found.  If not found,\012       *  returns npos.\012      */\012      size_type\012      find(_CharT __c, size_type __pos = 0) const;\012\012      /**\012       *  @brief  Find last position of a string.\012       *  @param str  String to locate.\012       *  @param pos  Index of character to search back from (default end).\012       *  @return  Index of start of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for value of @a str within\012       *  this string.  If found, returns the index where it begins.  If not\012       *  found, returns npos.\012      */\012      size_type\012      rfind(const basic_string& __str, size_type __pos = npos) const\012      { return this->rfind(__str.data(), __pos, __str.size()); }\012\012      /**\012       *  @brief  Find last position of a C substring.\012       *  @param s  C string to locate.\012       *  @param pos  Index of character to search back from.\012       *  @param n  Number of characters from s to search for.\012       *  @return  Index of start of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for the first @a n\012       *  characters in @a s within this string.  If found, returns the index\012       *  where it begins.  If not found, returns npos.\012      */\012      size_type\012      rfind(const _CharT* __s, size_type __pos, size_type __n) const;\012\012      /**\012       *  @brief  Find last position of a C string.\012       *  @param s  C string to locate.\012       *  @param pos  Index of character to start search at (default end).\012       *  @return  Index of start of  last occurrence.\012       *\012       *  Starting from @a pos, searches backward for the value of @a s within\012       *  this string.  If found, returns the index where it begins.  If not\012       *  found, returns npos.\012      */\012      size_type\012      rfind(const _CharT* __s, size_type __pos = npos) const\012      {\012	__glibcxx_requires_string(__s);\012	return this->rfind(__s, __pos, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Find last position of a character.\012       *  @param c  Character to locate.\012       *  @param pos  Index of character to search back from (default end).\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for @a c within this string.\012       *  If found, returns the index where it was found.  If not found,\012       *  returns npos.\012      */\012      size_type\012      rfind(_CharT __c, size_type __pos = npos) const;\012\012      /**\012       *  @brief  Find position of a character of string.\012       *  @param str  String containing characters to locate.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for one of the characters of\012       *  @a str within this string.  If found, returns the index where it was\012       *  found.  If not found, returns npos.\012      */\012      size_type\012      find_first_of(const basic_string& __str, size_type __pos = 0) const\012      { return this->find_first_of(__str.data(), __pos, __str.size()); }\012\012      /**\012       *  @brief  Find position of a character of C substring.\012       *  @param s  String containing characters to locate.\012       *  @param pos  Index of character to search from.\012       *  @param n  Number of characters from s to search for.\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for one of the first @a n\012       *  characters of @a s within this string.  If found, returns the index\012       *  where it was found.  If not found, returns npos.\012      */\012      size_type\012      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;\012\012      /**\012       *  @brief  Find position of a character of C string.\012       *  @param s  String containing characters to locate.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for one of the characters of\012       *  @a s within this string.  If found, returns the index where it was\012       *  found.  If not found, returns npos.\012      */\012      size_type\012      find_first_of(const _CharT* __s, size_type __pos = 0) const\012      {\012	__glibcxx_requires_string(__s);\012	return this->find_first_of(__s, __pos, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Find position of a character.\012       *  @param c  Character to locate.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for the character @a c within\012       *  this string.  If found, returns the index where it was found.  If\012       *  not found, returns npos.\012       *\012       *  Note: equivalent to find(c, pos).\012      */\012      size_type\012      find_first_of(_CharT __c, size_type __pos = 0) const\012      { return this->find(__c, __pos); }\012\012      /**\012       *  @brief  Find last position of a character of string.\012       *  @param str  String containing characters to locate.\012       *  @param pos  Index of character to search back from (default end).\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for one of the characters of\012       *  @a str within this string.  If found, returns the index where it was\012       *  found.  If not found, returns npos.\012      */\012      size_type\012      find_last_of(const basic_string& __str, size_type __pos = npos) const\012      { return this->find_last_of(__str.data(), __pos, __str.size()); }\012\012      /**\012       *  @brief  Find last position of a character of C substring.\012       *  @param s  C string containing characters to locate.\012       *  @param pos  Index of character to search back from.\012       *  @param n  Number of characters from s to search for.\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for one of the first @a n\012       *  characters of @a s within this string.  If found, returns the index\012       *  where it was found.  If not found, returns npos.\012      */\012      size_type\012      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;\012\012      /**\012       *  @brief  Find last position of a character of C string.\012       *  @param s  C string containing characters to locate.\012       *  @param pos  Index of character to search back from (default end).\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for one of the characters of\012       *  @a s within this string.  If found, returns the index where it was\012       *  found.  If not found, returns npos.\012      */\012      size_type\012      find_last_of(const _CharT* __s, size_type __pos = npos) const\012      {\012	__glibcxx_requires_string(__s);\012	return this->find_last_of(__s, __pos, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Find last position of a character.\012       *  @param c  Character to locate.\012       *  @param pos  Index of character to search back from (default end).\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for @a c within this string.\012       *  If found, returns the index where it was found.  If not found,\012       *  returns npos.\012       *\012       *  Note: equivalent to rfind(c, pos).\012      */\012      size_type\012      find_last_of(_CharT __c, size_type __pos = npos) const\012      { return this->rfind(__c, __pos); }\012\012      /**\012       *  @brief  Find position of a character not in string.\012       *  @param str  String containing characters to avoid.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for a character not contained\012       *  in @a str within this string.  If found, returns the index where it\012       *  was found.  If not found, returns npos.\012      */\012      size_type\012      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\012      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\012\012      /**\012       *  @brief  Find position of a character not in C substring.\012       *  @param s  C string containing characters to avoid.\012       *  @param pos  Index of character to search from.\012       *  @param n  Number of characters from s to consider.\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for a character not contained\012       *  in the first @a n characters of @a s within this string.  If found,\012       *  returns the index where it was found.  If not found, returns npos.\012      */\012      size_type\012      find_first_not_of(const _CharT* __s, size_type __pos,\012			size_type __n) const;\012\012      /**\012       *  @brief  Find position of a character not in C string.\012       *  @param s  C string containing characters to avoid.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for a character not contained\012       *  in @a s within this string.  If found, returns the index where it\012       *  was found.  If not found, returns npos.\012      */\012      size_type\012      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\012      {\012	__glibcxx_requires_string(__s);\012	return this->find_first_not_of(__s, __pos, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Find position of a different character.\012       *  @param c  Character to avoid.\012       *  @param pos  Index of character to search from (default 0).\012       *  @return  Index of first occurrence.\012       *\012       *  Starting from @a pos, searches forward for a character other than @a c\012       *  within this string.  If found, returns the index where it was found.\012       *  If not found, returns npos.\012      */\012      size_type\012      find_first_not_of(_CharT __c, size_type __pos = 0) const;\012\012      /**\012       *  @brief  Find last position of a character not in string.\012       *  @param str  String containing characters to avoid.\012       *  @param pos  Index of character to search back from (default end).\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for a character not\012       *  contained in @a str within this string.  If found, returns the index\012       *  where it was found.  If not found, returns npos.\012      */\012      size_type\012      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\012      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\012\012      /**\012       *  @brief  Find last position of a character not in C substring.\012       *  @param s  C string containing characters to avoid.\012       *  @param pos  Index of character to search back from.\012       *  @param n  Number of characters from s to consider.\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for a character not\012       *  contained in the first @a n characters of @a s within this string.\012       *  If found, returns the index where it was found.  If not found,\012       *  returns npos.\012      */\012      size_type\012      find_last_not_of(const _CharT* __s, size_type __pos,\012		       size_type __n) const;\012      /**\012       *  @brief  Find last position of a character not in C string.\012       *  @param s  C string containing characters to avoid.\012       *  @param pos  Index of character to search back from (default end).\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for a character not\012       *  contained in @a s within this string.  If found, returns the index\012       *  where it was found.  If not found, returns npos.\012      */\012      size_type\012      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\012      {\012	__glibcxx_requires_string(__s);\012	return this->find_last_not_of(__s, __pos, traits_type::length(__s));\012      }\012\012      /**\012       *  @brief  Find last position of a different character.\012       *  @param c  Character to avoid.\012       *  @param pos  Index of character to search back from (default end).\012       *  @return  Index of last occurrence.\012       *\012       *  Starting from @a pos, searches backward for a character other than\012       *  @a c within this string.  If found, returns the index where it was\012       *  found.  If not found, returns npos.\012      */\012      size_type\012      find_last_not_of(_CharT __c, size_type __pos = npos) const;\012\012      /**\012       *  @brief  Get a substring.\012       *  @param pos  Index of first character (default 0).\012       *  @param n  Number of characters in substring (default remainder).\012       *  @return  The new string.\012       *  @throw  std::out_of_range  If pos > size().\012       *\012       *  Construct and return a new string using the @a n characters starting\012       *  at @a pos.  If the string is too short, use the remainder of the\012       *  characters.  If @a pos is beyond the end of the string, out_of_range\012       *  is thrown.\012      */\012      basic_string\012      substr(size_type __pos = 0, size_type __n = npos) const\012      { return basic_string(*this,\012			    _M_check(__pos, \"basic_string::substr\"), __n); }\012\012      /**\012       *  @brief  Compare to a string.\012       *  @param str  String to compare against.\012       *  @return  Integer < 0, 0, or > 0.\012       *\012       *  Returns an integer < 0 if this string is ordered before @a str, 0 if\012       *  their values are equivalent, or > 0 if this string is ordered after\012       *  @a str.  Determines the effective length rlen of the strings to\012       *  compare as the smallest of size() and str.size().  The function\012       *  then compares the two strings by calling traits::compare(data(),\012       *  str.data(),rlen).  If the result of the comparison is nonzero returns\012       *  it, otherwise the shorter one is ordered first.\012      */\012      int\012      compare(const basic_string& __str) const\012      {\012	const size_type __size = this->size();\012	const size_type __osize = __str.size();\012	const size_type __len = std::min(__size, __osize);\012\012	int __r = traits_type::compare(_M_data(), __str.data(), __len);\012	if (!__r)\012	  __r = _S_compare(__size, __osize);\012	return __r;\012      }\012\012      /**\012       *  @brief  Compare substring to a string.\012       *  @param pos  Index of first character of substring.\012       *  @param n  Number of characters in substring.\012       *  @param str  String to compare against.\012       *  @return  Integer < 0, 0, or > 0.\012       *\012       *  Form the substring of this string from the @a n characters starting\012       *  at @a pos.  Returns an integer < 0 if the substring is ordered\012       *  before @a str, 0 if their values are equivalent, or > 0 if the\012       *  substring is ordered after @a str.  Determines the effective length\012       *  rlen of the strings to compare as the smallest of the length of the\012       *  substring and @a str.size().  The function then compares the two\012       *  strings by calling traits::compare(substring.data(),str.data(),rlen).\012       *  If the result of the comparison is nonzero returns it, otherwise the\012       *  shorter one is ordered first.\012      */\012      int\012      compare(size_type __pos, size_type __n, const basic_string& __str) const;\012\012      /**\012       *  @brief  Compare substring to a substring.\012       *  @param pos1  Index of first character of substring.\012       *  @param n1  Number of characters in substring.\012       *  @param str  String to compare against.\012       *  @param pos2  Index of first character of substring of str.\012       *  @param n2  Number of characters in substring of str.\012       *  @return  Integer < 0, 0, or > 0.\012       *\012       *  Form the substring of this string from the @a n1 characters starting\012       *  at @a pos1.  Form the substring of @a str from the @a n2 characters\012       *  starting at @a pos2.  Returns an integer < 0 if this substring is\012       *  ordered before the substring of @a str, 0 if their values are\012       *  equivalent, or > 0 if this substring is ordered after the substring\012       *  of @a str.  Determines the effective length rlen of the strings\012       *  to compare as the smallest of the lengths of the substrings.  The\012       *  function then compares the two strings by calling\012       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).\012       *  If the result of the comparison is nonzero returns it, otherwise the\012       *  shorter one is ordered first.\012      */\012      int\012      compare(size_type __pos1, size_type __n1, const basic_string& __str,\012	      size_type __pos2, size_type __n2) const;\012\012      /**\012       *  @brief  Compare to a C string.\012       *  @param s  C string to compare against.\012       *  @return  Integer < 0, 0, or > 0.\012       *\012       *  Returns an integer < 0 if this string is ordered before @a s, 0 if\012       *  their values are equivalent, or > 0 if this string is ordered after\012       *  @a s.  Determines the effective length rlen of the strings to\012       *  compare as the smallest of size() and the length of a string\012       *  constructed from @a s.  The function then compares the two strings\012       *  by calling traits::compare(data(),s,rlen).  If the result of the\012       *  comparison is nonzero returns it, otherwise the shorter one is\012       *  ordered first.\012      */\012      int\012      compare(const _CharT* __s) const;\012\012      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012      // 5 String::compare specification questionable\012      /**\012       *  @brief  Compare substring to a C string.\012       *  @param pos  Index of first character of substring.\012       *  @param n1  Number of characters in substring.\012       *  @param s  C string to compare against.\012       *  @return  Integer < 0, 0, or > 0.\012       *\012       *  Form the substring of this string from the @a n1 characters starting\012       *  at @a pos.  Returns an integer < 0 if the substring is ordered\012       *  before @a s, 0 if their values are equivalent, or > 0 if the\012       *  substring is ordered after @a s.  Determines the effective length\012       *  rlen of the strings to compare as the smallest of the length of the \012       *  substring and the length of a string constructed from @a s.  The\012       *  function then compares the two string by calling\012       *  traits::compare(substring.data(),s,rlen).  If the result of the\012       *  comparison is nonzero returns it, otherwise the shorter one is\012       *  ordered first.\012      */\012      int\012      compare(size_type __pos, size_type __n1, const _CharT* __s) const;\012\012      /**\012       *  @brief  Compare substring against a character array.\012       *  @param pos1  Index of first character of substring.\012       *  @param n1  Number of characters in substring.\012       *  @param s  character array to compare against.\012       *  @param n2  Number of characters of s.\012       *  @return  Integer < 0, 0, or > 0.\012       *\012       *  Form the substring of this string from the @a n1 characters starting\012       *  at @a pos1.  Form a string from the first @a n2 characters of @a s.\012       *  Returns an integer < 0 if this substring is ordered before the string\012       *  from @a s, 0 if their values are equivalent, or > 0 if this substring\012       *  is ordered after the string from @a s.   Determines the effective\012       *  length rlen of the strings to compare as the smallest of the length\012       *  of the substring and @a n2.  The function then compares the two\012       *  strings by calling traits::compare(substring.data(),s,rlen).  If the\012       *  result of the comparison is nonzero returns it, otherwise the shorter\012       *  one is ordered first.\012       *\012       *  NB: s must have at least n2 characters, '\\\\0' has no special\012       *  meaning.\012      */\012      int\012      compare(size_type __pos, size_type __n1, const _CharT* __s,\012	      size_type __n2) const;\012  };\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline basic_string<_CharT, _Traits, _Alloc>::\012    basic_string()\012#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING\012    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }\012#else\012    : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()) { }\012#endif\012\012  // operator+\012  /**\012   *  @brief  Concatenate two strings.\012   *  @param lhs  First string.\012   *  @param rhs  Last string.\012   *  @return  New string with value of @a lhs followed by @a rhs.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>\012    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    {\012      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\012      __str.append(__rhs);\012      return __str;\012    }\012\012  /**\012   *  @brief  Concatenate C string and string.\012   *  @param lhs  First string.\012   *  @param rhs  Last string.\012   *  @return  New string with value of @a lhs followed by @a rhs.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT,_Traits,_Alloc>\012    operator+(const _CharT* __lhs,\012	      const basic_string<_CharT,_Traits,_Alloc>& __rhs);\012\012  /**\012   *  @brief  Concatenate character and string.\012   *  @param lhs  First string.\012   *  @param rhs  Last string.\012   *  @return  New string with @a lhs followed by @a rhs.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT,_Traits,_Alloc>\012    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\012\012  /**\012   *  @brief  Concatenate string and C string.\012   *  @param lhs  First string.\012   *  @param rhs  Last string.\012   *  @return  New string with @a lhs followed by @a rhs.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline basic_string<_CharT, _Traits, _Alloc>\012    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	     const _CharT* __rhs)\012    {\012      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\012      __str.append(__rhs);\012      return __str;\012    }\012\012  /**\012   *  @brief  Concatenate string and character.\012   *  @param lhs  First string.\012   *  @param rhs  Last string.\012   *  @return  New string with @a lhs followed by @a rhs.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline basic_string<_CharT, _Traits, _Alloc>\012    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\012    {\012      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;\012      typedef typename __string_type::size_type		__size_type;\012      __string_type __str(__lhs);\012      __str.append(__size_type(1), __rhs);\012      return __str;\012    }\012\012  // operator ==\012  /**\012   *  @brief  Test equivalence of two strings.\012   *  @param lhs  First string.\012   *  @param rhs  Second string.\012   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __lhs.compare(__rhs) == 0; }\012\012  template<typename _CharT>\012    inline\012    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type\012    operator==(const basic_string<_CharT>& __lhs,\012	       const basic_string<_CharT>& __rhs)\012    { return (__lhs.size() == __rhs.size()\012	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),\012						    __lhs.size())); }\012\012  /**\012   *  @brief  Test equivalence of C string and string.\012   *  @param lhs  C string.\012   *  @param rhs  String.\012   *  @return  True if @a rhs.compare(@a lhs) == 0.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator==(const _CharT* __lhs,\012	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __rhs.compare(__lhs) == 0; }\012\012  /**\012   *  @brief  Test equivalence of string and C string.\012   *  @param lhs  String.\012   *  @param rhs  C string.\012   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	       const _CharT* __rhs)\012    { return __lhs.compare(__rhs) == 0; }\012\012  // operator !=\012  /**\012   *  @brief  Test difference of two strings.\012   *  @param lhs  First string.\012   *  @param rhs  Second string.\012   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return !(__lhs == __rhs); }\012\012  /**\012   *  @brief  Test difference of C string and string.\012   *  @param lhs  C string.\012   *  @param rhs  String.\012   *  @return  True if @a rhs.compare(@a lhs) != 0.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator!=(const _CharT* __lhs,\012	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return !(__lhs == __rhs); }\012\012  /**\012   *  @brief  Test difference of string and C string.\012   *  @param lhs  String.\012   *  @param rhs  C string.\012   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	       const _CharT* __rhs)\012    { return !(__lhs == __rhs); }\012\012  // operator <\012  /**\012   *  @brief  Test if string precedes string.\012   *  @param lhs  First string.\012   *  @param rhs  Second string.\012   *  @return  True if @a lhs precedes @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __lhs.compare(__rhs) < 0; }\012\012  /**\012   *  @brief  Test if string precedes C string.\012   *  @param lhs  String.\012   *  @param rhs  C string.\012   *  @return  True if @a lhs precedes @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	      const _CharT* __rhs)\012    { return __lhs.compare(__rhs) < 0; }\012\012  /**\012   *  @brief  Test if C string precedes string.\012   *  @param lhs  C string.\012   *  @param rhs  String.\012   *  @return  True if @a lhs precedes @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator<(const _CharT* __lhs,\012	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __rhs.compare(__lhs) > 0; }\012\012  // operator >\012  /**\012   *  @brief  Test if string follows string.\012   *  @param lhs  First string.\012   *  @param rhs  Second string.\012   *  @return  True if @a lhs follows @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __lhs.compare(__rhs) > 0; }\012\012  /**\012   *  @brief  Test if string follows C string.\012   *  @param lhs  String.\012   *  @param rhs  C string.\012   *  @return  True if @a lhs follows @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	      const _CharT* __rhs)\012    { return __lhs.compare(__rhs) > 0; }\012\012  /**\012   *  @brief  Test if C string follows string.\012   *  @param lhs  C string.\012   *  @param rhs  String.\012   *  @return  True if @a lhs follows @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator>(const _CharT* __lhs,\012	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __rhs.compare(__lhs) < 0; }\012\012  // operator <=\012  /**\012   *  @brief  Test if string doesn't follow string.\012   *  @param lhs  First string.\012   *  @param rhs  Second string.\012   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __lhs.compare(__rhs) <= 0; }\012\012  /**\012   *  @brief  Test if string doesn't follow C string.\012   *  @param lhs  String.\012   *  @param rhs  C string.\012   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	       const _CharT* __rhs)\012    { return __lhs.compare(__rhs) <= 0; }\012\012  /**\012   *  @brief  Test if C string doesn't follow string.\012   *  @param lhs  C string.\012   *  @param rhs  String.\012   *  @return  True if @a lhs doesn't follow @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator<=(const _CharT* __lhs,\012	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __rhs.compare(__lhs) >= 0; }\012\012  // operator >=\012  /**\012   *  @brief  Test if string doesn't precede string.\012   *  @param lhs  First string.\012   *  @param rhs  Second string.\012   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __lhs.compare(__rhs) >= 0; }\012\012  /**\012   *  @brief  Test if string doesn't precede C string.\012   *  @param lhs  String.\012   *  @param rhs  C string.\012   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	       const _CharT* __rhs)\012    { return __lhs.compare(__rhs) >= 0; }\012\012  /**\012   *  @brief  Test if C string doesn't precede string.\012   *  @param lhs  C string.\012   *  @param rhs  String.\012   *  @return  True if @a lhs doesn't precede @a rhs.  False otherwise.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline bool\012    operator>=(const _CharT* __lhs,\012	     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { return __rhs.compare(__lhs) <= 0; }\012\012  /**\012   *  @brief  Swap contents of two strings.\012   *  @param lhs  First string.\012   *  @param rhs  Second string.\012   *\012   *  Exchanges the contents of @a lhs and @a rhs in constant time.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline void\012    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,\012	 basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    { __lhs.swap(__rhs); }\012\012  /**\012   *  @brief  Read stream into a string.\012   *  @param is  Input stream.\012   *  @param str  Buffer to store into.\012   *  @return  Reference to the input stream.\012   *\012   *  Stores characters from @a is into @a str until whitespace is found, the\012   *  end of the stream is encountered, or str.max_size() is reached.  If\012   *  is.width() is non-zero, that is the limit on the number of characters\012   *  stored into @a str.  Any previous contents of @a str are erased.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_istream<_CharT, _Traits>&\012    operator>>(basic_istream<_CharT, _Traits>& __is,\012	       basic_string<_CharT, _Traits, _Alloc>& __str);\012\012  template<>\012    basic_istream<char>&\012    operator>>(basic_istream<char>& __is, basic_string<char>& __str);\012\012  /**\012   *  @brief  Write string to a stream.\012   *  @param os  Output stream.\012   *  @param str  String to write out.\012   *  @return  Reference to the output stream.\012   *\012   *  Output characters of @a str into os following the same rules as for\012   *  writing a C string.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline basic_ostream<_CharT, _Traits>&\012    operator<<(basic_ostream<_CharT, _Traits>& __os,\012	       const basic_string<_CharT, _Traits, _Alloc>& __str)\012    {\012      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012      // 586. string inserter not a formatted function\012      return __ostream_insert(__os, __str.data(), __str.size());\012    }\012\012  /**\012   *  @brief  Read a line from stream into a string.\012   *  @param is  Input stream.\012   *  @param str  Buffer to store into.\012   *  @param delim  Character marking end of line.\012   *  @return  Reference to the input stream.\012   *\012   *  Stores characters from @a is into @a str until @a delim is found, the\012   *  end of the stream is encountered, or str.max_size() is reached.  If\012   *  is.width() is non-zero, that is the limit on the number of characters\012   *  stored into @a str.  Any previous contents of @a str are erased.  If @a\012   *  delim was encountered, it is extracted but not stored into @a str.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_istream<_CharT, _Traits>&\012    getline(basic_istream<_CharT, _Traits>& __is,\012	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);\012\012  /**\012   *  @brief  Read a line from stream into a string.\012   *  @param is  Input stream.\012   *  @param str  Buffer to store into.\012   *  @return  Reference to the input stream.\012   *\012   *  Stores characters from is into @a str until '\\n' is found, the end of\012   *  the stream is encountered, or str.max_size() is reached.  If is.width()\012   *  is non-zero, that is the limit on the number of characters stored into\012   *  @a str.  Any previous contents of @a str are erased.  If end of line was\012   *  encountered, it is extracted but not stored into @a str.\012   */\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    inline basic_istream<_CharT, _Traits>&\012    getline(basic_istream<_CharT, _Traits>& __is,\012	    basic_string<_CharT, _Traits, _Alloc>& __str)\012    { return getline(__is, __str, __is.widen('\\n')); }\012\012  template<>\012    basic_istream<char>&\012    getline(basic_istream<char>& __in, basic_string<char>& __str,\012	    char __delim);\012\012#ifdef _GLIBCXX_USE_WCHAR_T\012  template<>\012    basic_istream<wchar_t>&\012    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,\012	    wchar_t __delim);\012#endif  \012\012_GLIBCXX_END_NAMESPACE\012\012#if (defined(__GXX_EXPERIMENTAL_CXX0X__) && defined(_GLIBCXX_USE_C99) \\\012     && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))\012\012#include <ext/string_conversions.h>\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  // 21.4 Numeric Conversions [string.conversions].\012  inline int\012  stoi(const string& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa<long, int>(&std::strtol, \"stoi\", __str.c_str(),\012					__idx, __base); }\012\012  inline long\012  stol(const string& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa(&std::strtol, \"stol\", __str.c_str(),\012			     __idx, __base); }\012\012  inline unsigned long\012  stoul(const string& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa(&std::strtoul, \"stoul\", __str.c_str(),\012			     __idx, __base); }\012\012  inline long long\012  stoll(const string& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa(&std::strtoll, \"stoll\", __str.c_str(),\012			     __idx, __base); }\012\012  inline unsigned long long\012  stoull(const string& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa(&std::strtoull, \"stoull\", __str.c_str(),\012			     __idx, __base); }\012\012  // NB: strtof vs strtod.\012  inline float\012  stof(const string& __str, size_t* __idx = 0)\012  { return __gnu_cxx::__stoa(&std::strtof, \"stof\", __str.c_str(), __idx); }\012\012  inline double\012  stod(const string& __str, size_t* __idx = 0)\012  { return __gnu_cxx::__stoa(&std::strtod, \"stod\", __str.c_str(), __idx); }\012\012  inline long double\012  stold(const string& __str, size_t* __idx = 0)\012  { return __gnu_cxx::__stoa(&std::strtold, \"stold\", __str.c_str(), __idx); }\012\012  // NB: (v)snprintf vs sprintf.\012  inline string\012  to_string(long long __val)\012  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\012					   4 * sizeof(long long),\012					   \"%lld\", __val); }\012\012  inline string\012  to_string(unsigned long long __val)\012  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,\012					   4 * sizeof(unsigned long long),\012					   \"%llu\", __val); }\012\012  inline string\012  to_string(long double __val)\012  {\012    const int __n = \012      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\012    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,\012					   \"%Lf\", __val);\012  }\012\012#ifdef _GLIBCXX_USE_WCHAR_T\012  inline int \012  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, \"stoi\", __str.c_str(),\012					__idx, __base); }\012\012  inline long \012  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa(&std::wcstol, \"stol\", __str.c_str(),\012			     __idx, __base); }\012\012  inline unsigned long\012  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa(&std::wcstoul, \"stoul\", __str.c_str(),\012			     __idx, __base); }\012\012  inline long long\012  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa(&std::wcstoll, \"stoll\", __str.c_str(),\012			     __idx, __base); }\012\012  inline unsigned long long\012  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)\012  { return __gnu_cxx::__stoa(&std::wcstoull, \"stoull\", __str.c_str(),\012			     __idx, __base); }\012\012  // NB: wcstof vs wcstod.\012  inline float\012  stof(const wstring& __str, size_t* __idx = 0)\012  { return __gnu_cxx::__stoa(&std::wcstof, \"stof\", __str.c_str(), __idx); }\012\012  inline double\012  stod(const wstring& __str, size_t* __idx = 0)\012  { return __gnu_cxx::__stoa(&std::wcstod, \"stod\", __str.c_str(), __idx); }\012\012  inline long double\012  stold(const wstring& __str, size_t* __idx = 0)\012  { return __gnu_cxx::__stoa(&std::wcstold, \"stold\", __str.c_str(), __idx); }\012\012  inline wstring\012  to_wstring(long long __val)\012  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\012					    4 * sizeof(long long),\012					    L\"%lld\", __val); }\012\012  inline wstring\012  to_wstring(unsigned long long __val)\012  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,\012					    4 * sizeof(unsigned long long),\012					    L\"%llu\", __val); }\012\012  inline wstring\012  to_wstring(long double __val)\012  {\012    const int __n =\012      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;\012    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,\012					    L\"%Lf\", __val);\012  }\012#endif\012\012_GLIBCXX_END_NAMESPACE\012\012#endif\012\012#endif /* _BASIC_STRING_H */\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/basic_string.tcc", "name":"basic_string.tcc", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/basic_string.tcc", "content":"// Components for manipulating sequences of characters -*- C++ -*-\012\012// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\012// 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file basic_string.tcc\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012//\012// ISO C++ 14882: 21  Strings library\012//\012\012// Written by Jason Merrill based upon the specification by Takanori Adachi\012// in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.\012\012#ifndef _BASIC_STRING_TCC\012#define _BASIC_STRING_TCC 1\012\012#pragma GCC system_header\012\012#include <cxxabi-forced.h>\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    const typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    const _CharT\012    basic_string<_CharT, _Traits, _Alloc>::\012    _Rep::_S_terminal = _CharT();\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    const typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::npos;\012\012  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)\012  // at static init time (before static ctors are run).\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[\012    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /\012      sizeof(size_type)];\012\012  // NB: This is the special case for Input Iterators, used in\012  // istreambuf_iterators, etc.\012  // Input Iterators have a cost structure very different from\012  // pointers, calling for a different coding style.\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    template<typename _InIterator>\012      _CharT*\012      basic_string<_CharT, _Traits, _Alloc>::\012      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\012		   input_iterator_tag)\012      {\012#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING\012	if (__beg == __end && __a == _Alloc())\012	  return _S_empty_rep()._M_refdata();\012#endif\012	// Avoid reallocation for common case.\012	_CharT __buf[128];\012	size_type __len = 0;\012	while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))\012	  {\012	    __buf[__len++] = *__beg;\012	    ++__beg;\012	  }\012	_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);\012	_M_copy(__r->_M_refdata(), __buf, __len);\012	__try\012	  {\012	    while (__beg != __end)\012	      {\012		if (__len == __r->_M_capacity)\012		  {\012		    // Allocate more space.\012		    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);\012		    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);\012		    __r->_M_destroy(__a);\012		    __r = __another;\012		  }\012		__r->_M_refdata()[__len++] = *__beg;\012		++__beg;\012	      }\012	  }\012	__catch(...)\012	  {\012	    __r->_M_destroy(__a);\012	    __throw_exception_again;\012	  }\012	__r->_M_set_length_and_sharable(__len);\012	return __r->_M_refdata();\012      }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    template <typename _InIterator>\012      _CharT*\012      basic_string<_CharT, _Traits, _Alloc>::\012      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,\012		   forward_iterator_tag)\012      {\012#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING\012	if (__beg == __end && __a == _Alloc())\012	  return _S_empty_rep()._M_refdata();\012#endif\012	// NB: Not required, but considered best practice.\012	if (__builtin_expect(__gnu_cxx::__is_null_pointer(__beg)\012			     && __beg != __end, 0))\012	  __throw_logic_error(__N(\"basic_string::_S_construct NULL not valid\"));\012\012	const size_type __dnew = static_cast<size_type>(std::distance(__beg,\012								      __end));\012	// Check for out_of_range and length_error exceptions.\012	_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);\012	__try\012	  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }\012	__catch(...)\012	  {\012	    __r->_M_destroy(__a);\012	    __throw_exception_again;\012	  }\012	__r->_M_set_length_and_sharable(__dnew);\012	return __r->_M_refdata();\012      }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    _CharT*\012    basic_string<_CharT, _Traits, _Alloc>::\012    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)\012    {\012#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING\012      if (__n == 0 && __a == _Alloc())\012	return _S_empty_rep()._M_refdata();\012#endif\012      // Check for out_of_range and length_error exceptions.\012      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);\012      if (__n)\012	_M_assign(__r->_M_refdata(), __n, __c);\012\012      __r->_M_set_length_and_sharable(__n);\012      return __r->_M_refdata();\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(const basic_string& __str)\012    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),\012					  __str.get_allocator()),\012		  __str.get_allocator())\012    { }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(const _Alloc& __a)\012    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)\012    { }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(const basic_string& __str, size_type __pos, size_type __n)\012    : _M_dataplus(_S_construct(__str._M_data()\012			       + __str._M_check(__pos,\012						\"basic_string::basic_string\"),\012			       __str._M_data() + __str._M_limit(__pos, __n)\012			       + __pos, _Alloc()), _Alloc())\012    { }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(const basic_string& __str, size_type __pos,\012		 size_type __n, const _Alloc& __a)\012    : _M_dataplus(_S_construct(__str._M_data()\012			       + __str._M_check(__pos,\012						\"basic_string::basic_string\"),\012			       __str._M_data() + __str._M_limit(__pos, __n)\012			       + __pos, __a), __a)\012    { }\012\012  // TBD: DPG annotate\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)\012    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)\012    { }\012\012  // TBD: DPG annotate\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(const _CharT* __s, const _Alloc& __a)\012    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :\012			       __s + npos, __a), __a)\012    { }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(size_type __n, _CharT __c, const _Alloc& __a)\012    : _M_dataplus(_S_construct(__n, __c, __a), __a)\012    { }\012\012  // TBD: DPG annotate\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    template<typename _InputIterator>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)\012    : _M_dataplus(_S_construct(__beg, __end, __a), __a)\012    { }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>::\012    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)\012    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)\012    { }\012#endif\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>&\012    basic_string<_CharT, _Traits, _Alloc>::\012    assign(const basic_string& __str)\012    {\012      if (_M_rep() != __str._M_rep())\012	{\012	  // XXX MT\012	  const allocator_type __a = this->get_allocator();\012	  _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());\012	  _M_rep()->_M_dispose(__a);\012	  _M_data(__tmp);\012	}\012      return *this;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>&\012    basic_string<_CharT, _Traits, _Alloc>::\012    assign(const _CharT* __s, size_type __n)\012    {\012      __glibcxx_requires_string_len(__s, __n);\012      _M_check_length(this->size(), __n, \"basic_string::assign\");\012      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\012	return _M_replace_safe(size_type(0), this->size(), __s, __n);\012      else\012	{\012	  // Work in-place.\012	  const size_type __pos = __s - _M_data();\012	  if (__pos >= __n)\012	    _M_copy(_M_data(), __s, __n);\012	  else if (__pos)\012	    _M_move(_M_data(), __s, __n);\012	  _M_rep()->_M_set_length_and_sharable(__n);\012	  return *this;\012	}\012     }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>&\012    basic_string<_CharT, _Traits, _Alloc>::\012    append(size_type __n, _CharT __c)\012    {\012      if (__n)\012	{\012	  _M_check_length(size_type(0), __n, \"basic_string::append\");	  \012	  const size_type __len = __n + this->size();\012	  if (__len > this->capacity() || _M_rep()->_M_is_shared())\012	    this->reserve(__len);\012	  _M_assign(_M_data() + this->size(), __n, __c);\012	  _M_rep()->_M_set_length_and_sharable(__len);\012	}\012      return *this;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>&\012    basic_string<_CharT, _Traits, _Alloc>::\012    append(const _CharT* __s, size_type __n)\012    {\012      __glibcxx_requires_string_len(__s, __n);\012      if (__n)\012	{\012	  _M_check_length(size_type(0), __n, \"basic_string::append\");\012	  const size_type __len = __n + this->size();\012	  if (__len > this->capacity() || _M_rep()->_M_is_shared())\012	    {\012	      if (_M_disjunct(__s))\012		this->reserve(__len);\012	      else\012		{\012		  const size_type __off = __s - _M_data();\012		  this->reserve(__len);\012		  __s = _M_data() + __off;\012		}\012	    }\012	  _M_copy(_M_data() + this->size(), __s, __n);\012	  _M_rep()->_M_set_length_and_sharable(__len);\012	}\012      return *this;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>&\012    basic_string<_CharT, _Traits, _Alloc>::\012    append(const basic_string& __str)\012    {\012      const size_type __size = __str.size();\012      if (__size)\012	{\012	  const size_type __len = __size + this->size();\012	  if (__len > this->capacity() || _M_rep()->_M_is_shared())\012	    this->reserve(__len);\012	  _M_copy(_M_data() + this->size(), __str._M_data(), __size);\012	  _M_rep()->_M_set_length_and_sharable(__len);\012	}\012      return *this;\012    }    \012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>&\012    basic_string<_CharT, _Traits, _Alloc>::\012    append(const basic_string& __str, size_type __pos, size_type __n)\012    {\012      __str._M_check(__pos, \"basic_string::append\");\012      __n = __str._M_limit(__pos, __n);\012      if (__n)\012	{\012	  const size_type __len = __n + this->size();\012	  if (__len > this->capacity() || _M_rep()->_M_is_shared())\012	    this->reserve(__len);\012	  _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);\012	  _M_rep()->_M_set_length_and_sharable(__len);	  \012	}\012      return *this;\012    }\012\012   template<typename _CharT, typename _Traits, typename _Alloc>\012     basic_string<_CharT, _Traits, _Alloc>&\012     basic_string<_CharT, _Traits, _Alloc>::\012     insert(size_type __pos, const _CharT* __s, size_type __n)\012     {\012       __glibcxx_requires_string_len(__s, __n);\012       _M_check(__pos, \"basic_string::insert\");\012       _M_check_length(size_type(0), __n, \"basic_string::insert\");\012       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\012         return _M_replace_safe(__pos, size_type(0), __s, __n);\012       else\012         {\012           // Work in-place.\012           const size_type __off = __s - _M_data();\012           _M_mutate(__pos, 0, __n);\012           __s = _M_data() + __off;\012           _CharT* __p = _M_data() + __pos;\012           if (__s  + __n <= __p)\012             _M_copy(__p, __s, __n);\012           else if (__s >= __p)\012             _M_copy(__p, __s + __n, __n);\012           else\012             {\012	       const size_type __nleft = __p - __s;\012               _M_copy(__p, __s, __nleft);\012               _M_copy(__p + __nleft, __p + __n, __n - __nleft);\012             }\012           return *this;\012         }\012     }\012\012   template<typename _CharT, typename _Traits, typename _Alloc>\012     typename basic_string<_CharT, _Traits, _Alloc>::iterator\012     basic_string<_CharT, _Traits, _Alloc>::\012     erase(iterator __first, iterator __last)\012     {\012       _GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last\012				&& __last <= _M_iend());\012\012       // NB: This isn't just an optimization (bail out early when\012       // there is nothing to do, really), it's also a correctness\012       // issue vs MT, see libstdc++/40518.\012       const size_type __size = __last - __first;\012       if (__size)\012	 {\012	   const size_type __pos = __first - _M_ibegin();\012	   _M_mutate(__pos, __size, size_type(0));\012	   _M_rep()->_M_set_leaked();\012	   return iterator(_M_data() + __pos);\012	 }\012       else\012	 return __first;\012     }\012\012   template<typename _CharT, typename _Traits, typename _Alloc>\012     basic_string<_CharT, _Traits, _Alloc>&\012     basic_string<_CharT, _Traits, _Alloc>::\012     replace(size_type __pos, size_type __n1, const _CharT* __s,\012	     size_type __n2)\012     {\012       __glibcxx_requires_string_len(__s, __n2);\012       _M_check(__pos, \"basic_string::replace\");\012       __n1 = _M_limit(__pos, __n1);\012       _M_check_length(__n1, __n2, \"basic_string::replace\");\012       bool __left;\012       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())\012         return _M_replace_safe(__pos, __n1, __s, __n2);\012       else if ((__left = __s + __n2 <= _M_data() + __pos)\012		|| _M_data() + __pos + __n1 <= __s)\012	 {\012	   // Work in-place: non-overlapping case.\012	   size_type __off = __s - _M_data();\012	   __left ? __off : (__off += __n2 - __n1);\012	   _M_mutate(__pos, __n1, __n2);\012	   _M_copy(_M_data() + __pos, _M_data() + __off, __n2);\012	   return *this;\012	 }\012       else\012	 {\012	   // Todo: overlapping case.\012	   const basic_string __tmp(__s, __n2);\012	   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);\012	 }\012     }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    void\012    basic_string<_CharT, _Traits, _Alloc>::_Rep::\012    _M_destroy(const _Alloc& __a) throw ()\012    {\012      const size_type __size = sizeof(_Rep_base) +\012	                       (this->_M_capacity + 1) * sizeof(_CharT);\012      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    void\012    basic_string<_CharT, _Traits, _Alloc>::\012    _M_leak_hard()\012    {\012#ifndef _GLIBCXX_FULLY_DYNAMIC_STRING\012      if (_M_rep() == &_S_empty_rep())\012	return;\012#endif\012      if (_M_rep()->_M_is_shared())\012	_M_mutate(0, 0, 0);\012      _M_rep()->_M_set_leaked();\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    void\012    basic_string<_CharT, _Traits, _Alloc>::\012    _M_mutate(size_type __pos, size_type __len1, size_type __len2)\012    {\012      const size_type __old_size = this->size();\012      const size_type __new_size = __old_size + __len2 - __len1;\012      const size_type __how_much = __old_size - __pos - __len1;\012\012      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())\012	{\012	  // Must reallocate.\012	  const allocator_type __a = get_allocator();\012	  _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);\012\012	  if (__pos)\012	    _M_copy(__r->_M_refdata(), _M_data(), __pos);\012	  if (__how_much)\012	    _M_copy(__r->_M_refdata() + __pos + __len2,\012		    _M_data() + __pos + __len1, __how_much);\012\012	  _M_rep()->_M_dispose(__a);\012	  _M_data(__r->_M_refdata());\012	}\012      else if (__how_much && __len1 != __len2)\012	{\012	  // Work in-place.\012	  _M_move(_M_data() + __pos + __len2,\012		  _M_data() + __pos + __len1, __how_much);\012	}\012      _M_rep()->_M_set_length_and_sharable(__new_size);\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    void\012    basic_string<_CharT, _Traits, _Alloc>::\012    reserve(size_type __res)\012    {\012      if (__res != this->capacity() || _M_rep()->_M_is_shared())\012        {\012	  // Make sure we don't shrink below the current size\012	  if (__res < this->size())\012	    __res = this->size();\012	  const allocator_type __a = get_allocator();\012	  _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());\012	  _M_rep()->_M_dispose(__a);\012	  _M_data(__tmp);\012        }\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    void\012    basic_string<_CharT, _Traits, _Alloc>::\012    swap(basic_string& __s)\012    {\012      if (_M_rep()->_M_is_leaked())\012	_M_rep()->_M_set_sharable();\012      if (__s._M_rep()->_M_is_leaked())\012	__s._M_rep()->_M_set_sharable();\012      if (this->get_allocator() == __s.get_allocator())\012	{\012	  _CharT* __tmp = _M_data();\012	  _M_data(__s._M_data());\012	  __s._M_data(__tmp);\012	}\012      // The code below can usually be optimized away.\012      else\012	{\012	  const basic_string __tmp1(_M_ibegin(), _M_iend(),\012				    __s.get_allocator());\012	  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),\012				    this->get_allocator());\012	  *this = __tmp2;\012	  __s = __tmp1;\012	}\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*\012    basic_string<_CharT, _Traits, _Alloc>::_Rep::\012    _S_create(size_type __capacity, size_type __old_capacity,\012	      const _Alloc& __alloc)\012    {\012      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012      // 83.  String::npos vs. string::max_size()\012      if (__capacity > _S_max_size)\012	__throw_length_error(__N(\"basic_string::_S_create\"));\012\012      // The standard places no restriction on allocating more memory\012      // than is strictly needed within this layer at the moment or as\012      // requested by an explicit application call to reserve().\012\012      // Many malloc implementations perform quite poorly when an\012      // application attempts to allocate memory in a stepwise fashion\012      // growing each allocation size by only 1 char.  Additionally,\012      // it makes little sense to allocate less linear memory than the\012      // natural blocking size of the malloc implementation.\012      // Unfortunately, we would need a somewhat low-level calculation\012      // with tuned parameters to get this perfect for any particular\012      // malloc implementation.  Fortunately, generalizations about\012      // common features seen among implementations seems to suffice.\012\012      // __pagesize need not match the actual VM page size for good\012      // results in practice, thus we pick a common value on the low\012      // side.  __malloc_header_size is an estimate of the amount of\012      // overhead per memory allocation (in practice seen N * sizeof\012      // (void*) where N is 0, 2 or 4).  According to folklore,\012      // picking this value on the high side is better than\012      // low-balling it (especially when this algorithm is used with\012      // malloc implementations that allocate memory blocks rounded up\012      // to a size which is a power of 2).\012      const size_type __pagesize = 4096;\012      const size_type __malloc_header_size = 4 * sizeof(void*);\012\012      // The below implements an exponential growth policy, necessary to\012      // meet amortized linear time requirements of the library: see\012      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\012      // It's active for allocations requiring an amount of memory above\012      // system pagesize. This is consistent with the requirements of the\012      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html\012      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)\012	__capacity = 2 * __old_capacity;\012\012      // NB: Need an array of char_type[__capacity], plus a terminating\012      // null char_type() element, plus enough for the _Rep data structure.\012      // Whew. Seemingly so needy, yet so elemental.\012      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\012\012      const size_type __adj_size = __size + __malloc_header_size;\012      if (__adj_size > __pagesize && __capacity > __old_capacity)\012	{\012	  const size_type __extra = __pagesize - __adj_size % __pagesize;\012	  __capacity += __extra / sizeof(_CharT);\012	  // Never allocate a string bigger than _S_max_size.\012	  if (__capacity > _S_max_size)\012	    __capacity = _S_max_size;\012	  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\012	}\012\012      // NB: Might throw, but no worries about a leak, mate: _Rep()\012      // does not throw.\012      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);\012      _Rep *__p = new (__place) _Rep;\012      __p->_M_capacity = __capacity;\012      // ABI compatibility - 3.4.x set in _S_create both\012      // _M_refcount and _M_length.  All callers of _S_create\012      // in basic_string.tcc then set just _M_length.\012      // In 4.0.x and later both _M_refcount and _M_length\012      // are initialized in the callers, unfortunately we can\012      // have 3.4.x compiled code with _S_create callers inlined\012      // calling 4.0.x+ _S_create.\012      __p->_M_set_sharable();\012      return __p;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    _CharT*\012    basic_string<_CharT, _Traits, _Alloc>::_Rep::\012    _M_clone(const _Alloc& __alloc, size_type __res)\012    {\012      // Requested capacity of the clone.\012      const size_type __requested_cap = this->_M_length + __res;\012      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,\012				  __alloc);\012      if (this->_M_length)\012	_M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);\012\012      __r->_M_set_length_and_sharable(this->_M_length);\012      return __r->_M_refdata();\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    void\012    basic_string<_CharT, _Traits, _Alloc>::\012    resize(size_type __n, _CharT __c)\012    {\012      const size_type __size = this->size();\012      _M_check_length(__size, __n, \"basic_string::resize\");\012      if (__size < __n)\012	this->append(__n - __size, __c);\012      else if (__n < __size)\012	this->erase(__n);\012      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    template<typename _InputIterator>\012      basic_string<_CharT, _Traits, _Alloc>&\012      basic_string<_CharT, _Traits, _Alloc>::\012      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,\012			  _InputIterator __k2, __false_type)\012      {\012	const basic_string __s(__k1, __k2);\012	const size_type __n1 = __i2 - __i1;\012	_M_check_length(__n1, __s.size(), \"basic_string::_M_replace_dispatch\");\012	return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),\012			       __s.size());\012      }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>&\012    basic_string<_CharT, _Traits, _Alloc>::\012    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,\012		   _CharT __c)\012    {\012      _M_check_length(__n1, __n2, \"basic_string::_M_replace_aux\");\012      _M_mutate(__pos1, __n1, __n2);\012      if (__n2)\012	_M_assign(_M_data() + __pos1, __n2, __c);\012      return *this;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>&\012    basic_string<_CharT, _Traits, _Alloc>::\012    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,\012		    size_type __n2)\012    {\012      _M_mutate(__pos1, __n1, __n2);\012      if (__n2)\012	_M_copy(_M_data() + __pos1, __s, __n2);\012      return *this;\012    }\012   \012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>\012    operator+(const _CharT* __lhs,\012	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    {\012      __glibcxx_requires_string(__lhs);\012      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\012      typedef typename __string_type::size_type	  __size_type;\012      const __size_type __len = _Traits::length(__lhs);\012      __string_type __str;\012      __str.reserve(__len + __rhs.size());\012      __str.append(__lhs, __len);\012      __str.append(__rhs);\012      return __str;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_string<_CharT, _Traits, _Alloc>\012    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)\012    {\012      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\012      typedef typename __string_type::size_type	  __size_type;\012      __string_type __str;\012      const __size_type __len = __rhs.size();\012      __str.reserve(__len + 1);\012      __str.append(__size_type(1), __lhs);\012      __str.append(__rhs);\012      return __str;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    copy(_CharT* __s, size_type __n, size_type __pos) const\012    {\012      _M_check(__pos, \"basic_string::copy\");\012      __n = _M_limit(__pos, __n);\012      __glibcxx_requires_string_len(__s, __n);\012      if (__n)\012	_M_copy(__s, _M_data() + __pos, __n);\012      // 21.3.5.7 par 3: do not append null.  (good.)\012      return __n;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    find(const _CharT* __s, size_type __pos, size_type __n) const\012    {\012      __glibcxx_requires_string_len(__s, __n);\012      const size_type __size = this->size();\012      const _CharT* __data = _M_data();\012\012      if (__n == 0)\012	return __pos <= __size ? __pos : npos;\012\012      if (__n <= __size)\012	{\012	  for (; __pos <= __size - __n; ++__pos)\012	    if (traits_type::eq(__data[__pos], __s[0])\012		&& traits_type::compare(__data + __pos + 1,\012					__s + 1, __n - 1) == 0)\012	      return __pos;\012	}\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    find(_CharT __c, size_type __pos) const\012    {\012      size_type __ret = npos;\012      const size_type __size = this->size();\012      if (__pos < __size)\012	{\012	  const _CharT* __data = _M_data();\012	  const size_type __n = __size - __pos;\012	  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);\012	  if (__p)\012	    __ret = __p - __data;\012	}\012      return __ret;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    rfind(const _CharT* __s, size_type __pos, size_type __n) const\012    {\012      __glibcxx_requires_string_len(__s, __n);\012      const size_type __size = this->size();\012      if (__n <= __size)\012	{\012	  __pos = std::min(size_type(__size - __n), __pos);\012	  const _CharT* __data = _M_data();\012	  do\012	    {\012	      if (traits_type::compare(__data + __pos, __s, __n) == 0)\012		return __pos;\012	    }\012	  while (__pos-- > 0);\012	}\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    rfind(_CharT __c, size_type __pos) const\012    {\012      size_type __size = this->size();\012      if (__size)\012	{\012	  if (--__size > __pos)\012	    __size = __pos;\012	  for (++__size; __size-- > 0; )\012	    if (traits_type::eq(_M_data()[__size], __c))\012	      return __size;\012	}\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\012    {\012      __glibcxx_requires_string_len(__s, __n);\012      for (; __n && __pos < this->size(); ++__pos)\012	{\012	  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);\012	  if (__p)\012	    return __pos;\012	}\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\012    {\012      __glibcxx_requires_string_len(__s, __n);\012      size_type __size = this->size();\012      if (__size && __n)\012	{\012	  if (--__size > __pos)\012	    __size = __pos;\012	  do\012	    {\012	      if (traits_type::find(__s, __n, _M_data()[__size]))\012		return __size;\012	    }\012	  while (__size-- != 0);\012	}\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const\012    {\012      __glibcxx_requires_string_len(__s, __n);\012      for (; __pos < this->size(); ++__pos)\012	if (!traits_type::find(__s, __n, _M_data()[__pos]))\012	  return __pos;\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    find_first_not_of(_CharT __c, size_type __pos) const\012    {\012      for (; __pos < this->size(); ++__pos)\012	if (!traits_type::eq(_M_data()[__pos], __c))\012	  return __pos;\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const\012    {\012      __glibcxx_requires_string_len(__s, __n);\012      size_type __size = this->size();\012      if (__size)\012	{\012	  if (--__size > __pos)\012	    __size = __pos;\012	  do\012	    {\012	      if (!traits_type::find(__s, __n, _M_data()[__size]))\012		return __size;\012	    }\012	  while (__size--);\012	}\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    typename basic_string<_CharT, _Traits, _Alloc>::size_type\012    basic_string<_CharT, _Traits, _Alloc>::\012    find_last_not_of(_CharT __c, size_type __pos) const\012    {\012      size_type __size = this->size();\012      if (__size)\012	{\012	  if (--__size > __pos)\012	    __size = __pos;\012	  do\012	    {\012	      if (!traits_type::eq(_M_data()[__size], __c))\012		return __size;\012	    }\012	  while (__size--);\012	}\012      return npos;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    int\012    basic_string<_CharT, _Traits, _Alloc>::\012    compare(size_type __pos, size_type __n, const basic_string& __str) const\012    {\012      _M_check(__pos, \"basic_string::compare\");\012      __n = _M_limit(__pos, __n);\012      const size_type __osize = __str.size();\012      const size_type __len = std::min(__n, __osize);\012      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);\012      if (!__r)\012	__r = _S_compare(__n, __osize);\012      return __r;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    int\012    basic_string<_CharT, _Traits, _Alloc>::\012    compare(size_type __pos1, size_type __n1, const basic_string& __str,\012	    size_type __pos2, size_type __n2) const\012    {\012      _M_check(__pos1, \"basic_string::compare\");\012      __str._M_check(__pos2, \"basic_string::compare\");\012      __n1 = _M_limit(__pos1, __n1);\012      __n2 = __str._M_limit(__pos2, __n2);\012      const size_type __len = std::min(__n1, __n2);\012      int __r = traits_type::compare(_M_data() + __pos1,\012				     __str.data() + __pos2, __len);\012      if (!__r)\012	__r = _S_compare(__n1, __n2);\012      return __r;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    int\012    basic_string<_CharT, _Traits, _Alloc>::\012    compare(const _CharT* __s) const\012    {\012      __glibcxx_requires_string(__s);\012      const size_type __size = this->size();\012      const size_type __osize = traits_type::length(__s);\012      const size_type __len = std::min(__size, __osize);\012      int __r = traits_type::compare(_M_data(), __s, __len);\012      if (!__r)\012	__r = _S_compare(__size, __osize);\012      return __r;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    int\012    basic_string <_CharT, _Traits, _Alloc>::\012    compare(size_type __pos, size_type __n1, const _CharT* __s) const\012    {\012      __glibcxx_requires_string(__s);\012      _M_check(__pos, \"basic_string::compare\");\012      __n1 = _M_limit(__pos, __n1);\012      const size_type __osize = traits_type::length(__s);\012      const size_type __len = std::min(__n1, __osize);\012      int __r = traits_type::compare(_M_data() + __pos, __s, __len);\012      if (!__r)\012	__r = _S_compare(__n1, __osize);\012      return __r;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    int\012    basic_string <_CharT, _Traits, _Alloc>::\012    compare(size_type __pos, size_type __n1, const _CharT* __s,\012	    size_type __n2) const\012    {\012      __glibcxx_requires_string_len(__s, __n2);\012      _M_check(__pos, \"basic_string::compare\");\012      __n1 = _M_limit(__pos, __n1);\012      const size_type __len = std::min(__n1, __n2);\012      int __r = traits_type::compare(_M_data() + __pos, __s, __len);\012      if (!__r)\012	__r = _S_compare(__n1, __n2);\012      return __r;\012    }\012\012  // 21.3.7.9 basic_string::getline and operators\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_istream<_CharT, _Traits>&\012    operator>>(basic_istream<_CharT, _Traits>& __in,\012	       basic_string<_CharT, _Traits, _Alloc>& __str)\012    {\012      typedef basic_istream<_CharT, _Traits>		__istream_type;\012      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;\012      typedef typename __istream_type::ios_base         __ios_base;\012      typedef typename __istream_type::int_type		__int_type;\012      typedef typename __string_type::size_type		__size_type;\012      typedef ctype<_CharT>				__ctype_type;\012      typedef typename __ctype_type::ctype_base         __ctype_base;\012\012      __size_type __extracted = 0;\012      typename __ios_base::iostate __err = __ios_base::goodbit;\012      typename __istream_type::sentry __cerb(__in, false);\012      if (__cerb)\012	{\012	  __try\012	    {\012	      // Avoid reallocation for common case.\012	      __str.erase();\012	      _CharT __buf[128];\012	      __size_type __len = 0;	      \012	      const streamsize __w = __in.width();\012	      const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)\012		                              : __str.max_size();\012	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());\012	      const __int_type __eof = _Traits::eof();\012	      __int_type __c = __in.rdbuf()->sgetc();\012\012	      while (__extracted < __n\012		     && !_Traits::eq_int_type(__c, __eof)\012		     && !__ct.is(__ctype_base::space,\012				 _Traits::to_char_type(__c)))\012		{\012		  if (__len == sizeof(__buf) / sizeof(_CharT))\012		    {\012		      __str.append(__buf, sizeof(__buf) / sizeof(_CharT));\012		      __len = 0;\012		    }\012		  __buf[__len++] = _Traits::to_char_type(__c);\012		  ++__extracted;\012		  __c = __in.rdbuf()->snextc();\012		}\012	      __str.append(__buf, __len);\012\012	      if (_Traits::eq_int_type(__c, __eof))\012		__err |= __ios_base::eofbit;\012	      __in.width(0);\012	    }\012	  __catch(__cxxabiv1::__forced_unwind&)\012	    {\012	      __in._M_setstate(__ios_base::badbit);\012	      __throw_exception_again;\012	    }\012	  __catch(...)\012	    {\012	      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012	      // 91. Description of operator>> and getline() for string<>\012	      // might cause endless loop\012	      __in._M_setstate(__ios_base::badbit);\012	    }\012	}\012      // 211.  operator>>(istream&, string&) doesn't set failbit\012      if (!__extracted)\012	__err |= __ios_base::failbit;\012      if (__err)\012	__in.setstate(__err);\012      return __in;\012    }\012\012  template<typename _CharT, typename _Traits, typename _Alloc>\012    basic_istream<_CharT, _Traits>&\012    getline(basic_istream<_CharT, _Traits>& __in,\012	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\012    {\012      typedef basic_istream<_CharT, _Traits>		__istream_type;\012      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;\012      typedef typename __istream_type::ios_base         __ios_base;\012      typedef typename __istream_type::int_type		__int_type;\012      typedef typename __string_type::size_type		__size_type;\012\012      __size_type __extracted = 0;\012      const __size_type __n = __str.max_size();\012      typename __ios_base::iostate __err = __ios_base::goodbit;\012      typename __istream_type::sentry __cerb(__in, true);\012      if (__cerb)\012	{\012	  __try\012	    {\012	      __str.erase();\012	      const __int_type __idelim = _Traits::to_int_type(__delim);\012	      const __int_type __eof = _Traits::eof();\012	      __int_type __c = __in.rdbuf()->sgetc();\012\012	      while (__extracted < __n\012		     && !_Traits::eq_int_type(__c, __eof)\012		     && !_Traits::eq_int_type(__c, __idelim))\012		{\012		  __str += _Traits::to_char_type(__c);\012		  ++__extracted;\012		  __c = __in.rdbuf()->snextc();\012		}\012\012	      if (_Traits::eq_int_type(__c, __eof))\012		__err |= __ios_base::eofbit;\012	      else if (_Traits::eq_int_type(__c, __idelim))\012		{\012		  ++__extracted;		  \012		  __in.rdbuf()->sbumpc();\012		}\012	      else\012		__err |= __ios_base::failbit;\012	    }\012	  __catch(__cxxabiv1::__forced_unwind&)\012	    {\012	      __in._M_setstate(__ios_base::badbit);\012	      __throw_exception_again;\012	    }\012	  __catch(...)\012	    {\012	      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012	      // 91. Description of operator>> and getline() for string<>\012	      // might cause endless loop\012	      __in._M_setstate(__ios_base::badbit);\012	    }\012	}\012      if (!__extracted)\012	__err |= __ios_base::failbit;\012      if (__err)\012	__in.setstate(__err);\012      return __in;\012    }\012\012  // Inhibit implicit instantiations for required instantiations,\012  // which are defined via explicit instantiations elsewhere.\012  // NB: This syntax is a GNU extension.\012#if _GLIBCXX_EXTERN_TEMPLATE > 0\012  extern template class basic_string<char>;\012  extern template\012    basic_istream<char>&\012    operator>>(basic_istream<char>&, string&);\012  extern template\012    basic_ostream<char>&\012    operator<<(basic_ostream<char>&, const string&);\012  extern template\012    basic_istream<char>&\012    getline(basic_istream<char>&, string&, char);\012  extern template\012    basic_istream<char>&\012    getline(basic_istream<char>&, string&);\012\012#ifdef _GLIBCXX_USE_WCHAR_T\012  extern template class basic_string<wchar_t>;\012  extern template\012    basic_istream<wchar_t>&\012    operator>>(basic_istream<wchar_t>&, wstring&);\012  extern template\012    basic_ostream<wchar_t>&\012    operator<<(basic_ostream<wchar_t>&, const wstring&);\012  extern template\012    basic_istream<wchar_t>&\012    getline(basic_istream<wchar_t>&, wstring&, wchar_t);\012  extern template\012    basic_istream<wchar_t>&\012    getline(basic_istream<wchar_t>&, wstring&);\012#endif\012#endif\012\012_GLIBCXX_END_NAMESPACE\012\012#endif\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/c++locale.h", "name":"c++locale.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/x86_64-redhat-linux/bits/c++locale.h", "content":"// Wrapper for underlying C-language localization -*- C++ -*-\012\012// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file c++locale.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012//\012// ISO C++ 14882: 22.8  Standard locale categories.\012//\012\012// Written by Benjamin Kosnik <bkoz@redhat.com>\012\012#ifndef _GLIBCXX_CXX_LOCALE_H\012#define _GLIBCXX_CXX_LOCALE_H 1\012\012#pragma GCC system_header\012\012#include <clocale>\012#include <cstddef>\012\012#define _GLIBCXX_C_LOCALE_GNU 1\012\012#define _GLIBCXX_NUM_CATEGORIES 6\012\012#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\012_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\012\012  extern \"C\" __typeof(uselocale) __uselocale;\012\012_GLIBCXX_END_NAMESPACE\012#endif\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  typedef __locale_t		__c_locale;\012\012  // Convert numeric value of type double and long double to string and\012  // return length of string.  If vsnprintf is available use it, otherwise\012  // fall back to the unsafe vsprintf which, in general, can be dangerous\012  // and should be avoided.\012  inline int\012  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),\012		   char* __out,\012		   const int __size __attribute__ ((__unused__)),\012		   const char* __fmt, ...)\012  {\012#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\012    __c_locale __old = __gnu_cxx::__uselocale(__cloc);\012#else\012    char* __old = std::setlocale(LC_NUMERIC, NULL);\012    char* __sav = NULL;\012    if (__builtin_strcmp(__old, \"C\"))\012      {\012	const size_t __len = __builtin_strlen(__old) + 1;\012	__sav = new char[__len];\012	__builtin_memcpy(__sav, __old, __len);\012	std::setlocale(LC_NUMERIC, \"C\");\012      }\012#endif\012\012    __builtin_va_list __args;\012    __builtin_va_start(__args, __fmt);\012\012#ifdef _GLIBCXX_USE_C99\012    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);\012#else\012    const int __ret = __builtin_vsprintf(__out, __fmt, __args);\012#endif\012\012    __builtin_va_end(__args);\012\012#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\012    __gnu_cxx::__uselocale(__old);\012#else\012    if (__sav)\012      {\012	std::setlocale(LC_NUMERIC, __sav);\012	delete [] __sav;\012      }\012#endif\012    return __ret;\012  }\012\012_GLIBCXX_END_NAMESPACE\012\012#endif\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/char_traits.h", "name":"char_traits.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/char_traits.h", "content":"// Character Traits for use by standard string and iostream -*- C++ -*-\012\012// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\012// 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file char_traits.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012//\012// ISO C++ 14882: 21  Strings library\012//\012\012#ifndef _CHAR_TRAITS_H\012#define _CHAR_TRAITS_H 1\012\012#pragma GCC system_header\012\012#include <bits/stl_algobase.h>  // std::copy, std::fill_n\012#include <bits/postypes.h>      // For streampos\012#include <cwchar>               // For WEOF, wmemmove, wmemset, etc.\012\012#ifndef _GLIBCXX_STDIO_MACROS\012# include <cstdio>              // For EOF\012# define _CHAR_TRAITS_EOF EOF\012#else\012# define _CHAR_TRAITS_EOF (-1)\012#endif\012\012_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\012\012  /**\012   *  @brief  Mapping from character type to associated types.\012   *\012   *  @note This is an implementation class for the generic version\012   *  of char_traits.  It defines int_type, off_type, pos_type, and\012   *  state_type.  By default these are unsigned long, streamoff,\012   *  streampos, and mbstate_t.  Users who need a different set of\012   *  types, but who don't need to change the definitions of any function\012   *  defined in char_traits, can specialize __gnu_cxx::_Char_types\012   *  while leaving __gnu_cxx::char_traits alone. */\012  template<typename _CharT>\012    struct _Char_types\012    {\012      typedef unsigned long   int_type;\012      typedef std::streampos  pos_type;\012      typedef std::streamoff  off_type;\012      typedef std::mbstate_t  state_type;\012    };\012\012\012  /**\012   *  @brief  Base class used to implement std::char_traits.\012   *\012   *  @note For any given actual character type, this definition is\012   *  probably wrong.  (Most of the member functions are likely to be\012   *  right, but the int_type and state_type typedefs, and the eof()\012   *  member function, are likely to be wrong.)  The reason this class\012   *  exists is so users can specialize it.  Classes in namespace std\012   *  may not be specialized for fundamental types, but classes in\012   *  namespace __gnu_cxx may be.\012   *\012   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt05ch13s03.html\012   *  for advice on how to make use of this class for \"unusual\" character\012   *  types. Also, check out include/ext/pod_char_traits.h.  \012   */\012  template<typename _CharT>\012    struct char_traits\012    {\012      typedef _CharT                                    char_type;\012      typedef typename _Char_types<_CharT>::int_type    int_type;\012      typedef typename _Char_types<_CharT>::pos_type    pos_type;\012      typedef typename _Char_types<_CharT>::off_type    off_type;\012      typedef typename _Char_types<_CharT>::state_type  state_type;\012\012      static void\012      assign(char_type& __c1, const char_type& __c2)\012      { __c1 = __c2; }\012\012      static bool\012      eq(const char_type& __c1, const char_type& __c2)\012      { return __c1 == __c2; }\012\012      static bool\012      lt(const char_type& __c1, const char_type& __c2)\012      { return __c1 < __c2; }\012\012      static int\012      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);\012\012      static std::size_t\012      length(const char_type* __s);\012\012      static const char_type*\012      find(const char_type* __s, std::size_t __n, const char_type& __a);\012\012      static char_type*\012      move(char_type* __s1, const char_type* __s2, std::size_t __n);\012\012      static char_type*\012      copy(char_type* __s1, const char_type* __s2, std::size_t __n);\012\012      static char_type*\012      assign(char_type* __s, std::size_t __n, char_type __a);\012\012      static char_type\012      to_char_type(const int_type& __c)\012      { return static_cast<char_type>(__c); }\012\012      static int_type\012      to_int_type(const char_type& __c)\012      { return static_cast<int_type>(__c); }\012\012      static bool\012      eq_int_type(const int_type& __c1, const int_type& __c2)\012      { return __c1 == __c2; }\012\012      static int_type\012      eof()\012      { return static_cast<int_type>(_CHAR_TRAITS_EOF); }\012\012      static int_type\012      not_eof(const int_type& __c)\012      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }\012    };\012\012  template<typename _CharT>\012    int\012    char_traits<_CharT>::\012    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)\012    {\012      for (std::size_t __i = 0; __i < __n; ++__i)\012	if (lt(__s1[__i], __s2[__i]))\012	  return -1;\012	else if (lt(__s2[__i], __s1[__i]))\012	  return 1;\012      return 0;\012    }\012\012  template<typename _CharT>\012    std::size_t\012    char_traits<_CharT>::\012    length(const char_type* __p)\012    {\012      std::size_t __i = 0;\012      while (!eq(__p[__i], char_type()))\012        ++__i;\012      return __i;\012    }\012\012  template<typename _CharT>\012    const typename char_traits<_CharT>::char_type*\012    char_traits<_CharT>::\012    find(const char_type* __s, std::size_t __n, const char_type& __a)\012    {\012      for (std::size_t __i = 0; __i < __n; ++__i)\012        if (eq(__s[__i], __a))\012          return __s + __i;\012      return 0;\012    }\012\012  template<typename _CharT>\012    typename char_traits<_CharT>::char_type*\012    char_traits<_CharT>::\012    move(char_type* __s1, const char_type* __s2, std::size_t __n)\012    {\012      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,\012						    __n * sizeof(char_type)));\012    }\012\012  template<typename _CharT>\012    typename char_traits<_CharT>::char_type*\012    char_traits<_CharT>::\012    copy(char_type* __s1, const char_type* __s2, std::size_t __n)\012    {\012      // NB: Inline std::copy so no recursive dependencies.\012      std::copy(__s2, __s2 + __n, __s1);\012      return __s1;\012    }\012\012  template<typename _CharT>\012    typename char_traits<_CharT>::char_type*\012    char_traits<_CharT>::\012    assign(char_type* __s, std::size_t __n, char_type __a)\012    {\012      // NB: Inline std::fill_n so no recursive dependencies.\012      std::fill_n(__s, __n, __a);\012      return __s;\012    }\012\012_GLIBCXX_END_NAMESPACE\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  // 21.1\012  /**\012   *  @brief  Basis for explicit traits specializations.\012   *\012   *  @note  For any given actual character type, this definition is\012   *  probably wrong.  Since this is just a thin wrapper around\012   *  __gnu_cxx::char_traits, it is possible to achieve a more\012   *  appropriate definition by specializing __gnu_cxx::char_traits.\012   *\012   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt05ch13s03.html\012   *  for advice on how to make use of this class for \"unusual\" character\012   *  types. Also, check out include/ext/pod_char_traits.h.\012  */\012  template<class _CharT>\012    struct char_traits : public __gnu_cxx::char_traits<_CharT>\012    { };\012\012\012  /// 21.1.3.1  char_traits specializations\012  template<>\012    struct char_traits<char>\012    {\012      typedef char              char_type;\012      typedef int               int_type;\012      typedef streampos         pos_type;\012      typedef streamoff         off_type;\012      typedef mbstate_t         state_type;\012\012      static void\012      assign(char_type& __c1, const char_type& __c2)\012      { __c1 = __c2; }\012\012      static bool\012      eq(const char_type& __c1, const char_type& __c2)\012      { return __c1 == __c2; }\012\012      static bool\012      lt(const char_type& __c1, const char_type& __c2)\012      { return __c1 < __c2; }\012\012      static int\012      compare(const char_type* __s1, const char_type* __s2, size_t __n)\012      { return __builtin_memcmp(__s1, __s2, __n); }\012\012      static size_t\012      length(const char_type* __s)\012      { return __builtin_strlen(__s); }\012\012      static const char_type*\012      find(const char_type* __s, size_t __n, const char_type& __a)\012      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }\012\012      static char_type*\012      move(char_type* __s1, const char_type* __s2, size_t __n)\012      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }\012\012      static char_type*\012      copy(char_type* __s1, const char_type* __s2, size_t __n)\012      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }\012\012      static char_type*\012      assign(char_type* __s, size_t __n, char_type __a)\012      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }\012\012      static char_type\012      to_char_type(const int_type& __c)\012      { return static_cast<char_type>(__c); }\012\012      // To keep both the byte 0xff and the eof symbol 0xffffffff\012      // from ending up as 0xffffffff.\012      static int_type\012      to_int_type(const char_type& __c)\012      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }\012\012      static bool\012      eq_int_type(const int_type& __c1, const int_type& __c2)\012      { return __c1 == __c2; }\012\012      static int_type\012      eof()\012      { return static_cast<int_type>(_CHAR_TRAITS_EOF); }\012\012      static int_type\012      not_eof(const int_type& __c)\012      { return (__c == eof()) ? 0 : __c; }\012  };\012\012\012#ifdef _GLIBCXX_USE_WCHAR_T\012  /// 21.1.3.2  char_traits specializations\012  template<>\012    struct char_traits<wchar_t>\012    {\012      typedef wchar_t           char_type;\012      typedef wint_t            int_type;\012      typedef streamoff         off_type;\012      typedef wstreampos        pos_type;\012      typedef mbstate_t         state_type;\012\012      static void\012      assign(char_type& __c1, const char_type& __c2)\012      { __c1 = __c2; }\012\012      static bool\012      eq(const char_type& __c1, const char_type& __c2)\012      { return __c1 == __c2; }\012\012      static bool\012      lt(const char_type& __c1, const char_type& __c2)\012      { return __c1 < __c2; }\012\012      static int\012      compare(const char_type* __s1, const char_type* __s2, size_t __n)\012      { return wmemcmp(__s1, __s2, __n); }\012\012      static size_t\012      length(const char_type* __s)\012      { return wcslen(__s); }\012\012      static const char_type*\012      find(const char_type* __s, size_t __n, const char_type& __a)\012      { return wmemchr(__s, __a, __n); }\012\012      static char_type*\012      move(char_type* __s1, const char_type* __s2, size_t __n)\012      { return wmemmove(__s1, __s2, __n); }\012\012      static char_type*\012      copy(char_type* __s1, const char_type* __s2, size_t __n)\012      { return wmemcpy(__s1, __s2, __n); }\012\012      static char_type*\012      assign(char_type* __s, size_t __n, char_type __a)\012      { return wmemset(__s, __a, __n); }\012\012      static char_type\012      to_char_type(const int_type& __c)\012      { return char_type(__c); }\012\012      static int_type\012      to_int_type(const char_type& __c)\012      { return int_type(__c); }\012\012      static bool\012      eq_int_type(const int_type& __c1, const int_type& __c2)\012      { return __c1 == __c2; }\012\012      static int_type\012      eof()\012      { return static_cast<int_type>(WEOF); }\012\012      static int_type\012      not_eof(const int_type& __c)\012      { return eq_int_type(__c, eof()) ? 0 : __c; }\012  };\012#endif //_GLIBCXX_USE_WCHAR_T\012\012_GLIBCXX_END_NAMESPACE\012\012#if (defined(__GXX_EXPERIMENTAL_CXX0X__) \\\012     && defined(_GLIBCXX_USE_C99_STDINT_TR1))\012\012#include <cstdint>\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  template<>\012    struct char_traits<char16_t>\012    {\012      typedef char16_t          char_type;\012      typedef uint_least16_t    int_type;\012      typedef streamoff         off_type;\012      typedef u16streampos      pos_type;\012      typedef mbstate_t         state_type;\012\012      static void\012      assign(char_type& __c1, const char_type& __c2)\012      { __c1 = __c2; }\012\012      static bool\012      eq(const char_type& __c1, const char_type& __c2)\012      { return __c1 == __c2; }\012\012      static bool\012      lt(const char_type& __c1, const char_type& __c2)\012      { return __c1 < __c2; }\012\012      static int\012      compare(const char_type* __s1, const char_type* __s2, size_t __n)\012      {\012	for (size_t __i = 0; __i < __n; ++__i)\012	  if (lt(__s1[__i], __s2[__i]))\012	    return -1;\012	  else if (lt(__s2[__i], __s1[__i]))\012	    return 1;\012	return 0;\012      }\012\012      static size_t\012      length(const char_type* __s)\012      {\012	size_t __i = 0;\012	while (!eq(__s[__i], char_type()))\012	  ++__i;\012	return __i;\012      }\012\012      static const char_type*\012      find(const char_type* __s, size_t __n, const char_type& __a)\012      {\012	for (size_t __i = 0; __i < __n; ++__i)\012	  if (eq(__s[__i], __a))\012	    return __s + __i;\012	return 0;\012      }\012\012      static char_type*\012      move(char_type* __s1, const char_type* __s2, size_t __n)\012      {\012	return (static_cast<char_type*>\012		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));\012      }\012\012      static char_type*\012      copy(char_type* __s1, const char_type* __s2, size_t __n)\012      {\012	return (static_cast<char_type*>\012		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));\012      }\012\012      static char_type*\012      assign(char_type* __s, size_t __n, char_type __a)\012      {\012	for (size_t __i = 0; __i < __n; ++__i)\012	  assign(__s[__i], __a);\012	return __s;\012      }\012\012      static char_type\012      to_char_type(const int_type& __c)\012      { return char_type(__c); }\012\012      static int_type\012      to_int_type(const char_type& __c)\012      { return int_type(__c); }\012\012      static bool\012      eq_int_type(const int_type& __c1, const int_type& __c2)\012      { return __c1 == __c2; }\012\012      static int_type\012      eof()\012      { return static_cast<int_type>(-1); }\012\012      static int_type\012      not_eof(const int_type& __c)\012      { return eq_int_type(__c, eof()) ? 0 : __c; }\012    };\012\012  template<>\012    struct char_traits<char32_t>\012    {\012      typedef char32_t          char_type;\012      typedef uint_least32_t    int_type;\012      typedef streamoff         off_type;\012      typedef u32streampos      pos_type;\012      typedef mbstate_t         state_type;\012\012      static void\012      assign(char_type& __c1, const char_type& __c2)\012      { __c1 = __c2; }\012\012      static bool\012      eq(const char_type& __c1, const char_type& __c2)\012      { return __c1 == __c2; }\012\012      static bool\012      lt(const char_type& __c1, const char_type& __c2)\012      { return __c1 < __c2; }\012\012      static int\012      compare(const char_type* __s1, const char_type* __s2, size_t __n)\012      {\012	for (size_t __i = 0; __i < __n; ++__i)\012	  if (lt(__s1[__i], __s2[__i]))\012	    return -1;\012	  else if (lt(__s2[__i], __s1[__i]))\012	    return 1;\012	return 0;\012      }\012\012      static size_t\012      length(const char_type* __s)\012      {\012	size_t __i = 0;\012	while (!eq(__s[__i], char_type()))\012	  ++__i;\012	return __i;\012      }\012\012      static const char_type*\012      find(const char_type* __s, size_t __n, const char_type& __a)\012      {\012	for (size_t __i = 0; __i < __n; ++__i)\012	  if (eq(__s[__i], __a))\012	    return __s + __i;\012	return 0;\012      }\012\012      static char_type*\012      move(char_type* __s1, const char_type* __s2, size_t __n)\012      {\012	return (static_cast<char_type*>\012		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));\012      }\012\012      static char_type*\012      copy(char_type* __s1, const char_type* __s2, size_t __n)\012      { \012	return (static_cast<char_type*>\012		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));\012      }\012\012      static char_type*\012      assign(char_type* __s, size_t __n, char_type __a)\012      {\012	for (size_t __i = 0; __i < __n; ++__i)\012	  assign(__s[__i], __a);\012	return __s;\012      }\012\012      static char_type\012      to_char_type(const int_type& __c)\012      { return char_type(__c); }\012\012      static int_type\012      to_int_type(const char_type& __c)\012      { return int_type(__c); }\012\012      static bool\012      eq_int_type(const int_type& __c1, const int_type& __c2)\012      { return __c1 == __c2; }\012\012      static int_type\012      eof()\012      { return static_cast<int_type>(-1); }\012\012      static int_type\012      not_eof(const int_type& __c)\012      { return eq_int_type(__c, eof()) ? 0 : __c; }\012    };\012\012_GLIBCXX_END_NAMESPACE\012\012#endif \012\012#undef _CHAR_TRAITS_EOF\012\012#endif // _CHAR_TRAITS_H\012"}, {"path":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":true, "absName":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifndef __INTELFPGA_COMPILER__\012#ifndef component\012#define component\012#endif\012#define HLS_X86\012#endif\012\012#include \"HLS/hls_internal.h\"\012\012/* Deprecated APIs and names after intel rebranding */\012#ifdef __IHC_USE_DEPRECATED_NAMES\012#pragma message \"Warning: Enabling deprecated names - these names will not be supported in future releases.\"\012namespace ihc {}\012namespace altera = ihc;\012#define altera_hls_component_run_all ihc_hls_component_run_all\012#define altera_fence ihc_fence\012#define altera_hls_get_sim_time ihc_hls_get_sim_time\012#define altera_hls_enqueue ihc_hls_enqueue\012#define altera_hls_enqueue_noret ihc_hls_enqueue_noret\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012\012// Memory attribute macros\012#define hls_simple_dual_port_memory hls_memory hls_singlepump hls_numports_readonly_writeonly(1,1)\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012template <int n>         class dwidth:public internal::param {};\012template <int n>         class awidth:public internal::param {};\012template <int n>         class latency: public internal::param {};\012template <readwrite_t n> class readwrite_mode: public internal::param{}; // declared in hls_internal.h as enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012template <int n>         class maxburst: public internal::param {};\012template <int n>         class align: public internal::param {};\012template <int n>         class aspace: public internal::param {};\012template <bool n>        class waitrequest: public internal::param{};\012\012template <typename DT, typename p1 = internal::notinit, typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit, typename p6 = internal::notinit, typename p7 = internal::notinit, typename p8 = internal::notinit>\012class mm_master\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false):internal::memory_base(data,size,sizeof(DT),use_socket) {\012  }\012#else\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false);\012#endif\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  DT &operator[](int index);\012  DT &operator*();\012  DT *operator->();\012  template<typename T> operator T();\012  DT *operator+(int index);\012  template<typename T> DT *operator&(T value);\012  template<typename T> DT *operator|(T value);\012  template<typename T> DT *operator^(T value);\012  // This function is only supported in the testbench:\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012  // The copy constructor and assignment operator are necessary to ensure\012  // new_masters doesn't get copied.\012  mm_master(const mm_master &other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  mm_master& operator=(const mm_master& other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012private:\012  std::vector<internal::memory_base* > new_masters;\012#endif\012\012};\012\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012template <int n> class buffer:public internal::param {};\012template <int n> class readyLatency:public internal::param {};\012template <int n> class bitsPerSymbol:public internal::param {};\012template <bool b> class usesPackets:public internal::param {};\012template <bool b> class usesValid:public internal::param {};\012template <bool b> class usesReady:public internal::param {};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_in : public internal::stream<T,p1,p2,p3,p4,p5> {\012public:\012  stream_in();\012  T read();\012  void write(T arg);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_out : public internal::stream<T,p1,p2,p3,p4,p5> {\012\012public:\012  stream_out();\012  T read();\012  void write(T);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {};\012\012#else\012extern \"C\" void mem_fence(int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((DT*)mem)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*() {\012  return ((DT*)mem)[0];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)mem;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)mem);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::getInterfaceAtIndex(int index) {\012  assert(size==0 || index*data_size<size);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8> *temp = new mm_master(&(((DT*)mem)[index]), size - index * sizeof(DT), use_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_in<T,p1,p2,p3,p4,p5>::stream_in() {}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_out<T,p1,p2,p3,p4,p5>::stream_out() {\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_ready, ready_delta);\012}\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  return ((DT*)this)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*(){\012  return *((DT*)this);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)this;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  return ((DT*)this)+index;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)this);\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)this & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)this | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)this ^ (unsigned long long)value);\012}\012\012#endif\012} // namespace ihc\012\012#endif\012\012"}, {"path":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":true, "absName":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#endif\012#include <stdio.h>\012#include <stdlib.h>\012\012#if defined(__clang__) //our llvm defines _MSC_VER so check this first\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#elif defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012namespace ihc {\012// Forward declarations so I can make them friends\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> class mm_master;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_in;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_out;\012\012namespace internal {\012\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  \012  size_t sim_base;\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  ~memory_base() {}; // Cannot inherit from HLS interface\012  template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> friend class ::ihc::mm_master;\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(void *mem, size_t size, size_t data_size, bool use_socket):data_size(data_size),mem(mem),size(size),use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012\012  void set_parameters(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() {return aspace;}\012  void * get_base(){return mem;}\012  size_t get_size() {return size;}\012  int get_awidth() {return awidth;}\012  int get_dwidth() {return dwidth;}\012  int get_latency() {return latency;}\012  readwrite_t get_readwrite_mode() {return readwrite_mode;}\012  bool get_byteenabled() {return byteenabled;}\012  int get_maxburst() {return maxburst;}\012  int get_align() {return align;}\012  bool get_waitrequest() {return waitrequest;}\012  \012  size_t get_data_size() {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base() {return sim_base;}\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, typename p1 = notinit, typename p2 = notinit, typename p3 = notinit, typename p4 = notinit, typename p5 = notinit>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012   ~stream() {} // Cannot inherit from HLS interface\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_in;\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_out;\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012#endif\012  \012protected:\012  stream();\012  \012#ifdef HLS_X86\012  stream(const stream<T,p1,p2,p3,p4,p5>& copy_from);\012#endif\012  \012public:     \012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read();               \012  virtual void write(T arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(T arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop);\012  virtual void write(T arg, bool sop, bool eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual bool tryWrite(T arg, bool sop, bool eop);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(T arg);      \012  T tryRead(bool &success); \012  bool tryWrite(T arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012#ifdef HLS_X86\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream(const stream<T,p1,p2,p3,p4,p5>& copy_from):stream_abstract_base(sizeof(T)),q_(copy_from.q_),qp_(copy_from.qp_)\012{\012}\012#endif\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read(sop,eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read() {\012  T arg;      \012  \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  qp_.pop(); //unused sideband signals\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012  T arg;\012\012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  qp_.pop(); //unused sideband signals\012  \012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front() {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg, sop, eop);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(false,false)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(sop, eop)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::stall() {\012  if (m_remaining_period > 0) {\012    m_remaining_period--;\012    if (m_remaining_period < m_period_threshold) { \012      return false;\012    } else {\012      return true;\012    }\012  }\012  setStallPeriod();\012  return false;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012unsigned stream<T,p1,p2,p3,p4,p5>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#endif\012\012"}, {"path":"image.cpp", "name":"image.cpp", "has_active_debug_locs":true, "absName":"/home/monstrinho/work/HLS/image.cpp", "content":"#include \"HLS/stdio.h\"\012#include <stdlib.h>\012#include <string.h>\012\012#include <iostream>\012#include <fstream>\012#include <memory>\012\012#include \"HLS/hls.h\"\012\012#define IMG_W 400\012#define IMG_H 400\012\012#define OFFSET 50\012\012#define IMG_IN \"img.pgm\"\012#define IMG_OUT \"out.pgm\"\012\012// just for a NxN image\012inline uint pxToMem(uint x, uint y, uint N){\012  return(x+y*N);\012}\012\012// px + OFFSET\012component void imgOffSet(ihc::mm_master<unsigned char, ihc::aspace<1>, ihc::awidth<32>, ihc::dwidth<8> >& imgIn,\012                         ihc::mm_master<unsigned char, ihc::aspace<2>, ihc::awidth<32>, ihc::dwidth<8> >& imgOut,\012                         int N)\012{\012    for(int y=0; y < N; y++){\012      for (int x=0; x < N; x++){\012        int px = pxToMem(x,y,N);\012        printf(\"%d \\n\", px);\012        unsigned int tpx = ((unsigned int) imgIn[px])+OFFSET;\012        if(tpx > 255)\012          imgOut[px]= 255;\012        else\012          imgOut[px]= tpx;\012   	 }\012	}\012}\012\012void readImgPgm(const char imgIn[32], unsigned char img[], unsigned int n){\012  FILE* fr = fopen(imgIn, \"r\");\012\012  char s[64];\012  fgets(s, 64, fr); // P3\012  fgets(s, 64, fr); // GIMP\012  fgets(s, 64, fr); // 400 400\012  fgets(s, 64, fr); // 255\012\012  for (int i=0; i< n; i++){\012    fgets(s, 64, fr);\012    img[i] = atoi(s);\012  }\012}\012\012\012void writeImgPgm(const char imgOut[32], unsigned char img[], unsigned int n){\012  FILE* fw = fopen(imgOut, \"w\");\012  fprintf(fw, \"P2\\n\");\012  fprintf(fw, \"# HLS img kernel test\\n\");\012  fprintf(fw, \"%d %d\\n\", IMG_W,IMG_H);\012  fprintf(fw, \"%d \\n\", 255);\012\012  for (int i=0; i< n; i++){\012    fprintf(fw, \"%d\\n\", (int)img[i]);\012  }\012}\012\012int main(void) {\012\012  int N = IMG_W;\012  int M_SIZE = N*N;\012\012  // create memorys\012  unsigned char in[M_SIZE];\012  unsigned char out[M_SIZE];\012  memset(out,0,sizeof(out));\012\012  /* -------------------------- */\012  /* reading img to mem */\012  /* -------------------------- */\012  printf(\"loading img\\n\");\012  readImgPgm(IMG_IN, in, M_SIZE);\012\012  /* -------------------------- */\012  /* create fake memorys components*/\012  /* -------------------------- */\012  ihc::mm_master<unsigned char, ihc::aspace<1>, ihc::awidth<32>, ihc::dwidth<8> >mm_in(in, M_SIZE);\012  ihc::mm_master<unsigned char, ihc::aspace<2>, ihc::awidth<32>, ihc::dwidth<8> >mm_out(out, M_SIZE);\012\012  /* -------------------------- */\012  /* process with kernel */\012  /* -------------------------- */\012  printf(\"processing \\n\");\012  imgOffSet(mm_in, mm_out, N);\012\012  /* -------------------------- */\012  /* img out */\012  /* -------------------------- */\012  printf(\"outputing img\\n\");\012  writeImgPgm(IMG_OUT, out, M_SIZE);\012\012  return 0;\012}\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/ios_base.h", "name":"ios_base.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/ios_base.h", "content":"// Iostreams base classes -*- C++ -*-\012\012// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\012// 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file ios_base.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012//\012// ISO C++ 14882: 27.4  Iostreams base classes\012//\012\012#ifndef _IOS_BASE_H\012#define _IOS_BASE_H 1\012\012#pragma GCC system_header\012\012#include <ext/atomicity.h>\012#include <bits/localefwd.h>\012#include <bits/locale_classes.h>\012\012#ifndef _GLIBCXX_STDIO_MACROS\012# include <cstdio>   // For SEEK_CUR, SEEK_END\012# define _IOS_BASE_SEEK_CUR SEEK_CUR\012# define _IOS_BASE_SEEK_END SEEK_END\012#else\012# define _IOS_BASE_SEEK_CUR 1\012# define _IOS_BASE_SEEK_END 2\012#endif\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  // The following definitions of bitmask types are enums, not ints,\012  // as permitted (but not required) in the standard, in order to provide\012  // better type safety in iostream calls.  A side effect is that\012  // expressions involving them are no longer compile-time constants.\012  enum _Ios_Fmtflags \012    { \012      _S_boolalpha 	= 1L << 0,\012      _S_dec 		= 1L << 1,\012      _S_fixed 		= 1L << 2,\012      _S_hex 		= 1L << 3,\012      _S_internal 	= 1L << 4,\012      _S_left 		= 1L << 5,\012      _S_oct 		= 1L << 6,\012      _S_right 		= 1L << 7,\012      _S_scientific 	= 1L << 8,\012      _S_showbase 	= 1L << 9,\012      _S_showpoint 	= 1L << 10,\012      _S_showpos 	= 1L << 11,\012      _S_skipws 	= 1L << 12,\012      _S_unitbuf 	= 1L << 13,\012      _S_uppercase 	= 1L << 14,\012      _S_adjustfield 	= _S_left | _S_right | _S_internal,\012      _S_basefield 	= _S_dec | _S_oct | _S_hex,\012      _S_floatfield 	= _S_scientific | _S_fixed,\012      _S_ios_fmtflags_end = 1L << 16 \012    };\012\012  inline _Ios_Fmtflags\012  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\012  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }\012\012  inline _Ios_Fmtflags\012  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\012  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }\012\012  inline _Ios_Fmtflags\012  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\012  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }\012\012  inline _Ios_Fmtflags&\012  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\012  { return __a = __a | __b; }\012\012  inline _Ios_Fmtflags&\012  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\012  { return __a = __a & __b; }\012\012  inline _Ios_Fmtflags&\012  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\012  { return __a = __a ^ __b; }\012\012  inline _Ios_Fmtflags\012  operator~(_Ios_Fmtflags __a)\012  { return _Ios_Fmtflags(~static_cast<int>(__a)); }\012\012\012  enum _Ios_Openmode \012    { \012      _S_app 		= 1L << 0,\012      _S_ate 		= 1L << 1,\012      _S_bin 		= 1L << 2,\012      _S_in 		= 1L << 3,\012      _S_out 		= 1L << 4,\012      _S_trunc 		= 1L << 5,\012      _S_ios_openmode_end = 1L << 16 \012    };\012\012  inline _Ios_Openmode\012  operator&(_Ios_Openmode __a, _Ios_Openmode __b)\012  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }\012\012  inline _Ios_Openmode\012  operator|(_Ios_Openmode __a, _Ios_Openmode __b)\012  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }\012\012  inline _Ios_Openmode\012  operator^(_Ios_Openmode __a, _Ios_Openmode __b)\012  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }\012\012  inline _Ios_Openmode&\012  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)\012  { return __a = __a | __b; }\012\012  inline _Ios_Openmode&\012  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)\012  { return __a = __a & __b; }\012\012  inline _Ios_Openmode&\012  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)\012  { return __a = __a ^ __b; }\012\012  inline _Ios_Openmode\012  operator~(_Ios_Openmode __a)\012  { return _Ios_Openmode(~static_cast<int>(__a)); }\012\012\012  enum _Ios_Iostate\012    { \012      _S_goodbit 		= 0,\012      _S_badbit 		= 1L << 0,\012      _S_eofbit 		= 1L << 1,\012      _S_failbit		= 1L << 2,\012      _S_ios_iostate_end = 1L << 16 \012    };\012\012  inline _Ios_Iostate\012  operator&(_Ios_Iostate __a, _Ios_Iostate __b)\012  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }\012\012  inline _Ios_Iostate\012  operator|(_Ios_Iostate __a, _Ios_Iostate __b)\012  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }\012\012  inline _Ios_Iostate\012  operator^(_Ios_Iostate __a, _Ios_Iostate __b)\012  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }\012\012  inline _Ios_Iostate&\012  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)\012  { return __a = __a | __b; }\012\012  inline _Ios_Iostate&\012  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)\012  { return __a = __a & __b; }\012\012  inline _Ios_Iostate&\012  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)\012  { return __a = __a ^ __b; }\012\012  inline _Ios_Iostate\012  operator~(_Ios_Iostate __a)\012  { return _Ios_Iostate(~static_cast<int>(__a)); }\012\012  enum _Ios_Seekdir \012    { \012      _S_beg = 0,\012      _S_cur = _IOS_BASE_SEEK_CUR,\012      _S_end = _IOS_BASE_SEEK_END,\012      _S_ios_seekdir_end = 1L << 16 \012    };\012\012  // 27.4.2  Class ios_base\012  /**\012   *  @brief  The base of the I/O class hierarchy.\012   *  @ingroup io\012   *\012   *  This class defines everything that can be defined about I/O that does\012   *  not depend on the type of characters being input or output.  Most\012   *  people will only see @c ios_base when they need to specify the full\012   *  name of the various I/O flags (e.g., the openmodes).\012  */\012  class ios_base\012  {\012  public:\012\012    /** \012     *  @brief These are thrown to indicate problems with io.\012     *  @ingroup exceptions\012     *\012     *  27.4.2.1.1  Class ios_base::failure\012     */\012    class failure : public exception\012    {\012    public:\012      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012      // 48.  Use of non-existent exception constructor\012      explicit\012      failure(const string& __str) throw();\012\012      // This declaration is not useless:\012      // http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Vague-Linkage.html\012      virtual\012      ~failure() throw();\012\012      virtual const char*\012      what() const throw();\012\012    private:\012      string _M_msg;\012    };\012\012    // 27.4.2.1.2  Type ios_base::fmtflags\012    /**\012     *  @brief This is a bitmask type.\012     *\012     *  @c \"_Ios_Fmtflags\" is implementation-defined, but it is valid to\012     *  perform bitwise operations on these values and expect the Right\012     *  Thing to happen.  Defined objects of type fmtflags are:\012     *  - boolalpha\012     *  - dec\012     *  - fixed\012     *  - hex\012     *  - internal\012     *  - left\012     *  - oct\012     *  - right\012     *  - scientific\012     *  - showbase\012     *  - showpoint\012     *  - showpos\012     *  - skipws\012     *  - unitbuf\012     *  - uppercase\012     *  - adjustfield\012     *  - basefield\012     *  - floatfield\012    */\012    typedef _Ios_Fmtflags fmtflags;\012\012    /// Insert/extract @c bool in alphabetic rather than numeric format.\012    static const fmtflags boolalpha =   _S_boolalpha;\012\012    /// Converts integer input or generates integer output in decimal base.\012    static const fmtflags dec =         _S_dec;\012\012    /// Generate floating-point output in fixed-point notation.\012    static const fmtflags fixed =       _S_fixed;\012\012    /// Converts integer input or generates integer output in hexadecimal base.\012    static const fmtflags hex =         _S_hex;\012\012    /// Adds fill characters at a designated internal point in certain\012    /// generated output, or identical to @c right if no such point is\012    /// designated.\012    static const fmtflags internal =    _S_internal;\012\012    /// Adds fill characters on the right (final positions) of certain\012    /// generated output.  (I.e., the thing you print is flush left.)\012    static const fmtflags left =        _S_left;\012\012    /// Converts integer input or generates integer output in octal base.\012    static const fmtflags oct =         _S_oct;\012\012    /// Adds fill characters on the left (initial positions) of certain\012    /// generated output.  (I.e., the thing you print is flush right.)\012    static const fmtflags right =       _S_right;\012\012    /// Generates floating-point output in scientific notation.\012    static const fmtflags scientific =  _S_scientific;\012\012    /// Generates a prefix indicating the numeric base of generated integer\012    /// output.\012    static const fmtflags showbase =    _S_showbase;\012\012    /// Generates a decimal-point character unconditionally in generated\012    /// floating-point output.\012    static const fmtflags showpoint =   _S_showpoint;\012\012    /// Generates a + sign in non-negative generated numeric output.\012    static const fmtflags showpos =     _S_showpos;\012\012    /// Skips leading white space before certain input operations.\012    static const fmtflags skipws =      _S_skipws;\012\012    /// Flushes output after each output operation.\012    static const fmtflags unitbuf =     _S_unitbuf;\012\012    /// Replaces certain lowercase letters with their uppercase equivalents\012    /// in generated output.\012    static const fmtflags uppercase =   _S_uppercase;\012\012    /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.\012    static const fmtflags adjustfield = _S_adjustfield;\012\012    /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.\012    static const fmtflags basefield =   _S_basefield;\012\012    /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.\012    static const fmtflags floatfield =  _S_floatfield;\012\012    // 27.4.2.1.3  Type ios_base::iostate\012    /**\012     *  @brief This is a bitmask type.\012     *\012     *  @c \"_Ios_Iostate\" is implementation-defined, but it is valid to\012     *  perform bitwise operations on these values and expect the Right\012     *  Thing to happen.  Defined objects of type iostate are:\012     *  - badbit\012     *  - eofbit\012     *  - failbit\012     *  - goodbit\012    */\012    typedef _Ios_Iostate iostate;\012\012    /// Indicates a loss of integrity in an input or output sequence (such\012    /// as an irrecoverable read error from a file).\012    static const iostate badbit =	_S_badbit;\012\012    /// Indicates that an input operation reached the end of an input sequence.\012    static const iostate eofbit =	_S_eofbit;\012\012    /// Indicates that an input operation failed to read the expected\012    /// characters, or that an output operation failed to generate the\012    /// desired characters.\012    static const iostate failbit =	_S_failbit;\012\012    /// Indicates all is well.\012    static const iostate goodbit =	_S_goodbit;\012\012    // 27.4.2.1.4  Type ios_base::openmode\012    /**\012     *  @brief This is a bitmask type.\012     *\012     *  @c \"_Ios_Openmode\" is implementation-defined, but it is valid to\012     *  perform bitwise operations on these values and expect the Right\012     *  Thing to happen.  Defined objects of type openmode are:\012     *  - app\012     *  - ate\012     *  - binary\012     *  - in\012     *  - out\012     *  - trunc\012    */\012    typedef _Ios_Openmode openmode;\012\012    /// Seek to end before each write.\012    static const openmode app =		_S_app;\012\012    /// Open and seek to end immediately after opening.\012    static const openmode ate =		_S_ate;\012\012    /// Perform input and output in binary mode (as opposed to text mode).\012    /// This is probably not what you think it is; see\012    /// http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch27s02.html\012    static const openmode binary =	_S_bin;\012\012    /// Open for input.  Default for @c ifstream and fstream.\012    static const openmode in =		_S_in;\012\012    /// Open for output.  Default for @c ofstream and fstream.\012    static const openmode out =		_S_out;\012\012    /// Open for input.  Default for @c ofstream.\012    static const openmode trunc =	_S_trunc;\012\012    // 27.4.2.1.5  Type ios_base::seekdir\012    /**\012     *  @brief This is an enumerated type.\012     *\012     *  @c \"_Ios_Seekdir\" is implementation-defined.  Defined values\012     *  of type seekdir are:\012     *  - beg\012     *  - cur, equivalent to @c SEEK_CUR in the C standard library.\012     *  - end, equivalent to @c SEEK_END in the C standard library.\012    */\012    typedef _Ios_Seekdir seekdir;\012\012    /// Request a seek relative to the beginning of the stream.\012    static const seekdir beg =		_S_beg;\012\012    /// Request a seek relative to the current position within the sequence.\012    static const seekdir cur =		_S_cur;\012\012    /// Request a seek relative to the current end of the sequence.\012    static const seekdir end =		_S_end;\012\012    // Annex D.6\012    typedef int io_state;\012    typedef int open_mode;\012    typedef int seek_dir;\012\012    typedef std::streampos streampos;\012    typedef std::streamoff streamoff;\012\012    // Callbacks;\012    /**\012     *  @brief  The set of events that may be passed to an event callback.\012     *\012     *  erase_event is used during ~ios() and copyfmt().  imbue_event is used\012     *  during imbue().  copyfmt_event is used during copyfmt().\012    */\012    enum event\012    {\012      erase_event,\012      imbue_event,\012      copyfmt_event\012    };\012\012    /**\012     *  @brief  The type of an event callback function.\012     *  @param  event  One of the members of the event enum.\012     *  @param  ios_base  Reference to the ios_base object.\012     *  @param  int  The integer provided when the callback was registered.\012     *\012     *  Event callbacks are user defined functions that get called during\012     *  several ios_base and basic_ios functions, specifically imbue(),\012     *  copyfmt(), and ~ios().\012    */\012    typedef void (*event_callback) (event, ios_base&, int);\012\012    /**\012     *  @brief  Add the callback __fn with parameter __index.\012     *  @param  __fn  The function to add.\012     *  @param  __index  The integer to pass to the function when invoked.\012     *\012     *  Registers a function as an event callback with an integer parameter to\012     *  be passed to the function when invoked.  Multiple copies of the\012     *  function are allowed.  If there are multiple callbacks, they are\012     *  invoked in the order they were registered.\012    */\012    void\012    register_callback(event_callback __fn, int __index);\012\012  protected:\012    //@{\012    /**\012     *  ios_base data members (doc me)\012    */\012    streamsize		_M_precision;\012    streamsize		_M_width;\012    fmtflags		_M_flags;\012    iostate		_M_exception;\012    iostate		_M_streambuf_state;\012    //@}\012\012    // 27.4.2.6  Members for callbacks\012    // 27.4.2.6  ios_base callbacks\012    struct _Callback_list\012    {\012      // Data Members\012      _Callback_list*		_M_next;\012      ios_base::event_callback	_M_fn;\012      int			_M_index;\012      _Atomic_word		_M_refcount;  // 0 means one reference.\012\012      _Callback_list(ios_base::event_callback __fn, int __index,\012		     _Callback_list* __cb)\012      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }\012\012      void\012      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\012\012      // 0 => OK to delete.\012      int\012      _M_remove_reference() \012      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }\012    };\012\012     _Callback_list*	_M_callbacks;\012\012    void\012    _M_call_callbacks(event __ev) throw();\012\012    void\012    _M_dispose_callbacks(void);\012\012    // 27.4.2.5  Members for iword/pword storage\012    struct _Words\012    {\012      void*	_M_pword;\012      long	_M_iword;\012      _Words() : _M_pword(0), _M_iword(0) { }\012    };\012\012    // Only for failed iword/pword calls.\012    _Words		_M_word_zero;\012\012    // Guaranteed storage.\012    // The first 5 iword and pword slots are reserved for internal use.\012    enum { _S_local_word_size = 8 };\012    _Words		_M_local_word[_S_local_word_size];\012\012    // Allocated storage.\012    int			_M_word_size;\012    _Words*		_M_word;\012\012    _Words&\012    _M_grow_words(int __index, bool __iword);\012\012    // Members for locale and locale caching.\012    locale		_M_ios_locale;\012\012    void\012    _M_init();\012\012  public:\012\012    // 27.4.2.1.6  Class ios_base::Init\012    // Used to initialize standard streams. In theory, g++ could use\012    // -finit-priority to order this stuff correctly without going\012    // through these machinations.\012    class Init\012    {\012      friend class ios_base;\012    public:\012      Init();\012      ~Init();\012\012    private:\012      static _Atomic_word	_S_refcount;\012      static bool		_S_synced_with_stdio;\012    };\012\012    // [27.4.2.2] fmtflags state functions\012    /**\012     *  @brief  Access to format flags.\012     *  @return  The format control flags for both input and output.\012    */\012    fmtflags\012    flags() const\012    { return _M_flags; }\012\012    /**\012     *  @brief  Setting new format flags all at once.\012     *  @param  fmtfl  The new flags to set.\012     *  @return  The previous format control flags.\012     *\012     *  This function overwrites all the format flags with @a fmtfl.\012    */\012    fmtflags\012    flags(fmtflags __fmtfl)\012    {\012      fmtflags __old = _M_flags;\012      _M_flags = __fmtfl;\012      return __old;\012    }\012\012    /**\012     *  @brief  Setting new format flags.\012     *  @param  fmtfl  Additional flags to set.\012     *  @return  The previous format control flags.\012     *\012     *  This function sets additional flags in format control.  Flags that\012     *  were previously set remain set.\012    */\012    fmtflags\012    setf(fmtflags __fmtfl)\012    {\012      fmtflags __old = _M_flags;\012      _M_flags |= __fmtfl;\012      return __old;\012    }\012\012    /**\012     *  @brief  Setting new format flags.\012     *  @param  fmtfl  Additional flags to set.\012     *  @param  mask  The flags mask for @a fmtfl.\012     *  @return  The previous format control flags.\012     *\012     *  This function clears @a mask in the format flags, then sets\012     *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.\012    */\012    fmtflags\012    setf(fmtflags __fmtfl, fmtflags __mask)\012    {\012      fmtflags __old = _M_flags;\012      _M_flags &= ~__mask;\012      _M_flags |= (__fmtfl & __mask);\012      return __old;\012    }\012\012    /**\012     *  @brief  Clearing format flags.\012     *  @param  mask  The flags to unset.\012     *\012     *  This function clears @a mask in the format flags.\012    */\012    void\012    unsetf(fmtflags __mask)\012    { _M_flags &= ~__mask; }\012\012    /**\012     *  @brief  Flags access.\012     *  @return  The precision to generate on certain output operations.\012     *\012     *  Be careful if you try to give a definition of \"precision\" here; see\012     *  DR 189.\012    */\012    streamsize\012    precision() const\012    { return _M_precision; }\012\012    /**\012     *  @brief  Changing flags.\012     *  @param  prec  The new precision value.\012     *  @return  The previous value of precision().\012    */\012    streamsize\012    precision(streamsize __prec)\012    {\012      streamsize __old = _M_precision;\012      _M_precision = __prec;\012      return __old;\012    }\012\012    /**\012     *  @brief  Flags access.\012     *  @return  The minimum field width to generate on output operations.\012     *\012     *  \"Minimum field width\" refers to the number of characters.\012    */\012    streamsize\012    width() const\012    { return _M_width; }\012\012    /**\012     *  @brief  Changing flags.\012     *  @param  wide  The new width value.\012     *  @return  The previous value of width().\012    */\012    streamsize\012    width(streamsize __wide)\012    {\012      streamsize __old = _M_width;\012      _M_width = __wide;\012      return __old;\012    }\012\012    // [27.4.2.4] ios_base static members\012    /**\012     *  @brief  Interaction with the standard C I/O objects.\012     *  @param  sync  Whether to synchronize or not.\012     *  @return  True if the standard streams were previously synchronized.\012     *\012     *  The synchronization referred to is @e only that between the standard\012     *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,\012     *  cout).  User-declared streams are unaffected.  See\012     *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch28s02.html\012    */\012    static bool\012    sync_with_stdio(bool __sync = true);\012\012    // [27.4.2.3] ios_base locale functions\012    /**\012     *  @brief  Setting a new locale.\012     *  @param  loc  The new locale.\012     *  @return  The previous locale.\012     *\012     *  Sets the new locale for this stream, and then invokes each callback\012     *  with imbue_event.\012    */\012    locale\012    imbue(const locale& __loc);\012\012    /**\012     *  @brief  Locale access\012     *  @return  A copy of the current locale.\012     *\012     *  If @c imbue(loc) has previously been called, then this function\012     *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),\012     *  the global C++ locale.\012    */\012    locale\012    getloc() const\012    { return _M_ios_locale; }\012\012    /**\012     *  @brief  Locale access\012     *  @return  A reference to the current locale.\012     *\012     *  Like getloc above, but returns a reference instead of\012     *  generating a copy.\012    */\012    const locale&\012    _M_getloc() const\012    { return _M_ios_locale; }\012\012    // [27.4.2.5] ios_base storage functions\012    /**\012     *  @brief  Access to unique indices.\012     *  @return  An integer different from all previous calls.\012     *\012     *  This function returns a unique integer every time it is called.  It\012     *  can be used for any purpose, but is primarily intended to be a unique\012     *  index for the iword and pword functions.  The expectation is that an\012     *  application calls xalloc in order to obtain an index in the iword and\012     *  pword arrays that can be used without fear of conflict.\012     *\012     *  The implementation maintains a static variable that is incremented and\012     *  returned on each invocation.  xalloc is guaranteed to return an index\012     *  that is safe to use in the iword and pword arrays.\012    */\012    static int\012    xalloc() throw();\012\012    /**\012     *  @brief  Access to integer array.\012     *  @param  __ix  Index into the array.\012     *  @return  A reference to an integer associated with the index.\012     *\012     *  The iword function provides access to an array of integers that can be\012     *  used for any purpose.  The array grows as required to hold the\012     *  supplied index.  All integers in the array are initialized to 0.\012     *\012     *  The implementation reserves several indices.  You should use xalloc to\012     *  obtain an index that is safe to use.  Also note that since the array\012     *  can grow dynamically, it is not safe to hold onto the reference.\012    */\012    long&\012    iword(int __ix)\012    {\012      _Words& __word = (__ix < _M_word_size)\012			? _M_word[__ix] : _M_grow_words(__ix, true);\012      return __word._M_iword;\012    }\012\012    /**\012     *  @brief  Access to void pointer array.\012     *  @param  __ix  Index into the array.\012     *  @return  A reference to a void* associated with the index.\012     *\012     *  The pword function provides access to an array of pointers that can be\012     *  used for any purpose.  The array grows as required to hold the\012     *  supplied index.  All pointers in the array are initialized to 0.\012     *\012     *  The implementation reserves several indices.  You should use xalloc to\012     *  obtain an index that is safe to use.  Also note that since the array\012     *  can grow dynamically, it is not safe to hold onto the reference.\012    */\012    void*&\012    pword(int __ix)\012    {\012      _Words& __word = (__ix < _M_word_size)\012			? _M_word[__ix] : _M_grow_words(__ix, false);\012      return __word._M_pword;\012    }\012\012    // Destructor\012    /**\012     *  Invokes each callback with erase_event.  Destroys local storage.\012     *\012     *  Note that the ios_base object for the standard streams never gets\012     *  destroyed.  As a result, any callbacks registered with the standard\012     *  streams will not get invoked with erase_event (unless copyfmt is\012     *  used).\012    */\012    virtual ~ios_base();\012\012  protected:\012    ios_base();\012\012  // _GLIBCXX_RESOLVE_LIB_DEFECTS\012  // 50.  Copy constructor and assignment operator of ios_base\012  private:\012    ios_base(const ios_base&);\012\012    ios_base&\012    operator=(const ios_base&);\012  };\012\012  // [27.4.5.1] fmtflags manipulators\012  /// Calls base.setf(ios_base::boolalpha).\012  inline ios_base&\012  boolalpha(ios_base& __base)\012  {\012    __base.setf(ios_base::boolalpha);\012    return __base;\012  }\012\012  /// Calls base.unsetf(ios_base::boolalpha).\012  inline ios_base&\012  noboolalpha(ios_base& __base)\012  {\012    __base.unsetf(ios_base::boolalpha);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::showbase).\012  inline ios_base&\012  showbase(ios_base& __base)\012  {\012    __base.setf(ios_base::showbase);\012    return __base;\012  }\012\012  /// Calls base.unsetf(ios_base::showbase).\012  inline ios_base&\012  noshowbase(ios_base& __base)\012  {\012    __base.unsetf(ios_base::showbase);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::showpoint).\012  inline ios_base&\012  showpoint(ios_base& __base)\012  {\012    __base.setf(ios_base::showpoint);\012    return __base;\012  }\012\012  /// Calls base.unsetf(ios_base::showpoint).\012  inline ios_base&\012  noshowpoint(ios_base& __base)\012  {\012    __base.unsetf(ios_base::showpoint);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::showpos).\012  inline ios_base&\012  showpos(ios_base& __base)\012  {\012    __base.setf(ios_base::showpos);\012    return __base;\012  }\012\012  /// Calls base.unsetf(ios_base::showpos).\012  inline ios_base&\012  noshowpos(ios_base& __base)\012  {\012    __base.unsetf(ios_base::showpos);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::skipws).\012  inline ios_base&\012  skipws(ios_base& __base)\012  {\012    __base.setf(ios_base::skipws);\012    return __base;\012  }\012\012  /// Calls base.unsetf(ios_base::skipws).\012  inline ios_base&\012  noskipws(ios_base& __base)\012  {\012    __base.unsetf(ios_base::skipws);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::uppercase).\012  inline ios_base&\012  uppercase(ios_base& __base)\012  {\012    __base.setf(ios_base::uppercase);\012    return __base;\012  }\012\012  /// Calls base.unsetf(ios_base::uppercase).\012  inline ios_base&\012  nouppercase(ios_base& __base)\012  {\012    __base.unsetf(ios_base::uppercase);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::unitbuf).\012  inline ios_base&\012  unitbuf(ios_base& __base)\012  {\012     __base.setf(ios_base::unitbuf);\012     return __base;\012  }\012\012  /// Calls base.unsetf(ios_base::unitbuf).\012  inline ios_base&\012  nounitbuf(ios_base& __base)\012  {\012     __base.unsetf(ios_base::unitbuf);\012     return __base;\012  }\012\012  // [27.4.5.2] adjustfield manipulators\012  /// Calls base.setf(ios_base::internal, ios_base::adjustfield).\012  inline ios_base&\012  internal(ios_base& __base)\012  {\012     __base.setf(ios_base::internal, ios_base::adjustfield);\012     return __base;\012  }\012\012  /// Calls base.setf(ios_base::left, ios_base::adjustfield).\012  inline ios_base&\012  left(ios_base& __base)\012  {\012    __base.setf(ios_base::left, ios_base::adjustfield);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::right, ios_base::adjustfield).\012  inline ios_base&\012  right(ios_base& __base)\012  {\012    __base.setf(ios_base::right, ios_base::adjustfield);\012    return __base;\012  }\012\012  // [27.4.5.3] basefield manipulators\012  /// Calls base.setf(ios_base::dec, ios_base::basefield).\012  inline ios_base&\012  dec(ios_base& __base)\012  {\012    __base.setf(ios_base::dec, ios_base::basefield);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::hex, ios_base::basefield).\012  inline ios_base&\012  hex(ios_base& __base)\012  {\012    __base.setf(ios_base::hex, ios_base::basefield);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::oct, ios_base::basefield).\012  inline ios_base&\012  oct(ios_base& __base)\012  {\012    __base.setf(ios_base::oct, ios_base::basefield);\012    return __base;\012  }\012\012  // [27.4.5.4] floatfield manipulators\012  /// Calls base.setf(ios_base::fixed, ios_base::floatfield).\012  inline ios_base&\012  fixed(ios_base& __base)\012  {\012    __base.setf(ios_base::fixed, ios_base::floatfield);\012    return __base;\012  }\012\012  /// Calls base.setf(ios_base::scientific, ios_base::floatfield).\012  inline ios_base&\012  scientific(ios_base& __base)\012  {\012    __base.setf(ios_base::scientific, ios_base::floatfield);\012    return __base;\012  }\012\012_GLIBCXX_END_NAMESPACE\012\012#undef _IOS_BASE_SEEK_CUR\012#undef _IOS_BASE_SEEK_END\012\012#endif /* _IOS_BASE_H */\012\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/locale_classes.h", "name":"locale_classes.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/locale_classes.h", "content":"// Locale support -*- C++ -*-\012\012// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\012// 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file locale_classes.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012//\012// ISO C++ 14882: 22.1  Locales\012//\012\012#ifndef _LOCALE_CLASSES_H\012#define _LOCALE_CLASSES_H 1\012\012#pragma GCC system_header\012\012#include <bits/localefwd.h>\012#include <string>\012#include <ext/atomicity.h>\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  // 22.1.1 Class locale\012  /**\012   *  @brief  Container class for localization functionality.\012   *\012   *  The locale class is first a class wrapper for C library locales.  It is\012   *  also an extensible container for user-defined localization.  A locale is\012   *  a collection of facets that implement various localization features such\012   *  as money, time, and number printing.\012   *\012   *  Constructing C++ locales does not change the C library locale.\012   *\012   *  This library supports efficient construction and copying of locales\012   *  through a reference counting implementation of the locale class.\012  */\012  class locale\012  {\012  public:\012    // Types:\012    /// Definition of locale::category.\012    typedef int	category;\012\012    // Forward decls and friends:\012    class facet;\012    class id;\012    class _Impl;\012\012    friend class facet;\012    friend class _Impl;\012\012    template<typename _Facet>\012      friend bool\012      has_facet(const locale&) throw();\012\012    template<typename _Facet>\012      friend const _Facet&\012      use_facet(const locale&);\012\012    template<typename _Cache>\012      friend struct __use_cache;\012\012    //@{\012    /**\012     *  @brief  Category values.\012     *\012     *  The standard category values are none, ctype, numeric, collate, time,\012     *  monetary, and messages.  They form a bitmask that supports union and\012     *  intersection.  The category all is the union of these values.\012     *\012     *  NB: Order must match _S_facet_categories definition in locale.cc\012    */\012    static const category none		= 0;\012    static const category ctype		= 1L << 0;\012    static const category numeric	= 1L << 1;\012    static const category collate	= 1L << 2;\012    static const category time		= 1L << 3;\012    static const category monetary	= 1L << 4;\012    static const category messages	= 1L << 5;\012    static const category all		= (ctype | numeric | collate |\012					   time  | monetary | messages);\012    //@}\012\012    // Construct/copy/destroy:\012\012    /**\012     *  @brief  Default constructor.\012     *\012     *  Constructs a copy of the global locale.  If no locale has been\012     *  explicitly set, this is the \"C\" locale.\012    */\012    locale() throw();\012\012    /**\012     *  @brief  Copy constructor.\012     *\012     *  Constructs a copy of @a other.\012     *\012     *  @param  other  The locale to copy.\012    */\012    locale(const locale& __other) throw();\012\012    /**\012     *  @brief  Named locale constructor.\012     *\012     *  Constructs a copy of the named C library locale.\012     *\012     *  @param  s  Name of the locale to construct.\012     *  @throw  std::runtime_error if s is null or an undefined locale.\012    */\012    explicit\012    locale(const char* __s);\012\012    /**\012     *  @brief  Construct locale with facets from another locale.\012     *\012     *  Constructs a copy of the locale @a base.  The facets specified by @a\012     *  cat are replaced with those from the locale named by @a s.  If base is\012     *  named, this locale instance will also be named.\012     *\012     *  @param  base  The locale to copy.\012     *  @param  s  Name of the locale to use facets from.\012     *  @param  cat  Set of categories defining the facets to use from s.\012     *  @throw  std::runtime_error if s is null or an undefined locale.\012    */\012    locale(const locale& __base, const char* __s, category __cat);\012\012    /**\012     *  @brief  Construct locale with facets from another locale.\012     *\012     *  Constructs a copy of the locale @a base.  The facets specified by @a\012     *  cat are replaced with those from the locale @a add.  If @a base and @a\012     *  add are named, this locale instance will also be named.\012     *\012     *  @param  base  The locale to copy.\012     *  @param  add  The locale to use facets from.\012     *  @param  cat  Set of categories defining the facets to use from add.\012    */\012    locale(const locale& __base, const locale& __add, category __cat);\012\012    /**\012     *  @brief  Construct locale with another facet.\012     *\012     *  Constructs a copy of the locale @a other.  The facet @f is added to\012     *  @other, replacing an existing facet of type Facet if there is one.  If\012     *  @f is null, this locale is a copy of @a other.\012     *\012     *  @param  other  The locale to copy.\012     *  @param  f  The facet to add in.\012    */\012    template<typename _Facet>\012      locale(const locale& __other, _Facet* __f);\012\012    /// Locale destructor.\012    ~locale() throw();\012\012    /**\012     *  @brief  Assignment operator.\012     *\012     *  Set this locale to be a copy of @a other.\012     *\012     *  @param  other  The locale to copy.\012     *  @return  A reference to this locale.\012    */\012    const locale&\012    operator=(const locale& __other) throw();\012\012    /**\012     *  @brief  Construct locale with another facet.\012     *\012     *  Constructs and returns a new copy of this locale.  Adds or replaces an\012     *  existing facet of type Facet from the locale @a other into the new\012     *  locale.\012     *\012     *  @param  Facet  The facet type to copy from other\012     *  @param  other  The locale to copy from.\012     *  @return  Newly constructed locale.\012     *  @throw  std::runtime_error if other has no facet of type Facet.\012    */\012    template<typename _Facet>\012      locale\012      combine(const locale& __other) const;\012\012    // Locale operations:\012    /**\012     *  @brief  Return locale name.\012     *  @return  Locale name or \"*\" if unnamed.\012    */\012    string\012    name() const;\012\012    /**\012     *  @brief  Locale equality.\012     *\012     *  @param  other  The locale to compare against.\012     *  @return  True if other and this refer to the same locale instance, are\012     *		 copies, or have the same name.  False otherwise.\012    */\012    bool\012    operator==(const locale& __other) const throw ();\012\012    /**\012     *  @brief  Locale inequality.\012     *\012     *  @param  other  The locale to compare against.\012     *  @return  ! (*this == other)\012    */\012    bool\012    operator!=(const locale& __other) const throw ()\012    { return !(this->operator==(__other)); }\012\012    /**\012     *  @brief  Compare two strings according to collate.\012     *\012     *  Template operator to compare two strings using the compare function of\012     *  the collate facet in this locale.  One use is to provide the locale to\012     *  the sort function.  For example, a vector v of strings could be sorted\012     *  according to locale loc by doing:\012     *  @code\012     *  std::sort(v.begin(), v.end(), loc);\012     *  @endcode\012     *\012     *  @param  s1  First string to compare.\012     *  @param  s2  Second string to compare.\012     *  @return  True if collate<Char> facet compares s1 < s2, else false.\012    */\012    template<typename _Char, typename _Traits, typename _Alloc>\012      bool\012      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,\012		 const basic_string<_Char, _Traits, _Alloc>& __s2) const;\012\012    // Global locale objects:\012    /**\012     *  @brief  Set global locale\012     *\012     *  This function sets the global locale to the argument and returns a\012     *  copy of the previous global locale.  If the argument has a name, it\012     *  will also call std::setlocale(LC_ALL, loc.name()).\012     *\012     *  @param  locale  The new locale to make global.\012     *  @return  Copy of the old global locale.\012    */\012    static locale\012    global(const locale&);\012\012    /**\012     *  @brief  Return reference to the \"C\" locale.\012    */\012    static const locale&\012    classic();\012\012  private:\012    // The (shared) implementation\012    _Impl*		_M_impl;\012\012    // The \"C\" reference locale\012    static _Impl*       _S_classic;\012\012    // Current global locale\012    static _Impl*	_S_global;\012\012    // Names of underlying locale categories.\012    // NB: locale::global() has to know how to modify all the\012    // underlying categories, not just the ones required by the C++\012    // standard.\012    static const char* const* const _S_categories;\012\012    // Number of standard categories. For C++, these categories are\012    // collate, ctype, monetary, numeric, time, and messages. These\012    // directly correspond to ISO C99 macros LC_COLLATE, LC_CTYPE,\012    // LC_MONETARY, LC_NUMERIC, and LC_TIME. In addition, POSIX (IEEE\012    // 1003.1-2001) specifies LC_MESSAGES.\012    // In addition to the standard categories, the underlying\012    // operating system is allowed to define extra LC_*\012    // macros. For GNU systems, the following are also valid:\012    // LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT,\012    // and LC_IDENTIFICATION.\012    enum { _S_categories_size = 6 + _GLIBCXX_NUM_CATEGORIES };\012\012#ifdef __GTHREADS\012    static __gthread_once_t _S_once;\012#endif\012\012    explicit\012    locale(_Impl*) throw();\012\012    static void\012    _S_initialize();\012\012    static void\012    _S_initialize_once();\012\012    static category\012    _S_normalize_category(category);\012\012    void\012    _M_coalesce(const locale& __base, const locale& __add, category __cat);\012  };\012\012\012  // 22.1.1.1.2  Class locale::facet\012  /**\012   *  @brief  Localization functionality base class.\012   *\012   *  The facet class is the base class for a localization feature, such as\012   *  money, time, and number printing.  It provides common support for facets\012   *  and reference management.\012   *\012   *  Facets may not be copied or assigned.\012  */\012  class locale::facet\012  {\012  private:\012    friend class locale;\012    friend class locale::_Impl;\012\012    mutable _Atomic_word		_M_refcount;\012\012    // Contains data from the underlying \"C\" library for the classic locale.\012    static __c_locale                   _S_c_locale;\012\012    // String literal for the name of the classic locale.\012    static const char			_S_c_name[2];\012\012#ifdef __GTHREADS\012    static __gthread_once_t		_S_once;\012#endif\012\012    static void\012    _S_initialize_once();\012\012  protected:\012    /**\012     *  @brief  Facet constructor.\012     *\012     *  This is the constructor provided by the standard.  If refs is 0, the\012     *  facet is destroyed when the last referencing locale is destroyed.\012     *  Otherwise the facet will never be destroyed.\012     *\012     *  @param refs  The initial value for reference count.\012    */\012    explicit\012    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)\012    { }\012\012    /// Facet destructor.\012    virtual\012    ~facet();\012\012    static void\012    _S_create_c_locale(__c_locale& __cloc, const char* __s,\012		       __c_locale __old = 0);\012\012    static __c_locale\012    _S_clone_c_locale(__c_locale& __cloc);\012\012    static void\012    _S_destroy_c_locale(__c_locale& __cloc);\012\012    // Returns data from the underlying \"C\" library data for the\012    // classic locale.\012    static __c_locale\012    _S_get_c_locale();\012\012    static const char*\012    _S_get_c_name();\012\012  private:\012    void\012    _M_add_reference() const throw()\012    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\012\012    void\012    _M_remove_reference() const throw()\012    {\012      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)\012	{\012	  __try\012	    { delete this; }\012	  __catch(...)\012	    { }\012	}\012    }\012\012    facet(const facet&);  // Not defined.\012\012    facet&\012    operator=(const facet&);  // Not defined.\012  };\012\012\012  // 22.1.1.1.3 Class locale::id\012  /**\012   *  @brief  Facet ID class.\012   *\012   *  The ID class provides facets with an index used to identify them.\012   *  Every facet class must define a public static member locale::id, or be\012   *  derived from a facet that provides this member, otherwise the facet\012   *  cannot be used in a locale.  The locale::id ensures that each class\012   *  type gets a unique identifier.\012  */\012  class locale::id\012  {\012  private:\012    friend class locale;\012    friend class locale::_Impl;\012\012    template<typename _Facet>\012      friend const _Facet&\012      use_facet(const locale&);\012\012    template<typename _Facet>\012      friend bool\012      has_facet(const locale&) throw ();\012\012    // NB: There is no accessor for _M_index because it may be used\012    // before the constructor is run; the effect of calling a member\012    // function (even an inline) would be undefined.\012    mutable size_t		_M_index;\012\012    // Last id number assigned.\012    static _Atomic_word		_S_refcount;\012\012    void\012    operator=(const id&);  // Not defined.\012\012    id(const id&);  // Not defined.\012\012  public:\012    // NB: This class is always a static data member, and thus can be\012    // counted on to be zero-initialized.\012    /// Constructor.\012    id() { }\012\012    size_t\012    _M_id() const;\012  };\012\012\012  // Implementation object for locale.\012  class locale::_Impl\012  {\012  public:\012    // Friends.\012    friend class locale;\012    friend class locale::facet;\012\012    template<typename _Facet>\012      friend bool\012      has_facet(const locale&) throw();\012\012    template<typename _Facet>\012      friend const _Facet&\012      use_facet(const locale&);\012\012    template<typename _Cache>\012      friend struct __use_cache;\012\012  private:\012    // Data Members.\012    _Atomic_word			_M_refcount;\012    const facet**			_M_facets;\012    size_t				_M_facets_size;\012    const facet**			_M_caches;\012    char**				_M_names;\012    static const locale::id* const	_S_id_ctype[];\012    static const locale::id* const	_S_id_numeric[];\012    static const locale::id* const	_S_id_collate[];\012    static const locale::id* const	_S_id_time[];\012    static const locale::id* const	_S_id_monetary[];\012    static const locale::id* const	_S_id_messages[];\012    static const locale::id* const* const _S_facet_categories[];\012\012    void\012    _M_add_reference() throw()\012    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\012\012    void\012    _M_remove_reference() throw()\012    {\012      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)\012	{\012	  __try\012	    { delete this; }\012	  __catch(...)\012	    { }\012	}\012    }\012\012    _Impl(const _Impl&, size_t);\012    _Impl(const char*, size_t);\012    _Impl(size_t) throw();\012\012   ~_Impl() throw();\012\012    _Impl(const _Impl&);  // Not defined.\012\012    void\012    operator=(const _Impl&);  // Not defined.\012\012    bool\012    _M_check_same_name()\012    {\012      bool __ret = true;\012      if (_M_names[1])\012	// We must actually compare all the _M_names: can be all equal!\012	for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)\012	  __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;\012      return __ret;\012    }\012\012    void\012    _M_replace_categories(const _Impl*, category);\012\012    void\012    _M_replace_category(const _Impl*, const locale::id* const*);\012\012    void\012    _M_replace_facet(const _Impl*, const locale::id*);\012\012    void\012    _M_install_facet(const locale::id*, const facet*);\012\012    template<typename _Facet>\012      void\012      _M_init_facet(_Facet* __facet)\012      { _M_install_facet(&_Facet::id, __facet); }\012\012    void\012    _M_install_cache(const facet*, size_t);\012  };\012\012\012  /**\012   *  @brief  Test for the presence of a facet.\012   *\012   *  has_facet tests the locale argument for the presence of the facet type\012   *  provided as the template parameter.  Facets derived from the facet\012   *  parameter will also return true.\012   *\012   *  @param  Facet  The facet type to test the presence of.\012   *  @param  locale  The locale to test.\012   *  @return  true if locale contains a facet of type Facet, else false.\012  */\012  template<typename _Facet>\012    bool\012    has_facet(const locale& __loc) throw();\012\012  /**\012   *  @brief  Return a facet.\012   *\012   *  use_facet looks for and returns a reference to a facet of type Facet\012   *  where Facet is the template parameter.  If has_facet(locale) is true,\012   *  there is a suitable facet to return.  It throws std::bad_cast if the\012   *  locale doesn't contain a facet of type Facet.\012   *\012   *  @param  Facet  The facet type to access.\012   *  @param  locale  The locale to use.\012   *  @return  Reference to facet of type Facet.\012   *  @throw  std::bad_cast if locale doesn't contain a facet of type Facet.\012  */\012  template<typename _Facet>\012    const _Facet&\012    use_facet(const locale& __loc);\012\012\012  /**\012   *  @brief  Facet for localized string comparison.\012   *\012   *  This facet encapsulates the code to compare strings in a localized\012   *  manner.\012   *\012   *  The collate template uses protected virtual functions to provide\012   *  the actual results.  The public accessors forward the call to\012   *  the virtual functions.  These virtual functions are hooks for\012   *  developers to implement the behavior they require from the\012   *  collate facet.\012  */\012  template<typename _CharT>\012    class collate : public locale::facet\012    {\012    public:\012      // Types:\012      //@{\012      /// Public typedefs\012      typedef _CharT			char_type;\012      typedef basic_string<_CharT>	string_type;\012      //@}\012\012    protected:\012      // Underlying \"C\" library locale information saved from\012      // initialization, needed by collate_byname as well.\012      __c_locale			_M_c_locale_collate;\012\012    public:\012      /// Numpunct facet id.\012      static locale::id			id;\012\012      /**\012       *  @brief  Constructor performs initialization.\012       *\012       *  This is the constructor provided by the standard.\012       *\012       *  @param refs  Passed to the base facet class.\012      */\012      explicit\012      collate(size_t __refs = 0)\012      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())\012      { }\012\012      /**\012       *  @brief  Internal constructor. Not for general use.\012       *\012       *  This is a constructor for use by the library itself to set up new\012       *  locales.\012       *\012       *  @param cloc  The \"C\" locale.\012       *  @param refs  Passed to the base facet class.\012      */\012      explicit\012      collate(__c_locale __cloc, size_t __refs = 0)\012      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))\012      { }\012\012      /**\012       *  @brief  Compare two strings.\012       *\012       *  This function compares two strings and returns the result by calling\012       *  collate::do_compare().\012       *\012       *  @param lo1  Start of string 1.\012       *  @param hi1  End of string 1.\012       *  @param lo2  Start of string 2.\012       *  @param hi2  End of string 2.\012       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\012      */\012      int\012      compare(const _CharT* __lo1, const _CharT* __hi1,\012	      const _CharT* __lo2, const _CharT* __hi2) const\012      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }\012\012      /**\012       *  @brief  Transform string to comparable form.\012       *\012       *  This function is a wrapper for strxfrm functionality.  It takes the\012       *  input string and returns a modified string that can be directly\012       *  compared to other transformed strings.  In the \"C\" locale, this\012       *  function just returns a copy of the input string.  In some other\012       *  locales, it may replace two chars with one, change a char for\012       *  another, etc.  It does so by returning collate::do_transform().\012       *\012       *  @param lo  Start of string.\012       *  @param hi  End of string.\012       *  @return  Transformed string_type.\012      */\012      string_type\012      transform(const _CharT* __lo, const _CharT* __hi) const\012      { return this->do_transform(__lo, __hi); }\012\012      /**\012       *  @brief  Return hash of a string.\012       *\012       *  This function computes and returns a hash on the input string.  It\012       *  does so by returning collate::do_hash().\012       *\012       *  @param lo  Start of string.\012       *  @param hi  End of string.\012       *  @return  Hash value.\012      */\012      long\012      hash(const _CharT* __lo, const _CharT* __hi) const\012      { return this->do_hash(__lo, __hi); }\012\012      // Used to abstract out _CharT bits in virtual member functions, below.\012      int\012      _M_compare(const _CharT*, const _CharT*) const;\012\012      size_t\012      _M_transform(_CharT*, const _CharT*, size_t) const;\012\012  protected:\012      /// Destructor.\012      virtual\012      ~collate()\012      { _S_destroy_c_locale(_M_c_locale_collate); }\012\012      /**\012       *  @brief  Compare two strings.\012       *\012       *  This function is a hook for derived classes to change the value\012       *  returned.  @see compare().\012       *\012       *  @param lo1  Start of string 1.\012       *  @param hi1  End of string 1.\012       *  @param lo2  Start of string 2.\012       *  @param hi2  End of string 2.\012       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\012      */\012      virtual int\012      do_compare(const _CharT* __lo1, const _CharT* __hi1,\012		 const _CharT* __lo2, const _CharT* __hi2) const;\012\012      /**\012       *  @brief  Transform string to comparable form.\012       *\012       *  This function is a hook for derived classes to change the value\012       *  returned.\012       *\012       *  @param lo1  Start of string 1.\012       *  @param hi1  End of string 1.\012       *  @param lo2  Start of string 2.\012       *  @param hi2  End of string 2.\012       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.\012      */\012      virtual string_type\012      do_transform(const _CharT* __lo, const _CharT* __hi) const;\012\012      /**\012       *  @brief  Return hash of a string.\012       *\012       *  This function computes and returns a hash on the input string.  This\012       *  function is a hook for derived classes to change the value returned.\012       *\012       *  @param lo  Start of string.\012       *  @param hi  End of string.\012       *  @return  Hash value.\012      */\012      virtual long\012      do_hash(const _CharT* __lo, const _CharT* __hi) const;\012    };\012\012  template<typename _CharT>\012    locale::id collate<_CharT>::id;\012\012  // Specializations.\012  template<>\012    int\012    collate<char>::_M_compare(const char*, const char*) const;\012\012  template<>\012    size_t\012    collate<char>::_M_transform(char*, const char*, size_t) const;\012\012#ifdef _GLIBCXX_USE_WCHAR_T\012  template<>\012    int\012    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;\012\012  template<>\012    size_t\012    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;\012#endif\012\012  /// class collate_byname [22.2.4.2].\012  template<typename _CharT>\012    class collate_byname : public collate<_CharT>\012    {\012    public:\012      //@{\012      /// Public typedefs\012      typedef _CharT               char_type;\012      typedef basic_string<_CharT> string_type;\012      //@}\012\012      explicit\012      collate_byname(const char* __s, size_t __refs = 0)\012      : collate<_CharT>(__refs)\012      {\012	if (__builtin_strcmp(__s, \"C\") != 0\012	    && __builtin_strcmp(__s, \"POSIX\") != 0)\012	  {\012	    this->_S_destroy_c_locale(this->_M_c_locale_collate);\012	    this->_S_create_c_locale(this->_M_c_locale_collate, __s);\012	  }\012      }\012\012    protected:\012      virtual\012      ~collate_byname() { }\012    };\012\012_GLIBCXX_END_NAMESPACE\012\012#ifndef _GLIBCXX_EXPORT_TEMPLATE\012# include <bits/locale_classes.tcc>\012#endif\012\012#endif\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ext/new_allocator.h", "name":"new_allocator.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/ext/new_allocator.h", "content":"// Allocator that wraps operator new -*- C++ -*-\012\012// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file ext/new_allocator.h\012 *  This file is a GNU extension to the Standard C++ Library.\012 */\012\012#ifndef _NEW_ALLOCATOR_H\012#define _NEW_ALLOCATOR_H 1\012\012#include <new>\012#include <bits/functexcept.h>\012#include <bits/move.h>\012\012_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\012\012  using std::size_t;\012  using std::ptrdiff_t;\012\012  /**\012   *  @brief  An allocator that uses global new, as per [20.4].\012   *  @ingroup allocators\012   *\012   *  This is precisely the allocator defined in the C++ Standard. \012   *    - all allocation calls operator new\012   *    - all deallocation calls operator delete\012   */\012  template<typename _Tp>\012    class new_allocator\012    {\012    public:\012      typedef size_t     size_type;\012      typedef ptrdiff_t  difference_type;\012      typedef _Tp*       pointer;\012      typedef const _Tp* const_pointer;\012      typedef _Tp&       reference;\012      typedef const _Tp& const_reference;\012      typedef _Tp        value_type;\012\012      template<typename _Tp1>\012        struct rebind\012        { typedef new_allocator<_Tp1> other; };\012\012      new_allocator() throw() { }\012\012      new_allocator(const new_allocator&) throw() { }\012\012      template<typename _Tp1>\012        new_allocator(const new_allocator<_Tp1>&) throw() { }\012\012      ~new_allocator() throw() { }\012\012      pointer\012      address(reference __x) const { return &__x; }\012\012      const_pointer\012      address(const_reference __x) const { return &__x; }\012\012      // NB: __n is permitted to be 0.  The C++ standard says nothing\012      // about what the return value is when __n == 0.\012      pointer\012      allocate(size_type __n, const void* = 0)\012      { \012	if (__builtin_expect(__n > this->max_size(), false))\012	  std::__throw_bad_alloc();\012\012	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));\012      }\012\012      // __p is not permitted to be a null pointer.\012      void\012      deallocate(pointer __p, size_type)\012      { ::operator delete(__p); }\012\012      size_type\012      max_size() const throw() \012      { return size_t(-1) / sizeof(_Tp); }\012\012      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012      // 402. wrong new expression in [some_] allocator::construct\012      void \012      construct(pointer __p, const _Tp& __val) \012      { ::new((void *)__p) _Tp(__val); }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      template<typename... _Args>\012        void\012        construct(pointer __p, _Args&&... __args)\012	{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }\012#endif\012\012      void \012      destroy(pointer __p) { __p->~_Tp(); }\012    };\012\012  template<typename _Tp>\012    inline bool\012    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)\012    { return true; }\012  \012  template<typename _Tp>\012    inline bool\012    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)\012    { return false; }\012\012_GLIBCXX_END_NAMESPACE\012\012#endif\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/postypes.h", "name":"postypes.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/postypes.h", "content":"// Position types -*- C++ -*-\012\012// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\012// 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file postypes.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012//\012// ISO C++ 14882: 27.4.1 - Types\012// ISO C++ 14882: 27.4.3 - Template class fpos\012//\012\012#ifndef _GLIBCXX_POSTYPES_H\012#define _GLIBCXX_POSTYPES_H 1\012\012#pragma GCC system_header\012\012#include <cwchar> // For mbstate_t\012\012// XXX If <stdint.h> is really needed, make sure to define the macros\012// before including it, in order not to break <tr1/cstdint> (and <cstdint>\012// in C++0x).  Reconsider all this as soon as possible...\012#if (defined(_GLIBCXX_HAVE_INT64_T) && !defined(_GLIBCXX_HAVE_INT64_T_LONG) \\\012     && !defined(_GLIBCXX_HAVE_INT64_T_LONG_LONG))\012\012#ifndef __STDC_LIMIT_MACROS\012# define _UNDEF__STDC_LIMIT_MACROS\012# define __STDC_LIMIT_MACROS\012#endif\012#ifndef __STDC_CONSTANT_MACROS\012# define _UNDEF__STDC_CONSTANT_MACROS\012# define __STDC_CONSTANT_MACROS\012#endif\012#include <stdint.h> // For int64_t\012#ifdef _UNDEF__STDC_LIMIT_MACROS\012# undef __STDC_LIMIT_MACROS\012# undef _UNDEF__STDC_LIMIT_MACROS\012#endif\012#ifdef _UNDEF__STDC_CONSTANT_MACROS\012# undef __STDC_CONSTANT_MACROS\012# undef _UNDEF__STDC_CONSTANT_MACROS\012#endif\012\012#endif\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  // The types streamoff, streampos and wstreampos and the class\012  // template fpos<> are described in clauses 21.1.2, 21.1.3, 27.1.2,\012  // 27.2, 27.4.1, 27.4.3 and D.6. Despite all this verbiage, the\012  // behaviour of these types is mostly implementation defined or\012  // unspecified. The behaviour in this implementation is as noted\012  // below.\012\012  /**\012   *  @brief  Type used by fpos, char_traits<char>, and char_traits<wchar_t>.\012   *\012   *  In clauses 21.1.3.1 and 27.4.1 streamoff is described as an\012   *  implementation defined type.\012   *  Note: In versions of GCC up to and including GCC 3.3, streamoff\012   *  was typedef long.\012  */  \012#ifdef _GLIBCXX_HAVE_INT64_T_LONG\012  typedef long          streamoff;\012#elif defined(_GLIBCXX_HAVE_INT64_T_LONG_LONG)\012  typedef long long     streamoff;\012#elif defined(_GLIBCXX_HAVE_INT64_T) \012  typedef int64_t       streamoff;\012#else\012  typedef long long     streamoff;\012#endif\012\012  /// Integral type for I/O operation counts and buffer sizes.\012  typedef ptrdiff_t	streamsize; // Signed integral type\012\012  /**\012   *  @brief  Class representing stream positions.\012   *\012   *  The standard places no requirements upon the template parameter StateT.\012   *  In this implementation StateT must be DefaultConstructible,\012   *  CopyConstructible and Assignable.  The standard only requires that fpos\012   *  should contain a member of type StateT. In this implementation it also\012   *  contains an offset stored as a signed integer.\012   *\012   *  @param  StateT  Type passed to and returned from state().\012   */\012  template<typename _StateT>\012    class fpos\012    {\012    private:\012      streamoff	                _M_off;\012      _StateT			_M_state;\012\012    public:\012      // The standard doesn't require that fpos objects can be default\012      // constructed. This implementation provides a default\012      // constructor that initializes the offset to 0 and default\012      // constructs the state.\012      fpos()\012      : _M_off(0), _M_state() { }\012\012      // The standard requires that fpos objects can be constructed\012      // from streamoff objects using the constructor syntax, and\012      // fails to give any meaningful semantics. In this\012      // implementation implicit conversion is also allowed, and this\012      // constructor stores the streamoff as the offset and default\012      // constructs the state.\012      /// Construct position from offset.\012      fpos(streamoff __off)\012      : _M_off(__off), _M_state() { }\012\012      /// Convert to streamoff.\012      operator streamoff() const { return _M_off; }\012\012      /// Remember the value of @a st.\012      void\012      state(_StateT __st)\012      { _M_state = __st; }\012\012      /// Return the last set value of @a st.\012      _StateT\012      state() const\012      { return _M_state; }\012\012      // The standard requires that this operator must be defined, but\012      // gives no semantics. In this implementation it just adds its\012      // argument to the stored offset and returns *this.\012      /// Add offset to this position.\012      fpos&\012      operator+=(streamoff __off)\012      {\012	_M_off += __off;\012	return *this;\012      }\012\012      // The standard requires that this operator must be defined, but\012      // gives no semantics. In this implementation it just subtracts\012      // its argument from the stored offset and returns *this.\012      /// Subtract offset from this position.\012      fpos&\012      operator-=(streamoff __off)\012      {\012	_M_off -= __off;\012	return *this;\012      }\012\012      // The standard requires that this operator must be defined, but\012      // defines its semantics only in terms of operator-. In this\012      // implementation it constructs a copy of *this, adds the\012      // argument to that copy using operator+= and then returns the\012      // copy.\012      /// Add position and offset.\012      fpos\012      operator+(streamoff __off) const\012      {\012	fpos __pos(*this);\012	__pos += __off;\012	return __pos;\012      }\012\012      // The standard requires that this operator must be defined, but\012      // defines its semantics only in terms of operator+. In this\012      // implementation it constructs a copy of *this, subtracts the\012      // argument from that copy using operator-= and then returns the\012      // copy.\012      /// Subtract offset from position.\012      fpos\012      operator-(streamoff __off) const\012      {\012	fpos __pos(*this);\012	__pos -= __off;\012	return __pos;\012      }\012\012      // The standard requires that this operator must be defined, but\012      // defines its semantics only in terms of operator+. In this\012      // implementation it returns the difference between the offset\012      // stored in *this and in the argument.\012      /// Subtract position to return offset.\012      streamoff\012      operator-(const fpos& __other) const\012      { return _M_off - __other._M_off; }\012    };\012\012  // The standard only requires that operator== must be an\012  // equivalence relation. In this implementation two fpos<StateT>\012  // objects belong to the same equivalence class if the contained\012  // offsets compare equal.\012  /// Test if equivalent to another position.\012  template<typename _StateT>\012    inline bool\012    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)\012    { return streamoff(__lhs) == streamoff(__rhs); }\012\012  template<typename _StateT>\012    inline bool\012    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)\012    { return streamoff(__lhs) != streamoff(__rhs); }\012\012  // Clauses 21.1.3.1 and 21.1.3.2 describe streampos and wstreampos\012  // as implementation defined types, but clause 27.2 requires that\012  // they must both be typedefs for fpos<mbstate_t>\012  /// File position for char streams.\012  typedef fpos<mbstate_t> streampos;\012  /// File position for wchar_t streams.\012  typedef fpos<mbstate_t> wstreampos;\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012  /// File position for char16_t streams.\012  typedef fpos<mbstate_t> u16streampos;\012  /// File position for char32_t streams.\012  typedef fpos<mbstate_t> u32streampos;\012#endif\012\012_GLIBCXX_END_NAMESPACE\012\012#endif\012"}, {"path":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/stdio.h", "name":"stdio.h", "has_active_debug_locs":false, "absName":"/home/monstrinho/opt/intelFPGA/18.1/hls/include/HLS/stdio.h", "content":"#ifndef __HLS_STDIO_H__\012#define __HLS_STDIO_H__\012\012#ifndef _STDIO_H\012#include <stdio.h>\012#endif\012\012#ifdef HLS_SYNTHESIS\012// Suppress if used in component\012# define printf(...) \012\012#endif //HLS_SYNTHESIS\012#endif //__HLS_STDIO_H__\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_iterator.h", "name":"stl_iterator.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/stl_iterator.h", "content":"// Iterators -*- C++ -*-\012\012// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/*\012 *\012 * Copyright (c) 1994\012 * Hewlett-Packard Company\012 *\012 * Permission to use, copy, modify, distribute and sell this software\012 * and its documentation for any purpose is hereby granted without fee,\012 * provided that the above copyright notice appear in all copies and\012 * that both that copyright notice and this permission notice appear\012 * in supporting documentation.  Hewlett-Packard Company makes no\012 * representations about the suitability of this software for any\012 * purpose.  It is provided \"as is\" without express or implied warranty.\012 *\012 *\012 * Copyright (c) 1996-1998\012 * Silicon Graphics Computer Systems, Inc.\012 *\012 * Permission to use, copy, modify, distribute and sell this software\012 * and its documentation for any purpose is hereby granted without fee,\012 * provided that the above copyright notice appear in all copies and\012 * that both that copyright notice and this permission notice appear\012 * in supporting documentation.  Silicon Graphics makes no\012 * representations about the suitability of this software for any\012 * purpose.  It is provided \"as is\" without express or implied warranty.\012 */\012\012/** @file stl_iterator.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 *\012 *  This file implements reverse_iterator, back_insert_iterator,\012 *  front_insert_iterator, insert_iterator, __normal_iterator, and their\012 *  supporting functions and overloaded operators.\012 */\012\012#ifndef _STL_ITERATOR_H\012#define _STL_ITERATOR_H 1\012\012#include <bits/cpp_type_traits.h>\012#include <ext/type_traits.h>\012#include <bits/move.h>\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  // 24.4.1 Reverse iterators\012  /**\012   *  \"Bidirectional and random access iterators have corresponding reverse\012   *  %iterator adaptors that iterate through the data structure in the\012   *  opposite direction.  They have the same signatures as the corresponding\012   *  iterators.  The fundamental relation between a reverse %iterator and its\012   *  corresponding %iterator @c i is established by the identity:\012   *  @code\012   *      &*(reverse_iterator(i)) == &*(i - 1)\012   *  @endcode\012   *\012   *  This mapping is dictated by the fact that while there is always a\012   *  pointer past the end of an array, there might not be a valid pointer\012   *  before the beginning of an array.\" [24.4.1]/1,2\012   *\012   *  Reverse iterators can be tricky and surprising at first.  Their\012   *  semantics make sense, however, and the trickiness is a side effect of\012   *  the requirement that the iterators must be safe.\012  */\012  template<typename _Iterator>\012    class reverse_iterator\012    : public iterator<typename iterator_traits<_Iterator>::iterator_category,\012		      typename iterator_traits<_Iterator>::value_type,\012		      typename iterator_traits<_Iterator>::difference_type,\012		      typename iterator_traits<_Iterator>::pointer,\012                      typename iterator_traits<_Iterator>::reference>\012    {\012    protected:\012      _Iterator current;\012\012    public:\012      typedef _Iterator					       iterator_type;\012      typedef typename iterator_traits<_Iterator>::difference_type\012							       difference_type;\012      typedef typename iterator_traits<_Iterator>::reference   reference;\012      typedef typename iterator_traits<_Iterator>::pointer     pointer;\012\012    public:\012      /**\012       *  The default constructor default-initializes member @p current.\012       *  If it is a pointer, that means it is zero-initialized.\012      */\012      // _GLIBCXX_RESOLVE_LIB_DEFECTS\012      // 235 No specification of default ctor for reverse_iterator\012      reverse_iterator() : current() { }\012\012      /**\012       *  This %iterator will move in the opposite direction that @p x does.\012      */\012      explicit\012      reverse_iterator(iterator_type __x) : current(__x) { }\012\012      /**\012       *  The copy constructor is normal.\012      */\012      reverse_iterator(const reverse_iterator& __x)\012      : current(__x.current) { }\012\012      /**\012       *  A reverse_iterator across other types can be copied in the normal\012       *  fashion.\012      */\012      template<typename _Iter>\012        reverse_iterator(const reverse_iterator<_Iter>& __x)\012	: current(__x.base()) { }\012\012      /**\012       *  @return  @c current, the %iterator used for underlying work.\012      */\012      iterator_type\012      base() const\012      { return current; }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reference\012      operator*() const\012      {\012	_Iterator __tmp = current;\012	return *--__tmp;\012      }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      pointer\012      operator->() const\012      { return &(operator*()); }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reverse_iterator&\012      operator++()\012      {\012	--current;\012	return *this;\012      }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reverse_iterator\012      operator++(int)\012      {\012	reverse_iterator __tmp = *this;\012	--current;\012	return __tmp;\012      }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reverse_iterator&\012      operator--()\012      {\012	++current;\012	return *this;\012      }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reverse_iterator\012      operator--(int)\012      {\012	reverse_iterator __tmp = *this;\012	++current;\012	return __tmp;\012      }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reverse_iterator\012      operator+(difference_type __n) const\012      { return reverse_iterator(current - __n); }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reverse_iterator&\012      operator+=(difference_type __n)\012      {\012	current -= __n;\012	return *this;\012      }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reverse_iterator\012      operator-(difference_type __n) const\012      { return reverse_iterator(current + __n); }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reverse_iterator&\012      operator-=(difference_type __n)\012      {\012	current += __n;\012	return *this;\012      }\012\012      /**\012       *  @return  TODO\012       *\012       *  @doctodo\012      */\012      reference\012      operator[](difference_type __n) const\012      { return *(*this + __n); }\012    };\012\012  //@{\012  /**\012   *  @param  x  A %reverse_iterator.\012   *  @param  y  A %reverse_iterator.\012   *  @return  A simple bool.\012   *\012   *  Reverse iterators forward many operations to their underlying base()\012   *  iterators.  Others are implemented in terms of one another.\012   *\012  */\012  template<typename _Iterator>\012    inline bool\012    operator==(const reverse_iterator<_Iterator>& __x,\012	       const reverse_iterator<_Iterator>& __y)\012    { return __x.base() == __y.base(); }\012\012  template<typename _Iterator>\012    inline bool\012    operator<(const reverse_iterator<_Iterator>& __x,\012	      const reverse_iterator<_Iterator>& __y)\012    { return __y.base() < __x.base(); }\012\012  template<typename _Iterator>\012    inline bool\012    operator!=(const reverse_iterator<_Iterator>& __x,\012	       const reverse_iterator<_Iterator>& __y)\012    { return !(__x == __y); }\012\012  template<typename _Iterator>\012    inline bool\012    operator>(const reverse_iterator<_Iterator>& __x,\012	      const reverse_iterator<_Iterator>& __y)\012    { return __y < __x; }\012\012  template<typename _Iterator>\012    inline bool\012    operator<=(const reverse_iterator<_Iterator>& __x,\012	       const reverse_iterator<_Iterator>& __y)\012    { return !(__y < __x); }\012\012  template<typename _Iterator>\012    inline bool\012    operator>=(const reverse_iterator<_Iterator>& __x,\012	       const reverse_iterator<_Iterator>& __y)\012    { return !(__x < __y); }\012\012  template<typename _Iterator>\012    inline typename reverse_iterator<_Iterator>::difference_type\012    operator-(const reverse_iterator<_Iterator>& __x,\012	      const reverse_iterator<_Iterator>& __y)\012    { return __y.base() - __x.base(); }\012\012  template<typename _Iterator>\012    inline reverse_iterator<_Iterator>\012    operator+(typename reverse_iterator<_Iterator>::difference_type __n,\012	      const reverse_iterator<_Iterator>& __x)\012    { return reverse_iterator<_Iterator>(__x.base() - __n); }\012\012  // _GLIBCXX_RESOLVE_LIB_DEFECTS\012  // DR 280. Comparison of reverse_iterator to const reverse_iterator.\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator==(const reverse_iterator<_IteratorL>& __x,\012	       const reverse_iterator<_IteratorR>& __y)\012    { return __x.base() == __y.base(); }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator<(const reverse_iterator<_IteratorL>& __x,\012	      const reverse_iterator<_IteratorR>& __y)\012    { return __y.base() < __x.base(); }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator!=(const reverse_iterator<_IteratorL>& __x,\012	       const reverse_iterator<_IteratorR>& __y)\012    { return !(__x == __y); }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator>(const reverse_iterator<_IteratorL>& __x,\012	      const reverse_iterator<_IteratorR>& __y)\012    { return __y < __x; }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator<=(const reverse_iterator<_IteratorL>& __x,\012	       const reverse_iterator<_IteratorR>& __y)\012    { return !(__y < __x); }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator>=(const reverse_iterator<_IteratorL>& __x,\012	       const reverse_iterator<_IteratorR>& __y)\012    { return !(__x < __y); }\012\012  template<typename _IteratorL, typename _IteratorR>\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012    // DR 685.\012    inline auto\012    operator-(const reverse_iterator<_IteratorL>& __x,\012	      const reverse_iterator<_IteratorR>& __y)\012    -> decltype(__y.base() - __x.base())\012#else\012    inline typename reverse_iterator<_IteratorL>::difference_type\012    operator-(const reverse_iterator<_IteratorL>& __x,\012	      const reverse_iterator<_IteratorR>& __y)\012#endif\012    { return __y.base() - __x.base(); }\012  //@}\012\012  // 24.4.2.2.1 back_insert_iterator\012  /**\012   *  @brief  Turns assignment into insertion.\012   *\012   *  These are output iterators, constructed from a container-of-T.\012   *  Assigning a T to the iterator appends it to the container using\012   *  push_back.\012   *\012   *  Tip:  Using the back_inserter function to create these iterators can\012   *  save typing.\012  */\012  template<typename _Container>\012    class back_insert_iterator\012    : public iterator<output_iterator_tag, void, void, void, void>\012    {\012    protected:\012      _Container* container;\012\012    public:\012      /// A nested typedef for the type of whatever container you used.\012      typedef _Container          container_type;\012\012      /// The only way to create this %iterator is with a container.\012      explicit\012      back_insert_iterator(_Container& __x) : container(&__x) { }\012\012      /**\012       *  @param  value  An instance of whatever type\012       *                 container_type::const_reference is; presumably a\012       *                 reference-to-const T for container<T>.\012       *  @return  This %iterator, for chained operations.\012       *\012       *  This kind of %iterator doesn't really have a \"position\" in the\012       *  container (you can think of the position as being permanently at\012       *  the end, if you like).  Assigning a value to the %iterator will\012       *  always append the value to the end of the container.\012      */\012      back_insert_iterator&\012      operator=(typename _Container::const_reference __value)\012      {\012	container->push_back(__value);\012	return *this;\012      }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      back_insert_iterator&\012      operator=(typename _Container::value_type&& __value)\012      {\012	container->push_back(std::move(__value));\012	return *this;\012      }\012#endif\012\012      /// Simply returns *this.\012      back_insert_iterator&\012      operator*()\012      { return *this; }\012\012      /// Simply returns *this.  (This %iterator does not \"move\".)\012      back_insert_iterator&\012      operator++()\012      { return *this; }\012\012      /// Simply returns *this.  (This %iterator does not \"move\".)\012      back_insert_iterator\012      operator++(int)\012      { return *this; }\012    };\012\012  /**\012   *  @param  x  A container of arbitrary type.\012   *  @return  An instance of back_insert_iterator working on @p x.\012   *\012   *  This wrapper function helps in creating back_insert_iterator instances.\012   *  Typing the name of the %iterator requires knowing the precise full\012   *  type of the container, which can be tedious and impedes generic\012   *  programming.  Using this function lets you take advantage of automatic\012   *  template parameter deduction, making the compiler match the correct\012   *  types for you.\012  */\012  template<typename _Container>\012    inline back_insert_iterator<_Container>\012    back_inserter(_Container& __x)\012    { return back_insert_iterator<_Container>(__x); }\012\012  /**\012   *  @brief  Turns assignment into insertion.\012   *\012   *  These are output iterators, constructed from a container-of-T.\012   *  Assigning a T to the iterator prepends it to the container using\012   *  push_front.\012   *\012   *  Tip:  Using the front_inserter function to create these iterators can\012   *  save typing.\012  */\012  template<typename _Container>\012    class front_insert_iterator\012    : public iterator<output_iterator_tag, void, void, void, void>\012    {\012    protected:\012      _Container* container;\012\012    public:\012      /// A nested typedef for the type of whatever container you used.\012      typedef _Container          container_type;\012\012      /// The only way to create this %iterator is with a container.\012      explicit front_insert_iterator(_Container& __x) : container(&__x) { }\012\012      /**\012       *  @param  value  An instance of whatever type\012       *                 container_type::const_reference is; presumably a\012       *                 reference-to-const T for container<T>.\012       *  @return  This %iterator, for chained operations.\012       *\012       *  This kind of %iterator doesn't really have a \"position\" in the\012       *  container (you can think of the position as being permanently at\012       *  the front, if you like).  Assigning a value to the %iterator will\012       *  always prepend the value to the front of the container.\012      */\012      front_insert_iterator&\012      operator=(typename _Container::const_reference __value)\012      {\012	container->push_front(__value);\012	return *this;\012      }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      front_insert_iterator&\012      operator=(typename _Container::value_type&& __value)\012      {\012	container->push_front(std::move(__value));\012	return *this;\012      }\012#endif\012\012      /// Simply returns *this.\012      front_insert_iterator&\012      operator*()\012      { return *this; }\012\012      /// Simply returns *this.  (This %iterator does not \"move\".)\012      front_insert_iterator&\012      operator++()\012      { return *this; }\012\012      /// Simply returns *this.  (This %iterator does not \"move\".)\012      front_insert_iterator\012      operator++(int)\012      { return *this; }\012    };\012\012  /**\012   *  @param  x  A container of arbitrary type.\012   *  @return  An instance of front_insert_iterator working on @p x.\012   *\012   *  This wrapper function helps in creating front_insert_iterator instances.\012   *  Typing the name of the %iterator requires knowing the precise full\012   *  type of the container, which can be tedious and impedes generic\012   *  programming.  Using this function lets you take advantage of automatic\012   *  template parameter deduction, making the compiler match the correct\012   *  types for you.\012  */\012  template<typename _Container>\012    inline front_insert_iterator<_Container>\012    front_inserter(_Container& __x)\012    { return front_insert_iterator<_Container>(__x); }\012\012  /**\012   *  @brief  Turns assignment into insertion.\012   *\012   *  These are output iterators, constructed from a container-of-T.\012   *  Assigning a T to the iterator inserts it in the container at the\012   *  %iterator's position, rather than overwriting the value at that\012   *  position.\012   *\012   *  (Sequences will actually insert a @e copy of the value before the\012   *  %iterator's position.)\012   *\012   *  Tip:  Using the inserter function to create these iterators can\012   *  save typing.\012  */\012  template<typename _Container>\012    class insert_iterator\012    : public iterator<output_iterator_tag, void, void, void, void>\012    {\012    protected:\012      _Container* container;\012      typename _Container::iterator iter;\012\012    public:\012      /// A nested typedef for the type of whatever container you used.\012      typedef _Container          container_type;\012\012      /**\012       *  The only way to create this %iterator is with a container and an\012       *  initial position (a normal %iterator into the container).\012      */\012      insert_iterator(_Container& __x, typename _Container::iterator __i)\012      : container(&__x), iter(__i) {}\012\012      /**\012       *  @param  value  An instance of whatever type\012       *                 container_type::const_reference is; presumably a\012       *                 reference-to-const T for container<T>.\012       *  @return  This %iterator, for chained operations.\012       *\012       *  This kind of %iterator maintains its own position in the\012       *  container.  Assigning a value to the %iterator will insert the\012       *  value into the container at the place before the %iterator.\012       *\012       *  The position is maintained such that subsequent assignments will\012       *  insert values immediately after one another.  For example,\012       *  @code\012       *     // vector v contains A and Z\012       *\012       *     insert_iterator i (v, ++v.begin());\012       *     i = 1;\012       *     i = 2;\012       *     i = 3;\012       *\012       *     // vector v contains A, 1, 2, 3, and Z\012       *  @endcode\012      */\012      insert_iterator&\012      operator=(typename _Container::const_reference __value)\012      {\012	iter = container->insert(iter, __value);\012	++iter;\012	return *this;\012      }\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012      insert_iterator&\012      operator=(typename _Container::value_type&& __value)\012      {\012	iter = container->insert(iter, std::move(__value));\012	++iter;\012	return *this;\012      }\012#endif\012\012      /// Simply returns *this.\012      insert_iterator&\012      operator*()\012      { return *this; }\012\012      /// Simply returns *this.  (This %iterator does not \"move\".)\012      insert_iterator&\012      operator++()\012      { return *this; }\012\012      /// Simply returns *this.  (This %iterator does not \"move\".)\012      insert_iterator&\012      operator++(int)\012      { return *this; }\012    };\012\012  /**\012   *  @param  x  A container of arbitrary type.\012   *  @return  An instance of insert_iterator working on @p x.\012   *\012   *  This wrapper function helps in creating insert_iterator instances.\012   *  Typing the name of the %iterator requires knowing the precise full\012   *  type of the container, which can be tedious and impedes generic\012   *  programming.  Using this function lets you take advantage of automatic\012   *  template parameter deduction, making the compiler match the correct\012   *  types for you.\012  */\012  template<typename _Container, typename _Iterator>\012    inline insert_iterator<_Container>\012    inserter(_Container& __x, _Iterator __i)\012    {\012      return insert_iterator<_Container>(__x,\012					 typename _Container::iterator(__i));\012    }\012\012_GLIBCXX_END_NAMESPACE\012\012_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\012\012  // This iterator adapter is 'normal' in the sense that it does not\012  // change the semantics of any of the operators of its iterator\012  // parameter.  Its primary purpose is to convert an iterator that is\012  // not a class, e.g. a pointer, into an iterator that is a class.\012  // The _Container parameter exists solely so that different containers\012  // using this template can instantiate different types, even if the\012  // _Iterator parameter is the same.\012  using std::iterator_traits;\012  using std::iterator;\012  template<typename _Iterator, typename _Container>\012    class __normal_iterator\012    {\012    protected:\012      _Iterator _M_current;\012\012    public:\012      typedef _Iterator					     iterator_type;\012      typedef typename iterator_traits<_Iterator>::iterator_category\012                                                             iterator_category;\012      typedef typename iterator_traits<_Iterator>::value_type  value_type;\012      typedef typename iterator_traits<_Iterator>::difference_type\012                                                             difference_type;\012      typedef typename iterator_traits<_Iterator>::reference reference;\012      typedef typename iterator_traits<_Iterator>::pointer   pointer;\012\012      __normal_iterator() : _M_current(_Iterator()) { }\012\012      explicit\012      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }\012\012      // Allow iterator to const_iterator conversion\012      template<typename _Iter>\012        __normal_iterator(const __normal_iterator<_Iter,\012			  typename __enable_if<\012      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),\012		      _Container>::__type>& __i)\012        : _M_current(__i.base()) { }\012\012      // Forward iterator requirements\012      reference\012      operator*() const\012      { return *_M_current; }\012\012      pointer\012      operator->() const\012      { return _M_current; }\012\012      __normal_iterator&\012      operator++()\012      {\012	++_M_current;\012	return *this;\012      }\012\012      __normal_iterator\012      operator++(int)\012      { return __normal_iterator(_M_current++); }\012\012      // Bidirectional iterator requirements\012      __normal_iterator&\012      operator--()\012      {\012	--_M_current;\012	return *this;\012      }\012\012      __normal_iterator\012      operator--(int)\012      { return __normal_iterator(_M_current--); }\012\012      // Random access iterator requirements\012      reference\012      operator[](const difference_type& __n) const\012      { return _M_current[__n]; }\012\012      __normal_iterator&\012      operator+=(const difference_type& __n)\012      { _M_current += __n; return *this; }\012\012      __normal_iterator\012      operator+(const difference_type& __n) const\012      { return __normal_iterator(_M_current + __n); }\012\012      __normal_iterator&\012      operator-=(const difference_type& __n)\012      { _M_current -= __n; return *this; }\012\012      __normal_iterator\012      operator-(const difference_type& __n) const\012      { return __normal_iterator(_M_current - __n); }\012\012      const _Iterator&\012      base() const\012      { return _M_current; }\012    };\012\012  // Note: In what follows, the left- and right-hand-side iterators are\012  // allowed to vary in types (conceptually in cv-qualification) so that\012  // comparison between cv-qualified and non-cv-qualified iterators be\012  // valid.  However, the greedy and unfriendly operators in std::rel_ops\012  // will make overload resolution ambiguous (when in scope) if we don't\012  // provide overloads whose operands are of the same type.  Can someone\012  // remind me what generic programming is about? -- Gaby\012\012  // Forward iterator requirements\012  template<typename _IteratorL, typename _IteratorR, typename _Container>\012    inline bool\012    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\012	       const __normal_iterator<_IteratorR, _Container>& __rhs)\012    { return __lhs.base() == __rhs.base(); }\012\012  template<typename _Iterator, typename _Container>\012    inline bool\012    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,\012	       const __normal_iterator<_Iterator, _Container>& __rhs)\012    { return __lhs.base() == __rhs.base(); }\012\012  template<typename _IteratorL, typename _IteratorR, typename _Container>\012    inline bool\012    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\012	       const __normal_iterator<_IteratorR, _Container>& __rhs)\012    { return __lhs.base() != __rhs.base(); }\012\012  template<typename _Iterator, typename _Container>\012    inline bool\012    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,\012	       const __normal_iterator<_Iterator, _Container>& __rhs)\012    { return __lhs.base() != __rhs.base(); }\012\012  // Random access iterator requirements\012  template<typename _IteratorL, typename _IteratorR, typename _Container>\012    inline bool\012    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\012	      const __normal_iterator<_IteratorR, _Container>& __rhs)\012    { return __lhs.base() < __rhs.base(); }\012\012  template<typename _Iterator, typename _Container>\012    inline bool\012    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,\012	      const __normal_iterator<_Iterator, _Container>& __rhs)\012    { return __lhs.base() < __rhs.base(); }\012\012  template<typename _IteratorL, typename _IteratorR, typename _Container>\012    inline bool\012    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\012	      const __normal_iterator<_IteratorR, _Container>& __rhs)\012    { return __lhs.base() > __rhs.base(); }\012\012  template<typename _Iterator, typename _Container>\012    inline bool\012    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,\012	      const __normal_iterator<_Iterator, _Container>& __rhs)\012    { return __lhs.base() > __rhs.base(); }\012\012  template<typename _IteratorL, typename _IteratorR, typename _Container>\012    inline bool\012    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\012	       const __normal_iterator<_IteratorR, _Container>& __rhs)\012    { return __lhs.base() <= __rhs.base(); }\012\012  template<typename _Iterator, typename _Container>\012    inline bool\012    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,\012	       const __normal_iterator<_Iterator, _Container>& __rhs)\012    { return __lhs.base() <= __rhs.base(); }\012\012  template<typename _IteratorL, typename _IteratorR, typename _Container>\012    inline bool\012    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\012	       const __normal_iterator<_IteratorR, _Container>& __rhs)\012    { return __lhs.base() >= __rhs.base(); }\012\012  template<typename _Iterator, typename _Container>\012    inline bool\012    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,\012	       const __normal_iterator<_Iterator, _Container>& __rhs)\012    { return __lhs.base() >= __rhs.base(); }\012\012  // _GLIBCXX_RESOLVE_LIB_DEFECTS\012  // According to the resolution of DR179 not only the various comparison\012  // operators but also operator- must accept mixed iterator/const_iterator\012  // parameters.\012  template<typename _IteratorL, typename _IteratorR, typename _Container>\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012    // DR 685.\012    inline auto\012    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\012	      const __normal_iterator<_IteratorR, _Container>& __rhs)\012    -> decltype(__lhs.base() - __rhs.base())\012#else\012    inline typename __normal_iterator<_IteratorL, _Container>::difference_type\012    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\012	      const __normal_iterator<_IteratorR, _Container>& __rhs)\012#endif\012    { return __lhs.base() - __rhs.base(); }\012\012  template<typename _Iterator, typename _Container>\012    inline typename __normal_iterator<_Iterator, _Container>::difference_type\012    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,\012	      const __normal_iterator<_Iterator, _Container>& __rhs)\012    { return __lhs.base() - __rhs.base(); }\012\012  template<typename _Iterator, typename _Container>\012    inline __normal_iterator<_Iterator, _Container>\012    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type\012	      __n, const __normal_iterator<_Iterator, _Container>& __i)\012    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }\012\012_GLIBCXX_END_NAMESPACE\012\012#ifdef __GXX_EXPERIMENTAL_CXX0X__\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  // 24.4.3  Move iterators\012  /**\012   *  Class template move_iterator is an iterator adapter with the same\012   *  behavior as the underlying iterator except that its dereference\012   *  operator implicitly converts the value returned by the underlying\012   *  iterator's dereference operator to an rvalue reference.  Some\012   *  generic algorithms can be called with move iterators to replace\012   *  copying with moving.\012   */\012  template<typename _Iterator>\012    class move_iterator\012    {\012    protected:\012      _Iterator _M_current;\012\012    public:\012      typedef _Iterator                                        iterator_type;\012      typedef typename iterator_traits<_Iterator>::difference_type\012                                                               difference_type;\012      // NB: DR 680.\012      typedef _Iterator                                        pointer;\012      typedef typename iterator_traits<_Iterator>::value_type  value_type;\012      typedef typename iterator_traits<_Iterator>::iterator_category\012                                                               iterator_category;\012      typedef value_type&&                                     reference;\012\012    public:\012      move_iterator()\012      : _M_current() { }\012\012      explicit\012      move_iterator(iterator_type __i)\012      : _M_current(__i) { }\012\012      template<typename _Iter>\012	move_iterator(const move_iterator<_Iter>& __i)\012	: _M_current(__i.base()) { }\012\012      iterator_type\012      base() const\012      { return _M_current; }\012\012      reference\012      operator*() const\012      { return *_M_current; }\012\012      pointer\012      operator->() const\012      { return _M_current; }\012\012      move_iterator&\012      operator++()\012      {\012	++_M_current;\012	return *this;\012      }\012\012      move_iterator\012      operator++(int)\012      {\012	move_iterator __tmp = *this;\012	++_M_current;\012	return __tmp;\012      }\012\012      move_iterator&\012      operator--()\012      {\012	--_M_current;\012	return *this;\012      }\012\012      move_iterator\012      operator--(int)\012      {\012	move_iterator __tmp = *this;\012	--_M_current;\012	return __tmp;\012      }\012\012      move_iterator\012      operator+(difference_type __n) const\012      { return move_iterator(_M_current + __n); }\012\012      move_iterator&\012      operator+=(difference_type __n)\012      {\012	_M_current += __n;\012	return *this;\012      }\012\012      move_iterator\012      operator-(difference_type __n) const\012      { return move_iterator(_M_current - __n); }\012    \012      move_iterator&\012      operator-=(difference_type __n)\012      { \012	_M_current -= __n;\012	return *this;\012      }\012\012      reference\012      operator[](difference_type __n) const\012      { return _M_current[__n]; }\012    };\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator==(const move_iterator<_IteratorL>& __x,\012	       const move_iterator<_IteratorR>& __y)\012    { return __x.base() == __y.base(); }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator!=(const move_iterator<_IteratorL>& __x,\012	       const move_iterator<_IteratorR>& __y)\012    { return !(__x == __y); }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator<(const move_iterator<_IteratorL>& __x,\012	      const move_iterator<_IteratorR>& __y)\012    { return __x.base() < __y.base(); }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator<=(const move_iterator<_IteratorL>& __x,\012	       const move_iterator<_IteratorR>& __y)\012    { return !(__y < __x); }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator>(const move_iterator<_IteratorL>& __x,\012	      const move_iterator<_IteratorR>& __y)\012    { return __y < __x; }\012\012  template<typename _IteratorL, typename _IteratorR>\012    inline bool\012    operator>=(const move_iterator<_IteratorL>& __x,\012	       const move_iterator<_IteratorR>& __y)\012    { return !(__x < __y); }\012\012  // DR 685.\012  template<typename _IteratorL, typename _IteratorR>\012    inline auto\012    operator-(const move_iterator<_IteratorL>& __x,\012	      const move_iterator<_IteratorR>& __y)\012    -> decltype(__x.base() - __y.base())\012    { return __x.base() - __y.base(); }\012\012  template<typename _Iterator>\012    inline move_iterator<_Iterator>\012    operator+(typename move_iterator<_Iterator>::difference_type __n,\012	      const move_iterator<_Iterator>& __x)\012    { return __x + __n; }\012\012  template<typename _Iterator>\012    inline move_iterator<_Iterator>\012    make_move_iterator(const _Iterator& __i)\012    { return move_iterator<_Iterator>(__i); }\012\012_GLIBCXX_END_NAMESPACE\012\012#define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)\012#else\012#define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)\012#endif // __GXX_EXPERIMENTAL_CXX0X__\012\012#endif\012"}, {"path":"/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stringfwd.h", "name":"stringfwd.h", "has_active_debug_locs":true, "absName":"/usr/include/c++/4.4.7/bits/stringfwd.h", "content":"// String support -*- C++ -*-\012\012// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\012// Free Software Foundation, Inc.\012//\012// This file is part of the GNU ISO C++ Library.  This library is free\012// software; you can redistribute it and/or modify it under the\012// terms of the GNU General Public License as published by the\012// Free Software Foundation; either version 3, or (at your option)\012// any later version.\012\012// This library is distributed in the hope that it will be useful,\012// but WITHOUT ANY WARRANTY; without even the implied warranty of\012// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\012// GNU General Public License for more details.\012\012// Under Section 7 of GPL version 3, you are granted additional\012// permissions described in the GCC Runtime Library Exception, version\012// 3.1, as published by the Free Software Foundation.\012\012// You should have received a copy of the GNU General Public License and\012// a copy of the GCC Runtime Library Exception along with this program;\012// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\012// <http://www.gnu.org/licenses/>.\012\012/** @file stringfwd.h\012 *  This is an internal header file, included by other library headers.\012 *  You should not attempt to use it directly.\012 */\012\012//\012// ISO C++ 14882: 21 Strings library\012//\012\012#ifndef _STRINGFWD_H\012#define _STRINGFWD_H 1\012\012#pragma GCC system_header\012\012#include <bits/c++config.h>\012\012_GLIBCXX_BEGIN_NAMESPACE(std)\012\012  template<typename _Alloc>\012    class allocator;\012\012  template<class _CharT>\012    struct char_traits;\012\012  template<typename _CharT, typename _Traits = char_traits<_CharT>,\012           typename _Alloc = allocator<_CharT> >\012    class basic_string;\012\012  template<> struct char_traits<char>;\012\012  typedef basic_string<char>    string;\012\012#ifdef _GLIBCXX_USE_WCHAR_T\012  template<> struct char_traits<wchar_t>;\012\012  typedef basic_string<wchar_t> wstring;\012#endif\012\012#if (defined(__GXX_EXPERIMENTAL_CXX0X__) \\\012     && defined(_GLIBCXX_USE_C99_STDINT_TR1))\012\012  template<> struct char_traits<char16_t>;\012  template<> struct char_traits<char32_t>;\012\012  typedef basic_string<char16_t> u16string;\012  typedef basic_string<char32_t> u32string;\012\012#endif\012\012_GLIBCXX_END_NAMESPACE\012\012#endif	// _STRINGFWD_H\012"}, {"path":"/usr/include/xlocale.h", "name":"xlocale.h", "has_active_debug_locs":true, "absName":"/usr/include/xlocale.h", "content":"/* Definition of locale datatype.\012   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.\012   This file is part of the GNU C Library.\012   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.\012\012   The GNU C Library is free software; you can redistribute it and/or\012   modify it under the terms of the GNU Lesser General Public\012   License as published by the Free Software Foundation; either\012   version 2.1 of the License, or (at your option) any later version.\012\012   The GNU C Library is distributed in the hope that it will be useful,\012   but WITHOUT ANY WARRANTY; without even the implied warranty of\012   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\012   Lesser General Public License for more details.\012\012   You should have received a copy of the GNU Lesser General Public\012   License along with the GNU C Library; if not, write to the Free\012   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\012   02111-1307 USA.  */\012\012#ifndef _XLOCALE_H\012#define _XLOCALE_H	1\012\012/* Structure for reentrant locale using functions.  This is an\012   (almost) opaque type for the user level programs.  The file and\012   this data structure is not standardized.  Don't rely on it.  It can\012   go away without warning.  */\012typedef struct __locale_struct\012{\012  /* Note: LC_ALL is not a valid index into this array.  */\012  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */\012\012  /* To increase the speed of this solution we add some special members.  */\012  const unsigned short int *__ctype_b;\012  const int *__ctype_tolower;\012  const int *__ctype_toupper;\012\012  /* Note: LC_ALL is not a valid index into this array.  */\012  const char *__names[13];\012} *__locale_t;\012\012/* POSIX 2008 makes locale_t official.  */\012typedef __locale_t locale_t;\012\012#endif /* xlocale.h */\012"}];