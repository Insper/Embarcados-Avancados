{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo a Eletica - Embarcados Avan\u00e7ados! \u00b6 Disciplina eletiva da Engenharia da Computa\u00e7\u00e3o Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Material de Aula dispon\u00edvel na wiki OBJETIVOS: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Geral \u00b6 Sobre FPGA e Softwares VHDL Projeto Final \u00b6 Overview Entrega 1 Tutorias \u00b6 FPGA \u00b6 1. RTL Entrega 1 2. NIOS Entrega 2 3. IP core Entrega 3 SoC \u00b6 4. u-boot 5. Linux Kernel 6. buildroot 7. Aplica\u00e7\u00e3o SoC + FPGA \u00b6 8. User space 9. Kernel space Acelera\u00e7\u00e3o \u00b6 10. HLS 11. OpenCl Din\u00e2mica \u00b6 A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado. Bibliografia \u00b6 B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008. Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na wiki do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final. Infraestrutura \u00b6 Vamos precisar dos softwares listados (aqui)[ https://github.com/Insper/Embarcados-Avancados/wiki/FPGA-e-Softwares#softwares ]. Iremos ao longo do curso trabalhar com uma FPGA Intel, o kit \u00e9 o DE10-Standard . Aulas \u00b6 Aulas segunda 19 / 8 e quarta 21 / 8 \u00b6 \u2757\ufe0f Sem aula \u2757\ufe0f Professor no evento Embedded Linux Usar o tempo para estudar os temas poss\u00edveis de tutorial e o que gostaria de atacar. Aula 3 - 14 / 8 \u00b6 Introdu\u00e7\u00e3o tutorial 2 Aula 2 - 7 / 8 \u00b6 Tutorial 1 Entrega 1 Aula 1 - 5 / 8 \u00b6 Objetivo da aula: Contextualiza\u00e7\u00e3o/ Aplica\u00e7\u00f5es/ Tecnologia/ Infraestrutura para o curso Assuntos \u00b6 O que \u00e9 um System On Chip (SoC) ? Qual a vantagem/desvantagem do uso de um SoC? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e Hard-Processor? NIOS x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / apple 2 / microsoft / amazon Para pr\u00f3xima aula \u00b6 Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Home"},{"location":"#bem-vindo-a-eletica-embarcados-avancados","text":"Disciplina eletiva da Engenharia da Computa\u00e7\u00e3o Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Material de Aula dispon\u00edvel na wiki OBJETIVOS: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"Bem vindo a Eletica - Embarcados Avan\u00e7ados!"},{"location":"#geral","text":"Sobre FPGA e Softwares VHDL","title":"Geral"},{"location":"#projeto-final","text":"Overview Entrega 1","title":"Projeto Final"},{"location":"#tutorias","text":"","title":"Tutorias"},{"location":"#fpga","text":"1. RTL Entrega 1 2. NIOS Entrega 2 3. IP core Entrega 3","title":"FPGA"},{"location":"#soc","text":"4. u-boot 5. Linux Kernel 6. buildroot 7. Aplica\u00e7\u00e3o","title":"SoC"},{"location":"#soc-fpga","text":"8. User space 9. Kernel space","title":"SoC + FPGA"},{"location":"#aceleracao","text":"10. HLS 11. OpenCl","title":"Acelera\u00e7\u00e3o"},{"location":"#dinamica","text":"A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado.","title":"Din\u00e2mica"},{"location":"#bibliografia","text":"B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008.","title":"Bibliografia"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na wiki do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final.","title":"Avalia\u00e7\u00e3o"},{"location":"#infraestrutura","text":"Vamos precisar dos softwares listados (aqui)[ https://github.com/Insper/Embarcados-Avancados/wiki/FPGA-e-Softwares#softwares ]. Iremos ao longo do curso trabalhar com uma FPGA Intel, o kit \u00e9 o DE10-Standard .","title":"Infraestrutura"},{"location":"#aulas","text":"","title":"Aulas"},{"location":"#aulas-segunda-19-8-e-quarta-21-8","text":"\u2757\ufe0f Sem aula \u2757\ufe0f Professor no evento Embedded Linux Usar o tempo para estudar os temas poss\u00edveis de tutorial e o que gostaria de atacar.","title":"Aulas segunda 19 / 8 e quarta 21 / 8"},{"location":"#aula-3-14-8","text":"Introdu\u00e7\u00e3o tutorial 2","title":"Aula 3 - 14 / 8"},{"location":"#aula-2-7-8","text":"Tutorial 1 Entrega 1","title":"Aula 2 - 7 / 8"},{"location":"#aula-1-5-8","text":"Objetivo da aula: Contextualiza\u00e7\u00e3o/ Aplica\u00e7\u00f5es/ Tecnologia/ Infraestrutura para o curso","title":"Aula 1  - 5 / 8"},{"location":"#assuntos","text":"O que \u00e9 um System On Chip (SoC) ? Qual a vantagem/desvantagem do uso de um SoC? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e Hard-Processor? NIOS x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / apple 2 / microsoft / amazon","title":"Assuntos"},{"location":"#para-proxima-aula","text":"Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Para pr\u00f3xima aula"},{"location":"Entrega-1/","text":"Entrega 1 \u00b6 Entrega: Pasta Entrega-1 no git Demonstra\u00e7\u00e3o em sala A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e com o Quartus e que tamb\u00e9m relembrem como desenvolver um projeto de forma hier\u00e1rquica. A partir do tutorial, voc\u00eas devem modificar o projeto para que o controle do LED seja feito por um componente (chamado de LED_peripheral ). Esse componente deve variar a frequ\u00eancia na qual os LEDs piscam com base um vetor de 4 bits, que ser\u00e1 ao final atribuido as chaves SW. E tamb\u00e9m deve possuir um sinal de enable (EN), que s\u00f3 deve funcionar caso positivo. Esse sinal de EN ser\u00e1 atribuido a bot\u00e3o KEY0. Depois de criarem esse novo componente, voc\u00eas devem o utilizar no topLevel para controlar efetivamente os pinos. Rubrica \u00b6 A Entregue um testbench capaz de testar o projeto. A Entregue um testbench capaz de testar o projeto. B O componente faz uso de generics para configura\u00e7\u00e3o interna. C Criou um componente em VHDL que \u00e9 respons\u00e1vel pelo controle do LED Esse componente possui um sinal de entrada de 4 bits que controla a frequ\u00eancia do LEDs, mapeado para as chaves SW. Esse componente possui um sinal de EN, mapeado para o bot\u00e3o KEY0 D Entregou o tutorial I N\u00e3o entregou nada Pr\u00f3ximo passo \u00b6 Siga para o tutorial Tutorial FPGA NIOS","title":"Entrega 1"},{"location":"Entrega-1/#entrega-1","text":"Entrega: Pasta Entrega-1 no git Demonstra\u00e7\u00e3o em sala A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e com o Quartus e que tamb\u00e9m relembrem como desenvolver um projeto de forma hier\u00e1rquica. A partir do tutorial, voc\u00eas devem modificar o projeto para que o controle do LED seja feito por um componente (chamado de LED_peripheral ). Esse componente deve variar a frequ\u00eancia na qual os LEDs piscam com base um vetor de 4 bits, que ser\u00e1 ao final atribuido as chaves SW. E tamb\u00e9m deve possuir um sinal de enable (EN), que s\u00f3 deve funcionar caso positivo. Esse sinal de EN ser\u00e1 atribuido a bot\u00e3o KEY0. Depois de criarem esse novo componente, voc\u00eas devem o utilizar no topLevel para controlar efetivamente os pinos.","title":"Entrega 1"},{"location":"Entrega-1/#rubrica","text":"A Entregue um testbench capaz de testar o projeto. A Entregue um testbench capaz de testar o projeto. B O componente faz uso de generics para configura\u00e7\u00e3o interna. C Criou um componente em VHDL que \u00e9 respons\u00e1vel pelo controle do LED Esse componente possui um sinal de entrada de 4 bits que controla a frequ\u00eancia do LEDs, mapeado para as chaves SW. Esse componente possui um sinal de EN, mapeado para o bot\u00e3o KEY0 D Entregou o tutorial I N\u00e3o entregou nada","title":"Rubrica"},{"location":"Entrega-1/#proximo-passo","text":"Siga para o tutorial Tutorial FPGA NIOS","title":"Pr\u00f3ximo passo"},{"location":"Entrega-2/","text":"Entrega 2 \u00b6 O que deve ser entregue? - Pasta Entrega-1 no git - Demonstra\u00e7\u00e3o em sala Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com os LEDs e bot\u00f5es sendo acionados e lidos pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf Rubrica: \u00b6 I N\u00e3o entregou nada D Entregou somente tutorial C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx e KEYx) Adicione um novo PIO para ler o valor dos bot\u00f5es Interrup\u00e7\u00e3o na leitura do bot\u00e3o B Crie um driver para controlar os LEDs e Ler as chaves (criar uma biblioteca com arquivos .c e .h separados e fun\u00e7\u00f5es), ou : Adicione e fa\u00e7a uso de um timer (Platform Design) A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o","title":"Entrega 2"},{"location":"Entrega-2/#entrega-2","text":"O que deve ser entregue? - Pasta Entrega-1 no git - Demonstra\u00e7\u00e3o em sala Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com os LEDs e bot\u00f5es sendo acionados e lidos pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf","title":"Entrega 2"},{"location":"Entrega-2/#rubrica","text":"I N\u00e3o entregou nada D Entregou somente tutorial C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx e KEYx) Adicione um novo PIO para ler o valor dos bot\u00f5es Interrup\u00e7\u00e3o na leitura do bot\u00e3o B Crie um driver para controlar os LEDs e Ler as chaves (criar uma biblioteca com arquivos .c e .h separados e fun\u00e7\u00f5es), ou : Adicione e fa\u00e7a uso de um timer (Platform Design) A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o","title":"Rubrica:"},{"location":"Entrega-3-old/","text":"Entrega 3 - (OLD) 2018-1 \u00b6 Warning semestre passado cada aluno teve que desenvolver um perif\u00e9rico para um hardware externo a FPGA, por diversas raz\u00f5es eles gastaram muito tempo nisso, nesse semestre eu quero facilitar um pouco para que possamos avan\u00e7ar em outras coisas, vou deixar a entrega aqui de refer\u00eancia para voc\u00eas verem o que foi feito!!! Criar um IP dedicado para interfacear com um hardware externo a FPGA, cada aluno (ou dupla) dever\u00e1 escolher um perif\u00e9rico e criar tanto o componente em HDL que conecta-se ao barramento Avalon quanto uma camada de abstra\u00e7\u00e3o de hardware (especificada a seguir) para comandar esse perif\u00e9rico. Os perif\u00e9ricos que podem ser escolhidos s\u00e3o: Teclado matricial de membrana 12 teclas Sabrina Motor de passo : Implementado por: Gustavo / Astur Motor DC com ponte H Implementado por: Cunial Sensor ultrass\u00f4nico HC-SR04 Implementado por: Raphael Encoder rotacional KY 040 Implementado por: Marcelo Sensor de temperatura e umidade AM2302 : Driver software \u00b6 https://www.intel.com/content/www/us/en/programmable/documentation/iga1430779693885.html https://www.intel.com/content/dam/altera-www/global/ja_JP/pdfs/literature/hb/nios2/n2sw_nii52003.pdf Para cada sensor deve ser desenvolvido um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: int NAME_init ( ..... ); // Inicializa o perif\u00e9rico int NAME_config ( ..... ); // Configura o perif\u00e9rico int NAME_halt ( ..... ); // Desativa o perif\u00e9rico int NAME_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int NAME_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o int NAME_read_xxxxx ( ..... ); // read data xxxx from device int NAME_write_xxxxx ( ..... ); // write data to xxxx device Esse driver deve estar distribu\u00eddo em dois arquivos: NAME.c e NAME.h . Rubricas gerais do projeto: \u00b6 I N\u00e3o entregou D Entregou o tutorial C (individual) Fornecido exemplo que utiliza o perif\u00e9rico Desenvolvido biblioteca em C para abstra\u00e7\u00e3o do perif\u00e9rico (de acordo com documenta\u00e7\u00e3o) Perif\u00e9rico possui registrador de configura\u00e7\u00e3o que o possibilita ligar e desligar rubrica espec\u00edfica B (individual) / C (dupla) rubrica espec\u00edfica A (individual) / B (dupla) um item da rubrica espec\u00edfica A+ (individual/dupla) dois itens do A Sensores \u00b6 Detalhamento dos sensores e das rubricas. Teclado matricial \u00b6 O perif\u00e9rico deve fazer a varredura autom\u00e1tica das teclas e gravar em um registrador o \u00faltimo valor referente ao bot\u00e3o pressionado. Rubrica: C Perif\u00e9rico faz varredura das teclas e salva bot\u00e3o em registrador B Sempre que uma tecla nova for detectada, gera uma interrup\u00e7\u00e3o A Suporta diferentes configura\u00e7\u00f5es (frequ\u00eancia de varredura, diferentes teclados: 12, 16, ...) Implementa debouncing Armazena um vetor de teclas pressionadas Motor de passo \u00b6 O perif\u00e9rico deve receber uma quantidade de pulsos e dire\u00e7\u00e3o e realizar o controle das fases do motor de passo a fim de realizar tal opera\u00e7\u00e3o. Rubrica: C Aciona motor com base em passos fornecidos B Sempre que uma a\u00e7\u00e3o de movimenta\u00e7\u00e3o for finalizada, gera uma interrup\u00e7\u00e3o. A Velocidade de rota\u00e7\u00e3o \u00e9 configur\u00e1vel Perif\u00e9rico pode ser acionado tanto por passos quanto por graus Motor DC (Ponte H) \u00b6 O perif\u00e9rico deve controlar a velocidade e dire\u00e7\u00e3o de um motor DC modulando um sinal PWM. Esse perif\u00e9rico deve ser capaz de receber um valor de duty cycle, esse motor deve ficar acionado por um tempo determinado. Rubrica: C Aciona motor com base em duty cycle e dire\u00e7\u00e3o fornecido. Possui um timer interno que especifica por quanto tempo o motor ficar\u00e1 acionado. B Gera uma interrup\u00e7\u00e3o quando o timer estourar. A (um item) Implementa um controle em malha aberta . HC \u00b6 Faz a leitura da dist\u00e2ncia de um objeto gerando o sinal de trigger no m\u00f3dulo e lendo o tempo de resposta para o echo. Deve possuir dois modos: Leitura peri\u00f3dica / Single shot. Rubrica: C Armazena em um registrador o valor do tempo da chegada do echo dado o inicio do trigger Possui dois modos de opera\u00e7\u00e3o: Peri\u00f3dico / Single shot Per\u00edodo deve ser configur\u00e1vel por reg. B Gera interrup\u00e7\u00e3o a cada nova leitura A Armazena a dist\u00e2ncia em metros, n\u00e3o o tempo percorrido. Armazena um buffer de leituras. Filtra os dados de leitura para remover ru\u00eddo Encoder de quadratura rotacional \u00b6 Contabiliza a leitura dos pulsos de um encoder de quadratura para um valor, indicando o sentido de rota\u00e7\u00e3o. Deve possuir uma maneira de zerar a quantia de pulsos j\u00e1 contabilizada. C Faz a leitura da quantidade de pulsos e a dire\u00e7\u00e3o B Gera interrup\u00e7\u00e3o a cada novo pulso detecado A Armazena a informa\u00e7\u00e3o em graus Faz a leitura por quadratura (sobida e descida) para aumentar a resolu\u00e7\u00e3o Sensor de temperatura e umidade AM2302 \u00b6 Perif\u00e9rico respons\u00e1vel por estabelecer comunica\u00e7\u00e3o com o sensor AM2302 e extrair dados de temperatura e umidade. Deve possuir dois modos de opera\u00e7\u00e3o: Peri\u00f3dico e Single Shot. C Faz a leitura da temperatura e umidade Per\u00edodo deve ser configur\u00e1vel por reg. B Dois modos de opera\u00e7\u00e3o: Peri\u00f3dico / Single Shot Gera interrup\u00e7\u00e3o a cada novo valor A Valida checksum e gera erro caso detectado algo errado","title":"Entrega 3 - (OLD) 2018-1"},{"location":"Entrega-3-old/#entrega-3-old-2018-1","text":"Warning semestre passado cada aluno teve que desenvolver um perif\u00e9rico para um hardware externo a FPGA, por diversas raz\u00f5es eles gastaram muito tempo nisso, nesse semestre eu quero facilitar um pouco para que possamos avan\u00e7ar em outras coisas, vou deixar a entrega aqui de refer\u00eancia para voc\u00eas verem o que foi feito!!! Criar um IP dedicado para interfacear com um hardware externo a FPGA, cada aluno (ou dupla) dever\u00e1 escolher um perif\u00e9rico e criar tanto o componente em HDL que conecta-se ao barramento Avalon quanto uma camada de abstra\u00e7\u00e3o de hardware (especificada a seguir) para comandar esse perif\u00e9rico. Os perif\u00e9ricos que podem ser escolhidos s\u00e3o: Teclado matricial de membrana 12 teclas Sabrina Motor de passo : Implementado por: Gustavo / Astur Motor DC com ponte H Implementado por: Cunial Sensor ultrass\u00f4nico HC-SR04 Implementado por: Raphael Encoder rotacional KY 040 Implementado por: Marcelo Sensor de temperatura e umidade AM2302 :","title":"Entrega 3 - (OLD) 2018-1"},{"location":"Entrega-3-old/#driver-software","text":"https://www.intel.com/content/www/us/en/programmable/documentation/iga1430779693885.html https://www.intel.com/content/dam/altera-www/global/ja_JP/pdfs/literature/hb/nios2/n2sw_nii52003.pdf Para cada sensor deve ser desenvolvido um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: int NAME_init ( ..... ); // Inicializa o perif\u00e9rico int NAME_config ( ..... ); // Configura o perif\u00e9rico int NAME_halt ( ..... ); // Desativa o perif\u00e9rico int NAME_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int NAME_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o int NAME_read_xxxxx ( ..... ); // read data xxxx from device int NAME_write_xxxxx ( ..... ); // write data to xxxx device Esse driver deve estar distribu\u00eddo em dois arquivos: NAME.c e NAME.h .","title":"Driver software"},{"location":"Entrega-3-old/#rubricas-gerais-do-projeto","text":"I N\u00e3o entregou D Entregou o tutorial C (individual) Fornecido exemplo que utiliza o perif\u00e9rico Desenvolvido biblioteca em C para abstra\u00e7\u00e3o do perif\u00e9rico (de acordo com documenta\u00e7\u00e3o) Perif\u00e9rico possui registrador de configura\u00e7\u00e3o que o possibilita ligar e desligar rubrica espec\u00edfica B (individual) / C (dupla) rubrica espec\u00edfica A (individual) / B (dupla) um item da rubrica espec\u00edfica A+ (individual/dupla) dois itens do A","title":"Rubricas gerais do projeto:"},{"location":"Entrega-3-old/#sensores","text":"Detalhamento dos sensores e das rubricas.","title":"Sensores"},{"location":"Entrega-3-old/#teclado-matricial","text":"O perif\u00e9rico deve fazer a varredura autom\u00e1tica das teclas e gravar em um registrador o \u00faltimo valor referente ao bot\u00e3o pressionado. Rubrica: C Perif\u00e9rico faz varredura das teclas e salva bot\u00e3o em registrador B Sempre que uma tecla nova for detectada, gera uma interrup\u00e7\u00e3o A Suporta diferentes configura\u00e7\u00f5es (frequ\u00eancia de varredura, diferentes teclados: 12, 16, ...) Implementa debouncing Armazena um vetor de teclas pressionadas","title":"Teclado matricial"},{"location":"Entrega-3-old/#motor-de-passo","text":"O perif\u00e9rico deve receber uma quantidade de pulsos e dire\u00e7\u00e3o e realizar o controle das fases do motor de passo a fim de realizar tal opera\u00e7\u00e3o. Rubrica: C Aciona motor com base em passos fornecidos B Sempre que uma a\u00e7\u00e3o de movimenta\u00e7\u00e3o for finalizada, gera uma interrup\u00e7\u00e3o. A Velocidade de rota\u00e7\u00e3o \u00e9 configur\u00e1vel Perif\u00e9rico pode ser acionado tanto por passos quanto por graus","title":"Motor de passo"},{"location":"Entrega-3-old/#motor-dc-ponte-h","text":"O perif\u00e9rico deve controlar a velocidade e dire\u00e7\u00e3o de um motor DC modulando um sinal PWM. Esse perif\u00e9rico deve ser capaz de receber um valor de duty cycle, esse motor deve ficar acionado por um tempo determinado. Rubrica: C Aciona motor com base em duty cycle e dire\u00e7\u00e3o fornecido. Possui um timer interno que especifica por quanto tempo o motor ficar\u00e1 acionado. B Gera uma interrup\u00e7\u00e3o quando o timer estourar. A (um item) Implementa um controle em malha aberta .","title":"Motor DC (Ponte H)"},{"location":"Entrega-3-old/#hc","text":"Faz a leitura da dist\u00e2ncia de um objeto gerando o sinal de trigger no m\u00f3dulo e lendo o tempo de resposta para o echo. Deve possuir dois modos: Leitura peri\u00f3dica / Single shot. Rubrica: C Armazena em um registrador o valor do tempo da chegada do echo dado o inicio do trigger Possui dois modos de opera\u00e7\u00e3o: Peri\u00f3dico / Single shot Per\u00edodo deve ser configur\u00e1vel por reg. B Gera interrup\u00e7\u00e3o a cada nova leitura A Armazena a dist\u00e2ncia em metros, n\u00e3o o tempo percorrido. Armazena um buffer de leituras. Filtra os dados de leitura para remover ru\u00eddo","title":"HC"},{"location":"Entrega-3-old/#encoder-de-quadratura-rotacional","text":"Contabiliza a leitura dos pulsos de um encoder de quadratura para um valor, indicando o sentido de rota\u00e7\u00e3o. Deve possuir uma maneira de zerar a quantia de pulsos j\u00e1 contabilizada. C Faz a leitura da quantidade de pulsos e a dire\u00e7\u00e3o B Gera interrup\u00e7\u00e3o a cada novo pulso detecado A Armazena a informa\u00e7\u00e3o em graus Faz a leitura por quadratura (sobida e descida) para aumentar a resolu\u00e7\u00e3o","title":"Encoder de quadratura rotacional"},{"location":"Entrega-3-old/#sensor-de-temperatura-e-umidade-am2302","text":"Perif\u00e9rico respons\u00e1vel por estabelecer comunica\u00e7\u00e3o com o sensor AM2302 e extrair dados de temperatura e umidade. Deve possuir dois modos de opera\u00e7\u00e3o: Peri\u00f3dico e Single Shot. C Faz a leitura da temperatura e umidade Per\u00edodo deve ser configur\u00e1vel por reg. B Dois modos de opera\u00e7\u00e3o: Peri\u00f3dico / Single Shot Gera interrup\u00e7\u00e3o a cada novo valor A Valida checksum e gera erro caso detectado algo errado","title":"Sensor de temperatura e umidade AM2302"},{"location":"Entrega-3/","text":"Entrega 3 \u00b6 Nessa entrega iremos encapsular um perif\u00e9rico que \u00e9 respons\u00e1vel pela leitura de um mouse pela interface PS/2 no Plataform Designer (criando um perif\u00e9rico mapeado em mem\u00f3ria). Utilizaremos como c\u00f3digo padr\u00e3o o exemplo fornecido pela terasic para essa placa, dispon\u00edvel no CD do kit: Demonstration/FPGA/DE10_Standard_PS2/ . Rubrica: \u00b6 I N\u00e3o entregou nada D Entregou somente tutorial C PS2 mapeado em mem\u00f3ria lendo X,Y e click Left Fun\u00e7\u00f5es: PS2_init() / PS2_halt() / ps_read_clickLeft() B Aprimorado fun\u00e7\u00f5es do PS2 + ps2.c e ps2.h A PS2 gera interrup\u00e7\u00e3o Hardware \u00b6 O diagrama a seguir \u00e9 uma vis\u00e3o geral do que deve ser feito, nessa concep\u00e7\u00e3o iremos \"encapsular\" o IP da Terasic em um \"perif\u00e9rico mapeado em mem\u00f3ria\" ( PS2-MM ), para isso ser\u00e1 necess\u00e1rio adicionar uma l\u00f3gica extra, normalmente chamada de Glue Logic que realiza a interface entre o barramento e o IP. Perif\u00e9rico Terasic: PS2-Terasic \u00b6 O perif\u00e9rico da Terasic est\u00e1 pode ser encontrado no link a seguir: https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/blob/master/Demonstration/FPGA/DE10_Standard_PS2/v/ps2.v O exemplo que \u00e9 fornecido pela Terasic est\u00e1 em Verilog! mas n\u00e3o \u00e9 preciso desespero, podemos usar no nosso projeto em VHDL, basta declarar o componente e usar normalmente: component ps2 is port ( iSTART : in std_logic ; -- press the button for tranxrdb -merge .Xdefaultssmitting instrucions to device; iRST_n : in std_logic ; -- FSM reset signal; iCLK_50 : in std_logic ; -- clock source; PS2_CLK : inout std_logic ; -- ps2_clock signal inout; PS2_DAT : inout std_logic ; -- ps2_data signal inout; oLEFBUT : out std_logic ; -- left button press display; oRIGBUT : out std_logic ; -- right button press display; oMIDBUT : out std_logic ; -- middle button press display; oX : out std_logic_vector ( 7 downto 0 ); -- X axis. oY : out std_logic_vector ( 7 downto 0 ) -- Y axis. ); end component ps2 ; Esse exemplo est\u00e1 tamb\u00e9m documentando no manual do usu\u00e1rio: DE10-Standard_User_manual.pdf sec\u00e7\u00e3o: 3.6.12. Sec\u00e7\u00e3o: 3.6.12: Manual do usu\u00e1rio: Glue Logic \u00b6 A l\u00f3gica de controle deve interfacear com o perif\u00e9rico da Terasic em todos os sinais de controle (todos menos PS2_CLK / PS2_DATA / iCLK_50 / 'iRST_n') de maneira abstrair o acesso mapeado em mem\u00f3ria para o perif\u00e9rico. A maneira mais f\u00e1cil de fazer isso \u00e9 definindo funcionalidades a endere\u00e7os do perif\u00e9rico, por exemplo: Offset Funcionalidade Tipo 0 Controle R/W 1 ox R 2 oy R 3 oLEFTBUT R ... ... A tabela anterior mapeia para cada endere\u00e7o do perif\u00e9rico uma funcionalidade diferente, nesse exemplo, se o usu\u00e1rio deseja ler a informa\u00e7\u00e3o do deslocamento y: oy , deve fazer a leitura no endere\u00e7o 2 desse perif\u00e9rico. A implementa\u00e7\u00e3o disso pode ser feita por um simples mux . O endere\u00e7o de controle, pode ser usado por exemplo, para inicializar a leitura no perif\u00e9rico da terasic (via o sinal iSTART ). Note que alguns endere\u00e7os s\u00e3o Read Only e outros Read/Write (tipo), isso se d\u00e1 porque n\u00e3o tem sentido (nem \u00e9 poss\u00edvel fisicamente) escrever me alguns endere\u00e7os. (rubrica C) Software \u00b6 Al\u00e9m da parte de HW, iremos desenvolver uma biblioteca em C que ir\u00e1 abstrair a interface com esse perif\u00e9rico. O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: // Para rubrica C int PS2_init ( ..... ); // Inicializa o perif\u00e9rico int PS2_halt ( ..... ); // Desativa o perif\u00e9rico int PS2_read_clickLeft ( ..... ); // retorna se houve algum click (rubrica B) Software (melhorando) \u00b6 Adicionar as seguintes fun\u00e7\u00f5es: // Para rubrica B/A int PS2_read_x ( ..... ); // retorna o valor do movimento X int PS2_read_y ( ..... ); // retorna o valor do movimento y (rubrica A) IRQ \u00b6 Pode-se adicionar um sinal de interrup\u00e7\u00e3o ao perif\u00e9rico PS2-MM que servir\u00e1 para alertar o uC (NIOS) de um evento novo. Ser\u00e1 necess\u00e1rio adicionar as seguintes fun\u00e7\u00f5es: int PS2_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int PS2_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o Esse driver deve estar distribu\u00eddo em dois arquivos: PS2-MM.c e PS2-MM.h . Dicas \u00b6 \u00c9 sugerido os seguintes passos de execu\u00e7\u00e3o da entrega: Executar o exemplo PS2 da Terasic, e ver funcionar Entender os sinais do toplevel desse exemplo Desenhar um diagrama um pouco mais detalhado do PS2-MM, indicando quais sinais (nomes) ser\u00e3o conectados ao Glue Logic e quais dever\u00e3o ser conectados aos pinos da FPGA (conduit no PD) Implementar o 'PS2-MM', usando como base o perif\u00e9rico criado no tutorial. Crie uma nova pasta para o componente dentro da pasta atual IP (exe: PS2-MM) Copie o IP da terasic para essa pasta Crie seu componente dentro dessa pasta","title":"Entrega 3"},{"location":"Entrega-3/#entrega-3","text":"Nessa entrega iremos encapsular um perif\u00e9rico que \u00e9 respons\u00e1vel pela leitura de um mouse pela interface PS/2 no Plataform Designer (criando um perif\u00e9rico mapeado em mem\u00f3ria). Utilizaremos como c\u00f3digo padr\u00e3o o exemplo fornecido pela terasic para essa placa, dispon\u00edvel no CD do kit: Demonstration/FPGA/DE10_Standard_PS2/ .","title":"Entrega 3"},{"location":"Entrega-3/#rubrica","text":"I N\u00e3o entregou nada D Entregou somente tutorial C PS2 mapeado em mem\u00f3ria lendo X,Y e click Left Fun\u00e7\u00f5es: PS2_init() / PS2_halt() / ps_read_clickLeft() B Aprimorado fun\u00e7\u00f5es do PS2 + ps2.c e ps2.h A PS2 gera interrup\u00e7\u00e3o","title":"Rubrica:"},{"location":"Entrega-3/#hardware","text":"O diagrama a seguir \u00e9 uma vis\u00e3o geral do que deve ser feito, nessa concep\u00e7\u00e3o iremos \"encapsular\" o IP da Terasic em um \"perif\u00e9rico mapeado em mem\u00f3ria\" ( PS2-MM ), para isso ser\u00e1 necess\u00e1rio adicionar uma l\u00f3gica extra, normalmente chamada de Glue Logic que realiza a interface entre o barramento e o IP.","title":"Hardware"},{"location":"Entrega-3/#periferico-terasic-ps2-terasic","text":"O perif\u00e9rico da Terasic est\u00e1 pode ser encontrado no link a seguir: https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/blob/master/Demonstration/FPGA/DE10_Standard_PS2/v/ps2.v O exemplo que \u00e9 fornecido pela Terasic est\u00e1 em Verilog! mas n\u00e3o \u00e9 preciso desespero, podemos usar no nosso projeto em VHDL, basta declarar o componente e usar normalmente: component ps2 is port ( iSTART : in std_logic ; -- press the button for tranxrdb -merge .Xdefaultssmitting instrucions to device; iRST_n : in std_logic ; -- FSM reset signal; iCLK_50 : in std_logic ; -- clock source; PS2_CLK : inout std_logic ; -- ps2_clock signal inout; PS2_DAT : inout std_logic ; -- ps2_data signal inout; oLEFBUT : out std_logic ; -- left button press display; oRIGBUT : out std_logic ; -- right button press display; oMIDBUT : out std_logic ; -- middle button press display; oX : out std_logic_vector ( 7 downto 0 ); -- X axis. oY : out std_logic_vector ( 7 downto 0 ) -- Y axis. ); end component ps2 ; Esse exemplo est\u00e1 tamb\u00e9m documentando no manual do usu\u00e1rio: DE10-Standard_User_manual.pdf sec\u00e7\u00e3o: 3.6.12. Sec\u00e7\u00e3o: 3.6.12: Manual do usu\u00e1rio:","title":"Perif\u00e9rico Terasic: PS2-Terasic"},{"location":"Entrega-3/#glue-logic","text":"A l\u00f3gica de controle deve interfacear com o perif\u00e9rico da Terasic em todos os sinais de controle (todos menos PS2_CLK / PS2_DATA / iCLK_50 / 'iRST_n') de maneira abstrair o acesso mapeado em mem\u00f3ria para o perif\u00e9rico. A maneira mais f\u00e1cil de fazer isso \u00e9 definindo funcionalidades a endere\u00e7os do perif\u00e9rico, por exemplo: Offset Funcionalidade Tipo 0 Controle R/W 1 ox R 2 oy R 3 oLEFTBUT R ... ... A tabela anterior mapeia para cada endere\u00e7o do perif\u00e9rico uma funcionalidade diferente, nesse exemplo, se o usu\u00e1rio deseja ler a informa\u00e7\u00e3o do deslocamento y: oy , deve fazer a leitura no endere\u00e7o 2 desse perif\u00e9rico. A implementa\u00e7\u00e3o disso pode ser feita por um simples mux . O endere\u00e7o de controle, pode ser usado por exemplo, para inicializar a leitura no perif\u00e9rico da terasic (via o sinal iSTART ). Note que alguns endere\u00e7os s\u00e3o Read Only e outros Read/Write (tipo), isso se d\u00e1 porque n\u00e3o tem sentido (nem \u00e9 poss\u00edvel fisicamente) escrever me alguns endere\u00e7os.","title":"Glue Logic"},{"location":"Entrega-3/#rubrica-c-software","text":"Al\u00e9m da parte de HW, iremos desenvolver uma biblioteca em C que ir\u00e1 abstrair a interface com esse perif\u00e9rico. O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: // Para rubrica C int PS2_init ( ..... ); // Inicializa o perif\u00e9rico int PS2_halt ( ..... ); // Desativa o perif\u00e9rico int PS2_read_clickLeft ( ..... ); // retorna se houve algum click","title":"(rubrica C) Software"},{"location":"Entrega-3/#rubrica-b-software-melhorando","text":"Adicionar as seguintes fun\u00e7\u00f5es: // Para rubrica B/A int PS2_read_x ( ..... ); // retorna o valor do movimento X int PS2_read_y ( ..... ); // retorna o valor do movimento y","title":"(rubrica B) Software (melhorando)"},{"location":"Entrega-3/#rubrica-a-irq","text":"Pode-se adicionar um sinal de interrup\u00e7\u00e3o ao perif\u00e9rico PS2-MM que servir\u00e1 para alertar o uC (NIOS) de um evento novo. Ser\u00e1 necess\u00e1rio adicionar as seguintes fun\u00e7\u00f5es: int PS2_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int PS2_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o Esse driver deve estar distribu\u00eddo em dois arquivos: PS2-MM.c e PS2-MM.h .","title":"(rubrica A) IRQ"},{"location":"Entrega-3/#dicas","text":"\u00c9 sugerido os seguintes passos de execu\u00e7\u00e3o da entrega: Executar o exemplo PS2 da Terasic, e ver funcionar Entender os sinais do toplevel desse exemplo Desenhar um diagrama um pouco mais detalhado do PS2-MM, indicando quais sinais (nomes) ser\u00e3o conectados ao Glue Logic e quais dever\u00e3o ser conectados aos pinos da FPGA (conduit no PD) Implementar o 'PS2-MM', usando como base o perif\u00e9rico criado no tutorial. Crie uma nova pasta para o componente dentro da pasta atual IP (exe: PS2-MM) Copie o IP da terasic para essa pasta Crie seu componente dentro dessa pasta","title":"Dicas"},{"location":"Projeto-Entrega-1/","text":"Nessa primeira entrega voc\u00ea deve ter uma sugest\u00e3o de t\u00f3picos que gostaria de atacar e ter em mente qual hardware seria necess\u00e1rio para a execu\u00e7\u00e3o do mesmo, de onde voc\u00ea quer sair e onde quer chegar... Tecnologia Hardware Ponto de partida / Ponto de chegada Exemplos/ sites/ manuais que leu e achou que pode servir como refer\u00eancia","title":"Projeto Entrega 1"},{"location":"Projeto-Overview/","text":"O projeto final da disciplina deve ser um tutorial com alguma rela\u00e7\u00e3o aos objetivos de aprendizagem da mat\u00e9ria: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Alguns exemplos de \u00e1reas que podem ser atacadas: Acelera\u00e7\u00e3o/ implementa\u00e7\u00e3o de algum algor\u00edtimo em hardware processamento de dados, FFT, compress\u00e3o, criptografia, ... HLD/ HLS/ OpenCL/ FPGA Amazon Compara\u00e7\u00e3o de performance entre diferentes tecnologias SoC vs GPU vs FPGA vs uC Sistema operacional Escalonador real time kernel linux, Android, RTOS embarcado Tecnologias/ Ferramentas \u00b6 A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) \ud83d\udc4d OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL .... Hardwares \u00b6 Temos os seguintes kits de desenvolvimento dispon\u00edvel: A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados com ele Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x Exemplos de temas/ coisas legais \u00b6 \u203c\ufe0f: demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c\ufe0f Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c\ufe0f Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux Rubrica \u00b6 O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Projeto Overview"},{"location":"Projeto-Overview/#tecnologias-ferramentas","text":"A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) \ud83d\udc4d OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL ....","title":"Tecnologias/ Ferramentas"},{"location":"Projeto-Overview/#hardwares","text":"Temos os seguintes kits de desenvolvimento dispon\u00edvel: A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados com ele Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x","title":"Hardwares"},{"location":"Projeto-Overview/#exemplos-de-temas-coisas-legais","text":"\u203c\ufe0f: demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c\ufe0f Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c\ufe0f Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux","title":"Exemplos de temas/ coisas legais"},{"location":"Projeto-Overview/#rubrica","text":"O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Rubrica"},{"location":"Sobre/","text":"Metodologia \u00b6 A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos. Objetivos de Aprendizagem \u00b6 Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Avalia\u00e7\u00e3o \u00b6 Entregas das APS Tutorial","title":"Sobre"},{"location":"Sobre/#metodologia","text":"A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos.","title":"Metodologia"},{"location":"Sobre/#objetivos-de-aprendizagem","text":"Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"Objetivos de Aprendizagem"},{"location":"Sobre/#avaliacao","text":"Entregas das APS Tutorial","title":"Avalia\u00e7\u00e3o"},{"location":"Tutorial-FPGA-NIOS-IP/","text":"Tutorial 3 - FPGA - IP \u00b6 Nesse tutorial deseja-se desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa, o perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\". Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Tutorial-FPGA-NIOS-IP IP Cores \u00b6 Intelectual Proprety Core (IP Core) s\u00e3o componentes descritos em HDL que possibilitam ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m da centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Altera IP cores Platform Desginer \u00b6 O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido a padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento. Barramentos \u00b6 A Altera define dois tipos de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no plataform designer. Avalon \u00b6 Documenta\u00e7\u00e3o completa dos tipos do barramento AVALON : https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o : Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity. Projeto \u00b6 Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto : Tutorial-FPGA-NIOS e renomeei para: Tutorial-FPGA-NIOS-IP . Iremos agora trabalhar nessa nova pasta. Criando um perif\u00e9rico \u00b6 Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver (.c e .h) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1rio uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 claramente um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio. Avalon Slave Memory Mapped \u00b6 Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset (`reset), lembre que projeto digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixado em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)? Especifica\u00e7\u00e3o \u00b6 Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....). Gerar HDL que representa o perif\u00e9rico com interface Avalon \u00b6 Partindo da entidade fornecida (peripheral_MM), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse generic poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Tutorial-FPGA-NIOS-IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto. Configurando path \u00b6 Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fontes que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente) Criando componente \u00b6 S\u00f3 adicionar o arquivo HDL ( .vhd ou .v verilog) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso : File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente. Files \u00b6 Na aba Files adicione o arquivo peripheral-LED.vhd : Files Syntesis Files add file peripheral-LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral-LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese. Signals & Interfaces \u00b6 Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir : Finalizando \u00b6 Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC : Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus : tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral-LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd E edite para: add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd Utilizando o componente no PD \u00b6 Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como : Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model Utilizando o componente no topLevel.vhd \u00b6 Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no topLevel.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o topLevel.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 . Firmware \u00b6 Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um novo BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral-LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m). Executando \u00b6 Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1. Simulando \u00b6 Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem : 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado. Configurando o bsp \u00b6 Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!! ModelSim \u00b6 No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Altera. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo. Entrega 3 \u00b6 Siga para a terceira entrega: Entega 3","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#tutorial-3-fpga-ip","text":"Nesse tutorial deseja-se desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa, o perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\".","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Tutorial-FPGA-NIOS-IP","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-NIOS-IP/#ip-cores","text":"Intelectual Proprety Core (IP Core) s\u00e3o componentes descritos em HDL que possibilitam ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m da centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Altera IP cores","title":"IP Cores"},{"location":"Tutorial-FPGA-NIOS-IP/#platform-desginer","text":"O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido a padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento.","title":"Platform Desginer"},{"location":"Tutorial-FPGA-NIOS-IP/#barramentos","text":"A Altera define dois tipos de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no plataform designer.","title":"Barramentos"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon","text":"Documenta\u00e7\u00e3o completa dos tipos do barramento AVALON : https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o : Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity.","title":"Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#projeto","text":"Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto : Tutorial-FPGA-NIOS e renomeei para: Tutorial-FPGA-NIOS-IP . Iremos agora trabalhar nessa nova pasta.","title":"Projeto"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-um-periferico","text":"Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver (.c e .h) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1rio uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 claramente um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio.","title":"Criando um perif\u00e9rico"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon-slave-memory-mapped","text":"Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset (`reset), lembre que projeto digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixado em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)?","title":"Avalon Slave Memory Mapped"},{"location":"Tutorial-FPGA-NIOS-IP/#especificacao","text":"Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....).","title":"Especifica\u00e7\u00e3o"},{"location":"Tutorial-FPGA-NIOS-IP/#gerar-hdl-que-representa-o-periferico-com-interface-avalon","text":"Partindo da entidade fornecida (peripheral_MM), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse generic poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Tutorial-FPGA-NIOS-IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto.","title":"Gerar HDL que representa o perif\u00e9rico com interface Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-path","text":"Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fontes que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente)","title":"Configurando path"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-componente","text":"S\u00f3 adicionar o arquivo HDL ( .vhd ou .v verilog) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso : File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente.","title":"Criando componente"},{"location":"Tutorial-FPGA-NIOS-IP/#files","text":"Na aba Files adicione o arquivo peripheral-LED.vhd : Files Syntesis Files add file peripheral-LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral-LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese.","title":"Files"},{"location":"Tutorial-FPGA-NIOS-IP/#signals-interfaces","text":"Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir :","title":"Signals &amp; Interfaces"},{"location":"Tutorial-FPGA-NIOS-IP/#finalizando","text":"Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC : Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus : tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral-LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd E edite para: add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-pd","text":"Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como : Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model","title":"Utilizando o componente no PD"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-toplevelvhd","text":"Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no topLevel.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o topLevel.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 .","title":"Utilizando o componente no topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS-IP/#firmware","text":"Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um novo BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral-LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m).","title":"Firmware"},{"location":"Tutorial-FPGA-NIOS-IP/#executando","text":"Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1.","title":"Executando"},{"location":"Tutorial-FPGA-NIOS-IP/#simulando","text":"Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem : 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado.","title":"Simulando"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-o-bsp","text":"Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!!","title":"Configurando o bsp"},{"location":"Tutorial-FPGA-NIOS-IP/#modelsim","text":"No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Altera. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo.","title":"ModelSim"},{"location":"Tutorial-FPGA-NIOS-IP/#entrega-3","text":"Siga para a terceira entrega: Entega 3","title":"Entrega 3"},{"location":"Tutorial-FPGA-NIOS/","text":"Tutorial 2 - FPGA - NIOS \u00b6 Nesse tutorial iremos criar e customizar um soft processor (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado. Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-NIOS Soft processor \u00b6 Projetos em HDL n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 algo imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um c\u00f3digo em HDL: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA,..) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente/ open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Existem SoCs que n\u00e3o s\u00e3o implementados em FPGAs, mas ainda assim concentram uma s\u00e9rie de outros componentes em um \u00fanico chip, \u00e9 o caso dos SoCs utilizados em celulares. Esses dispositivos, muitas vezes utilizam SoCs que possuem al\u00e9m da parte de processamento, sistemas respons\u00e1veis pela comunica\u00e7\u00e3o pela: interface gr\u00e1fica; gest\u00e3o des c\u00e2meras; comunica\u00e7\u00e3o 4g; .... A Qualcomm \u00e9 uma das empresas lideres do setor com o dispositivo SnapDragon . Plataform Designer \u00b6 O Platform Designer era chamado de QSYS, ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela INtel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar Intellectual property cores (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Quer se aprofundar? Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer NIOS \u00b6 NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits e controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas a seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: Combinacional; Multiciclo; Estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Para maiores detalhes consulte o documento : Nios II Custom Instruction User Guide Criando um simples SoC \u00b6 Nesse etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta do projeto da Entrega-1 renomeando para Tutorial-FPGA-NIOS Abra essa nova pasta Tutorial-FPGA-NIOS no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos: On-Chip Memmory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Type: NIOS II/e Voc\u00ea deve obter algo similar a: Conectando Clock e Reset \u00b6 Os perif\u00e9ricos do Qsys s\u00e3o como sistemas independentes (pensem em cada bloco \u00e9 como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel muito mais superior. O Qsys ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 , conforme figura a seguir: Conectando barramento \u00b6 A Altera define dois tipos de barramento de dados para o Qsys: Avalon e AXI. O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Interface Specifications O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transforma uma forma de comunica\u00e7\u00e3o na outra. Em um futuro breve n\u00f3s iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Melhorando o entendimento do sistema. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado no MIPS harvard ele possui dois barramentos, um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware, s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a principio compartilhada entre o dado e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Vamos portanto conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e vamos conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir: Mapa de mem\u00f3ria \u00b6 Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. S\u00e3o duas as maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map Configurando NIOS \u00b6 Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a aba: Parameters . Em Vector configure : Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos). Export \u00b6 A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados para fora do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal. Finalizando \u00b6 Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosHello.qsys na pasta do projeto e clique em Generate HDL , para o Qsys gerar o projeto. Utilizando o componente \u00b6 Ainda no Qsys, clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Anote isso, iremos utilizar na pr\u00f3xima etapa! component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; u0 : component niosHello port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no Qsys possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces: Finalizando \u00b6 Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foi configurado. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no Qsys: No Quartus: Project Add/remove files in project e adicione o arquivo: niosHello/synthesis/niosHello.qip Resultando em: Modificando o topLevel.vhd \u00b6 Agora \u00e9 necess\u00e1rio modificar o topLevel.vhd para incluir o componente niosHello rec\u00e9m criado. Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). library IEEE ; use IEEE.std_logic_1164. all ; entity topLevel is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity topLevel ; architecture rtl of topLevel is component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; begin u0 : component niosHello port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Compilando e gravando Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA. Programando o NIOS - Soft processor \u00b6 Agora que temos o projeto criado e a FPGA gravada com o novo hardware, que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H ardware A bstraction L ayer - HAL) ou como a Intel chama: B oard S uport P ackage (BSP), na qual extrai-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no NIOS II - Eclipse , dois projetos ser\u00e3o criados: Um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT Criando o projeto \u00b6 No Quartus Tools NIOS II - Eclipse No NIOS II - Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosHello.sopc Esse arquivo \u00e9 criado pelo Qsys quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name: niosHello Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosHello : firmware a ser embarcado niosHello_bsp : Board support package para o firmware Analisando e configurando o bsp \u00b6 No Project Explorer do Eclipse, clique com o bot\u00e3o direito no: Project Explorer niosHello_bsp NIOS II bsp Editor Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas : sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA). Jtag-UART small driver \u00b6 Note que no nosso projeto no QSYS o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver Gerando o bsp \u00b6 Toda vez que o bsp for editado ou o hardware alterado (qsys) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosHello_bsp NIOS II Generate BSP Embarcando! \u00b6 Com o bsp editado abra agora a pasta niosHello e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console : Blink LED \u00b6 Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS! Entrega 2 \u00b6 Siga para a Entrega 2","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#tutorial-2-fpga-nios","text":"Nesse tutorial iremos criar e customizar um soft processor (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado.","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-NIOS","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-NIOS/#soft-processor","text":"Projetos em HDL n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 algo imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um c\u00f3digo em HDL: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA,..) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente/ open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Existem SoCs que n\u00e3o s\u00e3o implementados em FPGAs, mas ainda assim concentram uma s\u00e9rie de outros componentes em um \u00fanico chip, \u00e9 o caso dos SoCs utilizados em celulares. Esses dispositivos, muitas vezes utilizam SoCs que possuem al\u00e9m da parte de processamento, sistemas respons\u00e1veis pela comunica\u00e7\u00e3o pela: interface gr\u00e1fica; gest\u00e3o des c\u00e2meras; comunica\u00e7\u00e3o 4g; .... A Qualcomm \u00e9 uma das empresas lideres do setor com o dispositivo SnapDragon .","title":"Soft processor"},{"location":"Tutorial-FPGA-NIOS/#plataform-designer","text":"O Platform Designer era chamado de QSYS, ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela INtel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar Intellectual property cores (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Quer se aprofundar? Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer","title":"Plataform Designer"},{"location":"Tutorial-FPGA-NIOS/#nios","text":"NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits e controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas a seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: Combinacional; Multiciclo; Estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Para maiores detalhes consulte o documento : Nios II Custom Instruction User Guide","title":"NIOS"},{"location":"Tutorial-FPGA-NIOS/#criando-um-simples-soc","text":"Nesse etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta do projeto da Entrega-1 renomeando para Tutorial-FPGA-NIOS Abra essa nova pasta Tutorial-FPGA-NIOS no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos: On-Chip Memmory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Type: NIOS II/e Voc\u00ea deve obter algo similar a:","title":"Criando um simples SoC"},{"location":"Tutorial-FPGA-NIOS/#conectando-clock-e-reset","text":"Os perif\u00e9ricos do Qsys s\u00e3o como sistemas independentes (pensem em cada bloco \u00e9 como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel muito mais superior. O Qsys ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 , conforme figura a seguir:","title":"Conectando Clock e Reset"},{"location":"Tutorial-FPGA-NIOS/#conectando-barramento","text":"A Altera define dois tipos de barramento de dados para o Qsys: Avalon e AXI. O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Interface Specifications O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transforma uma forma de comunica\u00e7\u00e3o na outra. Em um futuro breve n\u00f3s iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Melhorando o entendimento do sistema. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado no MIPS harvard ele possui dois barramentos, um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware, s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a principio compartilhada entre o dado e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Vamos portanto conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e vamos conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir:","title":"Conectando barramento"},{"location":"Tutorial-FPGA-NIOS/#mapa-de-memoria","text":"Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. S\u00e3o duas as maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map","title":"Mapa de mem\u00f3ria"},{"location":"Tutorial-FPGA-NIOS/#configurando-nios","text":"Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a aba: Parameters . Em Vector configure : Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos).","title":"Configurando NIOS"},{"location":"Tutorial-FPGA-NIOS/#export","text":"A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados para fora do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal.","title":"Export"},{"location":"Tutorial-FPGA-NIOS/#finalizando","text":"Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosHello.qsys na pasta do projeto e clique em Generate HDL , para o Qsys gerar o projeto.","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#utilizando-o-componente","text":"Ainda no Qsys, clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Anote isso, iremos utilizar na pr\u00f3xima etapa! component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; u0 : component niosHello port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no Qsys possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces:","title":"Utilizando o componente"},{"location":"Tutorial-FPGA-NIOS/#finalizando_1","text":"Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foi configurado. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no Qsys: No Quartus: Project Add/remove files in project e adicione o arquivo: niosHello/synthesis/niosHello.qip Resultando em:","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#modificando-o-toplevelvhd","text":"Agora \u00e9 necess\u00e1rio modificar o topLevel.vhd para incluir o componente niosHello rec\u00e9m criado. Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). library IEEE ; use IEEE.std_logic_1164. all ; entity topLevel is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity topLevel ; architecture rtl of topLevel is component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; begin u0 : component niosHello port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Compilando e gravando Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA.","title":"Modificando o topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS/#programando-o-nios-soft-processor","text":"Agora que temos o projeto criado e a FPGA gravada com o novo hardware, que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H ardware A bstraction L ayer - HAL) ou como a Intel chama: B oard S uport P ackage (BSP), na qual extrai-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no NIOS II - Eclipse , dois projetos ser\u00e3o criados: Um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT","title":"Programando o NIOS - Soft processor"},{"location":"Tutorial-FPGA-NIOS/#criando-o-projeto","text":"No Quartus Tools NIOS II - Eclipse No NIOS II - Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosHello.sopc Esse arquivo \u00e9 criado pelo Qsys quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name: niosHello Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosHello : firmware a ser embarcado niosHello_bsp : Board support package para o firmware","title":"Criando o projeto"},{"location":"Tutorial-FPGA-NIOS/#analisando-e-configurando-o-bsp","text":"No Project Explorer do Eclipse, clique com o bot\u00e3o direito no: Project Explorer niosHello_bsp NIOS II bsp Editor Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas : sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA).","title":"Analisando e configurando o bsp"},{"location":"Tutorial-FPGA-NIOS/#jtag-uart-small-driver","text":"Note que no nosso projeto no QSYS o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver","title":"Jtag-UART small driver"},{"location":"Tutorial-FPGA-NIOS/#gerando-o-bsp","text":"Toda vez que o bsp for editado ou o hardware alterado (qsys) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosHello_bsp NIOS II Generate BSP","title":"Gerando o bsp"},{"location":"Tutorial-FPGA-NIOS/#embarcando","text":"Com o bsp editado abra agora a pasta niosHello e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console :","title":"Embarcando!"},{"location":"Tutorial-FPGA-NIOS/#blink-led","text":"Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS!","title":"Blink LED"},{"location":"Tutorial-FPGA-NIOS/#entrega-2","text":"Siga para a Entrega 2","title":"Entrega 2"},{"location":"Tutorial-FPGA-RTL/","text":"Tutorial 1 - FPGA - RTL \u00b6 Nessa primeira etapa do projeto iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. Iremos passar por todo o processo de desenvolvimento de um projeto em FPGA, desde sua cria\u00e7\u00e3o at\u00e9 a valida\u00e7\u00e3o no HW. Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-RTL Quartus \u00b6 Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como RTL_Blink_LED Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA : Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Outra refer\u00eancia Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf Criando o topLevel \u00b6 TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: RTL_Blink_LED.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity RTL_Blink_LED is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity RTL_Blink_LED ; architecture rtl of RTL_Blink_LED is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim por ora. Configurando o topLevel \u00b6 No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar. Verificando \u00b6 Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo. I/Os \u00b6 Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes. Pin Assigment \u00b6 Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel. LEDs \u00b6 No manual da placa (p\u00e1gina 22( temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: Essa tabela define o sinal (que voc\u00ea pode dar qualquer nome), o pino na FPGA na qual est\u00e1 conectado, uma breve descri\u00e7\u00e3o e o n\u00edvel el\u00e9trico de sinal na qual o pino deve ser configurado. Note que a placa DE10-Standard possui 10 LEDs conectados a FPGA. Clocks \u00b6 Tamb\u00e9m temos a defini\u00e7\u00e3o do clock (sec. 3.5, manual da placa): Note que existem 5 diferentes clocks que podem ser utilizado, os FPGA_CLKx_50 s\u00e3o clocks de 50Mhz conectados a FPGA e os HPS_CLKx_25 s\u00e3o sinais de clocks conectados exclusivamente ao ARM (HPS). Como estamos desenvolvendo na FPGA e n\u00e3o temos ainda nenhum requisito de performance, podemos escolher qualquer pino de clock FPGA_CLKx_50 . Vamos usar (escolhido aleat\u00f3rio) o pino CLOCK3_50 . Dom\u00ednios de Clock Tenha em mente que a FPGA trabalha com diferentes dom\u00ednios de clock, quando o projeto possui temporaliza\u00e7\u00e3o cr\u00edtica, essa escolha n\u00e3o pode ser casual. Inserindo no Quartus \u00b6 Agora que temos os pinos referentes aos sinais da FPGA, devemos inserir essa informa\u00e7\u00e3o no Quartus. Existem duas maneiras de fazermos isso: Pin Planner Ferramenta gr\u00e1fica e interativa Assigments Pin Planer Assigments Editor Maneira mais completa e com maior flexibilidade Assigments Assigments Editor Iremos utilizar a princ\u00edpio o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do topLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Edite a coluna Location utilizando como refer\u00eancia a tabela anterior. Note que o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 \u00e9 o 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o Timing Requirements not met \u00b6 Note que ap\u00f3s compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes. Synopsys Design Constraints File \u00b6 Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : RTL_Blink_LED.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto. RTL Viewer \u00b6 RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em : Tools -> NetList Viewers -> RTL Viewer . Gravando \u00b6 Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra : Tools -> Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux . Exerc\u00edcios \u00b6 : F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade Entrega 1 \u00b6 Siga para a Entrega 1","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#tutorial-1-fpga-rtl","text":"Nessa primeira etapa do projeto iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. Iremos passar por todo o processo de desenvolvimento de um projeto em FPGA, desde sua cria\u00e7\u00e3o at\u00e9 a valida\u00e7\u00e3o no HW.","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-RTL","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-RTL/#quartus","text":"Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como RTL_Blink_LED Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA : Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Outra refer\u00eancia Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf","title":"Quartus"},{"location":"Tutorial-FPGA-RTL/#criando-o-toplevel","text":"TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: RTL_Blink_LED.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity RTL_Blink_LED is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity RTL_Blink_LED ; architecture rtl of RTL_Blink_LED is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim por ora.","title":"Criando o topLevel"},{"location":"Tutorial-FPGA-RTL/#configurando-o-toplevel","text":"No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar.","title":"Configurando o topLevel"},{"location":"Tutorial-FPGA-RTL/#verificando","text":"Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo.","title":"Verificando"},{"location":"Tutorial-FPGA-RTL/#ios","text":"Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes.","title":"I/Os"},{"location":"Tutorial-FPGA-RTL/#pin-assigment","text":"Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel.","title":"Pin Assigment"},{"location":"Tutorial-FPGA-RTL/#leds","text":"No manual da placa (p\u00e1gina 22( temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: Essa tabela define o sinal (que voc\u00ea pode dar qualquer nome), o pino na FPGA na qual est\u00e1 conectado, uma breve descri\u00e7\u00e3o e o n\u00edvel el\u00e9trico de sinal na qual o pino deve ser configurado. Note que a placa DE10-Standard possui 10 LEDs conectados a FPGA.","title":"LEDs"},{"location":"Tutorial-FPGA-RTL/#clocks","text":"Tamb\u00e9m temos a defini\u00e7\u00e3o do clock (sec. 3.5, manual da placa): Note que existem 5 diferentes clocks que podem ser utilizado, os FPGA_CLKx_50 s\u00e3o clocks de 50Mhz conectados a FPGA e os HPS_CLKx_25 s\u00e3o sinais de clocks conectados exclusivamente ao ARM (HPS). Como estamos desenvolvendo na FPGA e n\u00e3o temos ainda nenhum requisito de performance, podemos escolher qualquer pino de clock FPGA_CLKx_50 . Vamos usar (escolhido aleat\u00f3rio) o pino CLOCK3_50 . Dom\u00ednios de Clock Tenha em mente que a FPGA trabalha com diferentes dom\u00ednios de clock, quando o projeto possui temporaliza\u00e7\u00e3o cr\u00edtica, essa escolha n\u00e3o pode ser casual.","title":"Clocks"},{"location":"Tutorial-FPGA-RTL/#inserindo-no-quartus","text":"Agora que temos os pinos referentes aos sinais da FPGA, devemos inserir essa informa\u00e7\u00e3o no Quartus. Existem duas maneiras de fazermos isso: Pin Planner Ferramenta gr\u00e1fica e interativa Assigments Pin Planer Assigments Editor Maneira mais completa e com maior flexibilidade Assigments Assigments Editor Iremos utilizar a princ\u00edpio o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do topLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Edite a coluna Location utilizando como refer\u00eancia a tabela anterior. Note que o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 \u00e9 o 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o","title":"Inserindo no Quartus"},{"location":"Tutorial-FPGA-RTL/#timing-requirements-not-met","text":"Note que ap\u00f3s compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes.","title":"Timing Requirements not met"},{"location":"Tutorial-FPGA-RTL/#synopsys-design-constraints-file","text":"Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : RTL_Blink_LED.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto.","title":"Synopsys Design Constraints File"},{"location":"Tutorial-FPGA-RTL/#rtl-viewer","text":"RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em : Tools -> NetList Viewers -> RTL Viewer .","title":"RTL Viewer"},{"location":"Tutorial-FPGA-RTL/#gravando","text":"Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra : Tools -> Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux .","title":"Gravando"},{"location":"Tutorial-FPGA-RTL/#exercicios","text":": F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade","title":"Exerc\u00edcios"},{"location":"Tutorial-FPGA-RTL/#entrega-1","text":"Siga para a Entrega 1","title":"Entrega 1"},{"location":"Tutorial-HPS-Acessando-Target/","text":"Acessando e controlando o target \u00b6 Possu\u00edmos algumas formas de acessar e utilizar esse sistema: Via terminal UART Via terminal ssh Se o linux possuir interface gr\u00e1fica, podemos usar um teclado e mouse. Interface gr\u00e1fica via ssh UART \u00b6 O linux no HPS \u00e9 geralmente configurado (no bootloader) para possuir um terminal redirecionado para uma porta UART, essa porta UART \u00e9 dispon\u00edvel via FTDI em um dos USBs da placa (o que estiver escrito UART) e ent\u00e3o pode ser acessado como uma UART. Para isso h\u00e1 uma porta USB espec\u00edfica (UART). Uma vez conectada a porta USB ao PC e energizada a placa, podemos verificar em qual device a porta serial foi mapeada (no host ): $ demsg | tail [ 95158 .497894 ] ftdi_sio 1 -1.1:1.0: device disconnected [ 95161 .649187 ] usb 1 -1.1: new full-speed USB device number 22 using xhci_hcd [ 95161 .748948 ] ftdi_sio 1 -1.1:1.0: FTDI USB Serial Device converter detected [ 95161 .749067 ] usb 1 -1.1: Detected FT232RL [ 95161 .756092 ] usb 1 -1.1: FTDI USB Serial Device converter now attached to ttyUSB0 No log, verificamos que um dispositivo FTDI USB Serial Device foi conectado a ttyUSB0 . E ent\u00e3o podemos abrir o terminal por qualquer programa de porta serial (PUTTY, ...), nesse exemplo utilizaremos o programa screen . $ screen /dev/ttyUSB0 115200 ,cs8 Para melhoramos a interface com o screen crie um arquivo ~/.screenrc e adicione o seguinte conte\u00fado a ele # Enable mouse scrolling and scroll bar history scrolling termcapinfo xterm* ti@:te@ talvez seja necess\u00e1rio instalar o screen. Feito isso, reinicie o target (religando a energia) para termos acesso a todo o log de inicializa\u00e7\u00e3o. notem que no meu caso o nome atribuido ao USB-UART foi o /dev/ttyUSB0 , isso pode mudar no PC de voc\u00eas Uma vez conectado, agora temos acesso a todas as funcionalidades do linux como um bash normal. Na verdade o terminal j\u00e1 \u00e9 configurado para funcionar j\u00e1 no boot, ou seja, conseguimos ter acesso as informa\u00e7\u00f5es do u-boot. Kernel e porta serial \u00b6 Como o kernel sabe qual porta ele deve utilizar para imprimir o log e usar como terminal ? Esse par\u00e2metro \u00e9 passado pelo u-boot para o kernel via o Device Tree : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-1.0\", \"snps,dw-apb-uart\"; reg = < 0xFFC02000 0x00001000 >; interrupt-parent = < &hps_0_arm_gic_0 >; interrupts = < 0 162 4 >; reg-io-width = < 4 >; reg-shift = < 2 >; clock-frequency = < 100000000 >; }; E ent\u00e3o passado com o argumento para o kernel: bootargs = \"console=ttyS0,115200\"; (esse exemplo n\u00e3o \u00e9 da nossa FPGA)","title":"Acessando e controlando o target"},{"location":"Tutorial-HPS-Acessando-Target/#acessando-e-controlando-o-target","text":"Possu\u00edmos algumas formas de acessar e utilizar esse sistema: Via terminal UART Via terminal ssh Se o linux possuir interface gr\u00e1fica, podemos usar um teclado e mouse. Interface gr\u00e1fica via ssh","title":"Acessando e controlando o target"},{"location":"Tutorial-HPS-Acessando-Target/#uart","text":"O linux no HPS \u00e9 geralmente configurado (no bootloader) para possuir um terminal redirecionado para uma porta UART, essa porta UART \u00e9 dispon\u00edvel via FTDI em um dos USBs da placa (o que estiver escrito UART) e ent\u00e3o pode ser acessado como uma UART. Para isso h\u00e1 uma porta USB espec\u00edfica (UART). Uma vez conectada a porta USB ao PC e energizada a placa, podemos verificar em qual device a porta serial foi mapeada (no host ): $ demsg | tail [ 95158 .497894 ] ftdi_sio 1 -1.1:1.0: device disconnected [ 95161 .649187 ] usb 1 -1.1: new full-speed USB device number 22 using xhci_hcd [ 95161 .748948 ] ftdi_sio 1 -1.1:1.0: FTDI USB Serial Device converter detected [ 95161 .749067 ] usb 1 -1.1: Detected FT232RL [ 95161 .756092 ] usb 1 -1.1: FTDI USB Serial Device converter now attached to ttyUSB0 No log, verificamos que um dispositivo FTDI USB Serial Device foi conectado a ttyUSB0 . E ent\u00e3o podemos abrir o terminal por qualquer programa de porta serial (PUTTY, ...), nesse exemplo utilizaremos o programa screen . $ screen /dev/ttyUSB0 115200 ,cs8 Para melhoramos a interface com o screen crie um arquivo ~/.screenrc e adicione o seguinte conte\u00fado a ele # Enable mouse scrolling and scroll bar history scrolling termcapinfo xterm* ti@:te@ talvez seja necess\u00e1rio instalar o screen. Feito isso, reinicie o target (religando a energia) para termos acesso a todo o log de inicializa\u00e7\u00e3o. notem que no meu caso o nome atribuido ao USB-UART foi o /dev/ttyUSB0 , isso pode mudar no PC de voc\u00eas Uma vez conectado, agora temos acesso a todas as funcionalidades do linux como um bash normal. Na verdade o terminal j\u00e1 \u00e9 configurado para funcionar j\u00e1 no boot, ou seja, conseguimos ter acesso as informa\u00e7\u00f5es do u-boot.","title":"UART"},{"location":"Tutorial-HPS-Acessando-Target/#kernel-e-porta-serial","text":"Como o kernel sabe qual porta ele deve utilizar para imprimir o log e usar como terminal ? Esse par\u00e2metro \u00e9 passado pelo u-boot para o kernel via o Device Tree : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-1.0\", \"snps,dw-apb-uart\"; reg = < 0xFFC02000 0x00001000 >; interrupt-parent = < &hps_0_arm_gic_0 >; interrupts = < 0 162 4 >; reg-io-width = < 4 >; reg-shift = < 2 >; clock-frequency = < 100000000 >; }; E ent\u00e3o passado com o argumento para o kernel: bootargs = \"console=ttyS0,115200\"; (esse exemplo n\u00e3o \u00e9 da nossa FPGA)","title":"Kernel e porta serial"},{"location":"Tutorial-HPS-BlinkLED/","text":"Nesse tutorial iremos compilar um programa para o HPS (Arm Cortex A) que ser\u00e1 capaz de controlar os LEDs e ler os bot\u00f5es da placa que est\u00e3o conectados ao HPS. Note pelo diagrama anterior extra\u00eddo do manual do usu\u00e1rio, existem LEDs e bot\u00f5es conectados diretamente ao HPS, e outros conectados a FPGA. Duas s\u00e3o as poss\u00edveis abordagens para programarmos o HPS: baremetal \u00b6 Far\u00edamos um programa que seria executado no ARM HPS sem nenhum sistema operacional. Como detalhado no diagrama : ref: Altera Bare Metal User Guide Nessa maneira, a aplica\u00e7\u00e3o deve ser capaz de realizar toda a inicializa\u00e7\u00e3o de HW necess\u00e1ria para que o processador rode corretamente. Se a aplica\u00e7\u00e3o for executada sobre um sistema operacional, toda essa etapa \u00e9 de compila\u00e7\u00e3o \u00e9 responsabilidade do SO. Para isso, utiliza-se a IDE da ARM chamada de DS-5 Sistema operacional \u00b6 Duas s\u00e3o as op\u00e7\u00f5es: Real Time ou Linux (existe outros sistemas operacionais para ARM que n\u00e3o o linux: BSD,...), a escolha depender\u00e1 da aplica\u00e7\u00e3o. Com o uso de um sistema operacional a parte referente ao HW \u00e9 responsabilidade do kernel (ou dos desenvolvedores que est\u00e3o adequando o kernel ao HW, que \u00e9 o caso de voc\u00eas). Diversos s\u00e3o os ganhos de utilizar um sistema operacional do tipo Linux (as perdas tamb\u00e9m s\u00e3o grandes: maior ocupa\u00e7\u00e3o de mem\u00f3ria, maior lat\u00eancias,...) tais como: Device drivers Portabilidade Seguran\u00e7a Rede Linux \u00b6 Nesse tutorial iremos compilar um programa e executar no Linux e esse programa que ser\u00e1 executado no user space . Para isso iremos utilizar a toolchain definida no tutorial passado . Iremos utilizar como base o c\u00f3digo: Tutoriais/HPS-BlinkLED/main.c e crosscopilar esse c\u00f3digo para o nosso HPS. Iremos seguir as etapas a seguir: Instale o toolchain Grave o SDcard com a imagem padr\u00e3o fornecida Compile o c\u00f3digo Passe o c\u00f3digo para o HPS via SDCard Execute o linux no sistema emabarcado Conecte-se ao terminal do target (ssh ou terminal) Execute o c\u00f3digo no HPS e veja os LEDs piscarem ! Compilando \u00b6 Crie uma pasta para essa entrega, digamos: HPS-Hello , nela insira: um arquivo main.c com o conte\u00fado a seguir: #include <stdio.h> #include <unistd.h> #include <fcntl.h> #include <sys/mman.h> #include \"hwlib.h\" #include \"socal/socal.h\" #include \"socal/hps.h\" #include \"socal/alt_gpio.h\" #define HW_REGS_BASE ( ALT_STM_OFST ) #define HW_REGS_SPAN ( 0x04000000 ) #define HW_REGS_MASK ( HW_REGS_SPAN - 1 ) #define USER_IO_DIR (0x01000000) #define BIT_LED (0x01000000) #define BUTTON_MASK (0x02000000) int main ( int argc , char ** argv ) { void * virtual_base ; int fd ; uint32_t scan_input ; int i ; // map the address space for the LED registers into user space so we can interact with them. // we'll actually map in the entire CSR span of the HPS since we want to access various registers within that span if ( ( fd = open ( \"/dev/mem\" , ( O_RDWR | O_SYNC ) ) ) == - 1 ) { printf ( \"ERROR: could not open \\\" /dev/mem \\\" ... \\n \" ); return ( 1 ); } virtual_base = mmap ( NULL , HW_REGS_SPAN , ( PROT_READ | PROT_WRITE ), MAP_SHARED , fd , HW_REGS_BASE ); if ( virtual_base == MAP_FAILED ) { printf ( \"ERROR: mmap() failed... \\n \" ); close ( fd ); return ( 1 ); } // GPIO // gpio register absolut address // uint32_t * gpio1_swporta_ddr_addr = ( uint32_t * )( virtual_base + (( uint32_t )( ALT_GPIO1_SWPORTA_DDR_ADDR ) & ( uint32_t )( HW_REGS_MASK ))); uint32_t * gpio1_swporta_dr_addr = ( uint32_t * )( virtual_base + (( uint32_t )( ALT_GPIO1_SWPORTA_DR_ADDR ) & ( uint32_t )( HW_REGS_MASK ))); uint32_t * gpio1_porta_ext_addr = ( uint32_t * )( virtual_base + (( uint32_t )( ALT_GPIO1_EXT_PORTA_ADDR ) & ( uint32_t )( HW_REGS_MASK ) )); // initialize the pio controller // led: set the direction of the HPS GPIO1 bits attached to LEDs to output alt_setbits_word ( gpio1_swporta_ddr_addr , USER_IO_DIR ); printf ( \"led test \\r\\n \" ); printf ( \"the led flash 2 times \\r\\n \" ); for ( i = 0 ; i < 2 ; i ++ ) { alt_setbits_word ( gpio1_swporta_dr_addr , BIT_LED ); usleep ( 500 * 1000 ); alt_clrbits_word ( gpio1_swporta_dr_addr , BIT_LED ); usleep ( 500 * 1000 ); } printf ( \"user key test \\r\\n \" ); printf ( \"press key to control led \\r\\n \" ); while ( 1 ){ scan_input = alt_read_word ( gpio1_porta_ext_addr ); if ( ~ scan_input & BUTTON_MASK ) alt_setbits_word ( gpio1_swporta_dr_addr , BIT_LED ); else alt_clrbits_word ( gpio1_swporta_dr_addr , BIT_LED ); } // clean up our memory mapping and exit if ( munmap ( virtual_base , HW_REGS_SPAN ) != 0 ) { printf ( \"ERROR: munmap() failed... \\n \" ); close ( fd ); return ( 1 ); } close ( fd ); return ( 0 ); } um arquivo Makefile com o conte\u00fado a seguir: TARGET = hps_gpio ALT_DEVICE_FAMILY ?= soc_cv_av HWLIBS_ROOT = $( SOCEDS_HWLIB ) CFLAGS = -g -Wall -Werror -I $( HWLIBS_ROOT ) /include -I $( HWLIBS_ROOT ) /include/ $( ALT_DEVICE_FAMILY ) -D $( ALT_DEVICE_FAMILY ) LDFLAGS = -g -Wall -Werror CROSS_COMPILE = $( GCC_Linaro ) /arm-linux-gnueabihf- CC = $( CROSS_COMPILE ) gcc LD = $( CROSS_COMPILE ) gcc ARCH = arm .PHONY : build build : $( TARGET ) $(TARGET) : main . o $( LD ) $( LDFLAGS ) $^ -o $@ %.o : %. c $( CC ) $( CFLAGS ) -c $< -o $@ .PHONY : clean clean : rm -f $( TARGET ) *.a *.o *~ E compile o projeto: $ make Copiando para o target \u00b6 Com o cart\u00e3o de mem\u00f3ria ainda no host , copie o arquivo bin\u00e1rio: hps_gpio para a pasta: /root/ do cart\u00e3o de mem\u00f3ria. Sempre que manipular um dispositivo de mem\u00f3ria externo, ser\u00e1 necess\u00e1rio fazer um flush do cache para for\u00e7ar o linux alterar o dispositivo externo, caso contr\u00e1rio a altera\u00e7\u00e3o poder\u00e1 ficar s\u00f3 local ao PC. $ sync A fun\u00e7\u00e3o sync \u00e9 blocante, ficar\u00e1 travada enquanto o linux faz o flush dos dados. Executando no target \u00b6 Executar o linux no target Conectar host no target via terminal Fa\u00e7a login no linux via terminal (user: root, ps: 1234) e execute o arquivo compilado: $ /root/hps_gpio E veja os LEDs piscarem ! Na verdade os LEDs piscam 2 vezes e depois o c\u00f3digo fica verificando quando um bot\u00e3o (KEY2) \u00e9 pressionado. Cuidado para n\u00e3o apertar os bot\u00f5es do lado que s\u00e3o de reset ! Modificando o c\u00f3digo ! \u00b6 Fa\u00e7a o programa ler apenas duas vezes o bot\u00e3o, e depois disso termina a aplica\u00e7\u00e3o ! Entrega 4 \u00b6 Vamos melhorar esse nosso sistema de compila\u00e7\u00e3o e deploy ! Entrega 4","title":"Embarcados Avan\u00e7ados - FPGA RTL"},{"location":"Tutorial-HPS-BlinkLED/#baremetal","text":"Far\u00edamos um programa que seria executado no ARM HPS sem nenhum sistema operacional. Como detalhado no diagrama : ref: Altera Bare Metal User Guide Nessa maneira, a aplica\u00e7\u00e3o deve ser capaz de realizar toda a inicializa\u00e7\u00e3o de HW necess\u00e1ria para que o processador rode corretamente. Se a aplica\u00e7\u00e3o for executada sobre um sistema operacional, toda essa etapa \u00e9 de compila\u00e7\u00e3o \u00e9 responsabilidade do SO. Para isso, utiliza-se a IDE da ARM chamada de DS-5","title":"baremetal"},{"location":"Tutorial-HPS-BlinkLED/#sistema-operacional","text":"Duas s\u00e3o as op\u00e7\u00f5es: Real Time ou Linux (existe outros sistemas operacionais para ARM que n\u00e3o o linux: BSD,...), a escolha depender\u00e1 da aplica\u00e7\u00e3o. Com o uso de um sistema operacional a parte referente ao HW \u00e9 responsabilidade do kernel (ou dos desenvolvedores que est\u00e3o adequando o kernel ao HW, que \u00e9 o caso de voc\u00eas). Diversos s\u00e3o os ganhos de utilizar um sistema operacional do tipo Linux (as perdas tamb\u00e9m s\u00e3o grandes: maior ocupa\u00e7\u00e3o de mem\u00f3ria, maior lat\u00eancias,...) tais como: Device drivers Portabilidade Seguran\u00e7a Rede","title":"Sistema operacional"},{"location":"Tutorial-HPS-BlinkLED/#linux","text":"Nesse tutorial iremos compilar um programa e executar no Linux e esse programa que ser\u00e1 executado no user space . Para isso iremos utilizar a toolchain definida no tutorial passado . Iremos utilizar como base o c\u00f3digo: Tutoriais/HPS-BlinkLED/main.c e crosscopilar esse c\u00f3digo para o nosso HPS. Iremos seguir as etapas a seguir: Instale o toolchain Grave o SDcard com a imagem padr\u00e3o fornecida Compile o c\u00f3digo Passe o c\u00f3digo para o HPS via SDCard Execute o linux no sistema emabarcado Conecte-se ao terminal do target (ssh ou terminal) Execute o c\u00f3digo no HPS e veja os LEDs piscarem !","title":"Linux"},{"location":"Tutorial-HPS-BlinkLED/#compilando","text":"Crie uma pasta para essa entrega, digamos: HPS-Hello , nela insira: um arquivo main.c com o conte\u00fado a seguir: #include <stdio.h> #include <unistd.h> #include <fcntl.h> #include <sys/mman.h> #include \"hwlib.h\" #include \"socal/socal.h\" #include \"socal/hps.h\" #include \"socal/alt_gpio.h\" #define HW_REGS_BASE ( ALT_STM_OFST ) #define HW_REGS_SPAN ( 0x04000000 ) #define HW_REGS_MASK ( HW_REGS_SPAN - 1 ) #define USER_IO_DIR (0x01000000) #define BIT_LED (0x01000000) #define BUTTON_MASK (0x02000000) int main ( int argc , char ** argv ) { void * virtual_base ; int fd ; uint32_t scan_input ; int i ; // map the address space for the LED registers into user space so we can interact with them. // we'll actually map in the entire CSR span of the HPS since we want to access various registers within that span if ( ( fd = open ( \"/dev/mem\" , ( O_RDWR | O_SYNC ) ) ) == - 1 ) { printf ( \"ERROR: could not open \\\" /dev/mem \\\" ... \\n \" ); return ( 1 ); } virtual_base = mmap ( NULL , HW_REGS_SPAN , ( PROT_READ | PROT_WRITE ), MAP_SHARED , fd , HW_REGS_BASE ); if ( virtual_base == MAP_FAILED ) { printf ( \"ERROR: mmap() failed... \\n \" ); close ( fd ); return ( 1 ); } // GPIO // gpio register absolut address // uint32_t * gpio1_swporta_ddr_addr = ( uint32_t * )( virtual_base + (( uint32_t )( ALT_GPIO1_SWPORTA_DDR_ADDR ) & ( uint32_t )( HW_REGS_MASK ))); uint32_t * gpio1_swporta_dr_addr = ( uint32_t * )( virtual_base + (( uint32_t )( ALT_GPIO1_SWPORTA_DR_ADDR ) & ( uint32_t )( HW_REGS_MASK ))); uint32_t * gpio1_porta_ext_addr = ( uint32_t * )( virtual_base + (( uint32_t )( ALT_GPIO1_EXT_PORTA_ADDR ) & ( uint32_t )( HW_REGS_MASK ) )); // initialize the pio controller // led: set the direction of the HPS GPIO1 bits attached to LEDs to output alt_setbits_word ( gpio1_swporta_ddr_addr , USER_IO_DIR ); printf ( \"led test \\r\\n \" ); printf ( \"the led flash 2 times \\r\\n \" ); for ( i = 0 ; i < 2 ; i ++ ) { alt_setbits_word ( gpio1_swporta_dr_addr , BIT_LED ); usleep ( 500 * 1000 ); alt_clrbits_word ( gpio1_swporta_dr_addr , BIT_LED ); usleep ( 500 * 1000 ); } printf ( \"user key test \\r\\n \" ); printf ( \"press key to control led \\r\\n \" ); while ( 1 ){ scan_input = alt_read_word ( gpio1_porta_ext_addr ); if ( ~ scan_input & BUTTON_MASK ) alt_setbits_word ( gpio1_swporta_dr_addr , BIT_LED ); else alt_clrbits_word ( gpio1_swporta_dr_addr , BIT_LED ); } // clean up our memory mapping and exit if ( munmap ( virtual_base , HW_REGS_SPAN ) != 0 ) { printf ( \"ERROR: munmap() failed... \\n \" ); close ( fd ); return ( 1 ); } close ( fd ); return ( 0 ); } um arquivo Makefile com o conte\u00fado a seguir: TARGET = hps_gpio ALT_DEVICE_FAMILY ?= soc_cv_av HWLIBS_ROOT = $( SOCEDS_HWLIB ) CFLAGS = -g -Wall -Werror -I $( HWLIBS_ROOT ) /include -I $( HWLIBS_ROOT ) /include/ $( ALT_DEVICE_FAMILY ) -D $( ALT_DEVICE_FAMILY ) LDFLAGS = -g -Wall -Werror CROSS_COMPILE = $( GCC_Linaro ) /arm-linux-gnueabihf- CC = $( CROSS_COMPILE ) gcc LD = $( CROSS_COMPILE ) gcc ARCH = arm .PHONY : build build : $( TARGET ) $(TARGET) : main . o $( LD ) $( LDFLAGS ) $^ -o $@ %.o : %. c $( CC ) $( CFLAGS ) -c $< -o $@ .PHONY : clean clean : rm -f $( TARGET ) *.a *.o *~ E compile o projeto: $ make","title":"Compilando"},{"location":"Tutorial-HPS-BlinkLED/#copiando-para-o-target","text":"Com o cart\u00e3o de mem\u00f3ria ainda no host , copie o arquivo bin\u00e1rio: hps_gpio para a pasta: /root/ do cart\u00e3o de mem\u00f3ria. Sempre que manipular um dispositivo de mem\u00f3ria externo, ser\u00e1 necess\u00e1rio fazer um flush do cache para for\u00e7ar o linux alterar o dispositivo externo, caso contr\u00e1rio a altera\u00e7\u00e3o poder\u00e1 ficar s\u00f3 local ao PC. $ sync A fun\u00e7\u00e3o sync \u00e9 blocante, ficar\u00e1 travada enquanto o linux faz o flush dos dados.","title":"Copiando para o target"},{"location":"Tutorial-HPS-BlinkLED/#executando-no-target","text":"Executar o linux no target Conectar host no target via terminal Fa\u00e7a login no linux via terminal (user: root, ps: 1234) e execute o arquivo compilado: $ /root/hps_gpio E veja os LEDs piscarem ! Na verdade os LEDs piscam 2 vezes e depois o c\u00f3digo fica verificando quando um bot\u00e3o (KEY2) \u00e9 pressionado. Cuidado para n\u00e3o apertar os bot\u00f5es do lado que s\u00e3o de reset !","title":"Executando no target"},{"location":"Tutorial-HPS-BlinkLED/#modificando-o-codigo","text":"Fa\u00e7a o programa ler apenas duas vezes o bot\u00e3o, e depois disso termina a aplica\u00e7\u00e3o !","title":"Modificando o c\u00f3digo !"},{"location":"Tutorial-HPS-BlinkLED/#entrega-4","text":"Vamos melhorar esse nosso sistema de compila\u00e7\u00e3o e deploy ! Entrega 4","title":"Entrega 4"},{"location":"Tutorial-HPS-BuildSystem/","text":"Ferramental \u00b6 Vamos instalar o ferramental (compiladores) que ser\u00e1 utilizado para compilar o kernel e o filesystem. Deveremos instalar o socdes e o linaro-gcc . Intel SOCDES \u00b6 Voc\u00ea ir\u00e1 precisar ter o software instalado (mesmas vers\u00f5es!): - Quartus - Intel SoC FPGA Embedded Development Suite Vamos precisar inserir no path do bash refer\u00eancia para uma s\u00e9rie de softwares a serem usados, modifique seu .bashrc inserindo: Ao fazer o download do soced deve-se verificar para ser a mesma vers\u00e3o do Quartus. export ALTERAPATH = ~/intelFPGA/18.1/ export PATH = $PATH : ${ ALTERAPATH } /quartus/bin export PATH = $PATH : ${ ALTERAPATH } /modelsim_ase/linuxaloem/ export PATH = $PATH : ${ ALTERAPATH } /quartus/sopc_builder/bin/ export PATH = $PATH : ${ ALTERAPATH } /embedded/host_tools/altera/preloadergen/ export PATH = $PATH : ${ ALTERAPATH } /quartus/embedded/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/ export SOCEDS_HWLIB = ${ ALTERAPATH } /embedded/ip/altera/hps/altera_hps/hwlib/ Note Lembre de verificar se o ALTERAPATH desse exemplo \u00e9 o caminho correto da instala\u00e7\u00e3o do Quartus outros bashs Se estiver usando outro bash (zsh/ fish) ser\u00e1 necess\u00e1rio editar o arquivo de configura\u00e7\u00e3o referente. Testando \u00b6 Para testar, digite no terminal (ap\u00f3s abrir uma nova aba, ou executar source ~/.bashrc ): $ nios2_command_shell.sh ------------------------------------------------ Altera Nios2 Command Shell [ GCC 4 ] Version 16 .1, Build 196 ------------------------------------------------ $ exit Note Isso s\u00f3 testa uma parte da instala\u00e7\u00e3o (soceds) GCC toolchain \u00b6 Iremos utilizar o GCC cross compile fornecido pelo Linaro, esse mesmo GCC ser\u00e1 utilizado para compilar o Kernel, gerar o file system e compilar os programas que executar\u00e3o no Linux. Para facilitar a organiza\u00e7\u00e3o, iremos manter o toolchain na pasta ~/work/ . $ mkdir ~/work/ $ cd ~/work $ wget https://releases.linaro.org/components/toolchain/binaries/7.3-2018.05/arm-linux-gnueabihf/gcc-linaro-7.3.1-2018.05-i686_arm-linux-gnueabihf.tar.xz $ tar xvf gcc-linaro-7.3.1-2018.05-i686_arm-linux-gnueabihf.tar.xz De uma olhada na pasta rec\u00e9m extra\u00edda: $ cd gcc-linaro-7.3.1-2018.05-i686_arm-linux-gnueabihf $ tree -L 1 ... + arm-linux-gnueabihf + bin + arm-linux-gnueabihf-addr2line + arm-linux-gnueabihf-ar + ... + arm-linux-gnueabihf-c++ + arm-linux-gnueabihf-g++ + arm-linux-gnueabihf-gcc + include + lib + libexec + share Temos todas as ferramentas necess\u00e1rias para compilar e linkar c\u00f3digos em C e C++ para o ARM. Note que no path do gcc temos o prefixo : gnueabihf . Pesquisa Qual a diferen\u00e7a entre eabi e hf Criando um atalho no bash \u00b6 Vamos criar um atalho para essa pasta no bash. Edite o arquivo ~/.bashrc para incluir a pasta ~/work/gcc-linaro.../bin/ na vari\u00e1vel do sistema: GCC_Linaro . # GCC Linaro on path $ export GCC_Linaro = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf/bin Note Edite o comando para a pasta correta de onde Linaro foi extra\u00eddo: /home/... Agora temos um atalho para o gcc-arm, vamos testar : $ $GCC_Linaro /arm-linux-gnueabihf-gcc -v ... gcc version 7 .2.1 20171011 ( Linaro GCC 7 .2-2017.11 )","title":"Ferramental"},{"location":"Tutorial-HPS-BuildSystem/#ferramental","text":"Vamos instalar o ferramental (compiladores) que ser\u00e1 utilizado para compilar o kernel e o filesystem. Deveremos instalar o socdes e o linaro-gcc .","title":"Ferramental"},{"location":"Tutorial-HPS-BuildSystem/#intel-socdes","text":"Voc\u00ea ir\u00e1 precisar ter o software instalado (mesmas vers\u00f5es!): - Quartus - Intel SoC FPGA Embedded Development Suite Vamos precisar inserir no path do bash refer\u00eancia para uma s\u00e9rie de softwares a serem usados, modifique seu .bashrc inserindo: Ao fazer o download do soced deve-se verificar para ser a mesma vers\u00e3o do Quartus. export ALTERAPATH = ~/intelFPGA/18.1/ export PATH = $PATH : ${ ALTERAPATH } /quartus/bin export PATH = $PATH : ${ ALTERAPATH } /modelsim_ase/linuxaloem/ export PATH = $PATH : ${ ALTERAPATH } /quartus/sopc_builder/bin/ export PATH = $PATH : ${ ALTERAPATH } /embedded/host_tools/altera/preloadergen/ export PATH = $PATH : ${ ALTERAPATH } /quartus/embedded/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/ export SOCEDS_HWLIB = ${ ALTERAPATH } /embedded/ip/altera/hps/altera_hps/hwlib/ Note Lembre de verificar se o ALTERAPATH desse exemplo \u00e9 o caminho correto da instala\u00e7\u00e3o do Quartus outros bashs Se estiver usando outro bash (zsh/ fish) ser\u00e1 necess\u00e1rio editar o arquivo de configura\u00e7\u00e3o referente.","title":"Intel SOCDES"},{"location":"Tutorial-HPS-BuildSystem/#testando","text":"Para testar, digite no terminal (ap\u00f3s abrir uma nova aba, ou executar source ~/.bashrc ): $ nios2_command_shell.sh ------------------------------------------------ Altera Nios2 Command Shell [ GCC 4 ] Version 16 .1, Build 196 ------------------------------------------------ $ exit Note Isso s\u00f3 testa uma parte da instala\u00e7\u00e3o (soceds)","title":"Testando"},{"location":"Tutorial-HPS-BuildSystem/#gcc-toolchain","text":"Iremos utilizar o GCC cross compile fornecido pelo Linaro, esse mesmo GCC ser\u00e1 utilizado para compilar o Kernel, gerar o file system e compilar os programas que executar\u00e3o no Linux. Para facilitar a organiza\u00e7\u00e3o, iremos manter o toolchain na pasta ~/work/ . $ mkdir ~/work/ $ cd ~/work $ wget https://releases.linaro.org/components/toolchain/binaries/7.3-2018.05/arm-linux-gnueabihf/gcc-linaro-7.3.1-2018.05-i686_arm-linux-gnueabihf.tar.xz $ tar xvf gcc-linaro-7.3.1-2018.05-i686_arm-linux-gnueabihf.tar.xz De uma olhada na pasta rec\u00e9m extra\u00edda: $ cd gcc-linaro-7.3.1-2018.05-i686_arm-linux-gnueabihf $ tree -L 1 ... + arm-linux-gnueabihf + bin + arm-linux-gnueabihf-addr2line + arm-linux-gnueabihf-ar + ... + arm-linux-gnueabihf-c++ + arm-linux-gnueabihf-g++ + arm-linux-gnueabihf-gcc + include + lib + libexec + share Temos todas as ferramentas necess\u00e1rias para compilar e linkar c\u00f3digos em C e C++ para o ARM. Note que no path do gcc temos o prefixo : gnueabihf . Pesquisa Qual a diferen\u00e7a entre eabi e hf","title":"GCC toolchain"},{"location":"Tutorial-HPS-BuildSystem/#criando-um-atalho-no-bash","text":"Vamos criar um atalho para essa pasta no bash. Edite o arquivo ~/.bashrc para incluir a pasta ~/work/gcc-linaro.../bin/ na vari\u00e1vel do sistema: GCC_Linaro . # GCC Linaro on path $ export GCC_Linaro = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf/bin Note Edite o comando para a pasta correta de onde Linaro foi extra\u00eddo: /home/... Agora temos um atalho para o gcc-arm, vamos testar : $ $GCC_Linaro /arm-linux-gnueabihf-gcc -v ... gcc version 7 .2.1 20171011 ( Linaro GCC 7 .2-2017.11 )","title":"Criando um atalho no bash"},{"location":"Tutorial-HPS-FileSystem-buildroot/","text":"Buildroot \u00b6 Ferramentas e configura\u00e7\u00f5es necess\u00e1rias para compilarmos um projeto (hardware e software) para o HPS. Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system https://en.wikipedia.org/wiki/Buildroot Iremos utilizar o buildroot para gerar o filesystem ( /bin , /etc , ...) do nosso sistema embarcado. No buildroot teremos a op\u00e7\u00e3o de configura\u00e7\u00e3o de quais softwares queremos no dispositivo. Por exemplo, se desejarmos acessar o HPS via ssh, teremos que no buildroot adicionar um ssh server para ser compilado e adicionado ao filesystem e executado no boot. O buildroot \u00e9 uma alternativa a outro projeto bem conhecido: Yocto. O v\u00eddeo a seguir s\u00e3o dois desenvolvedores, um de cada projeto, fazendo a compara\u00e7\u00e3o entre as duas ferramentas : https://www.youtube.com/watch?v=13LZ0szWSVg O Yocto tem um problema de n\u00e3o funcionar em vers\u00f5es mais recentes do Ubuntu/Fedora, por isso a escolha pelo buildroot. Mas \u00e9 prov\u00e1vel que tenhamos que usar o yocto em um outro projeto ! buildroot \u00b6 Ler getting Started: https://buildroot.org/downloads/manual/manual.html#_getting_started Primeiramente devemos fazer o download do buildroot : $ git clone https://github.com/buildroot/buildroot ~/work/buildroot $ cd ~/work/buildroot/ O buildroot possui uma ferramenta de configura\u00e7\u00e3o similar ao do kernel do linux (nconfig) iremos utilizar-la para configurar o filesystem assim como quais programas ser\u00e3o compilados e inseridos no /root/ . Lembre que j\u00e1 possu\u00edmos um toolchain (o que compilamos o kernel) na pasta ~/work/ , iremos utilizar para a compila\u00e7\u00e3o de todos os programas que iremos carregar no embarcado. O buildroot tem a op\u00e7\u00e3o de fazer o download do toolchain (ele tamb\u00e9m pode compilar o kernel e gerar o uboot, \u00e9 uma ferramenta bem completa), mas dessa vez iremos utilizar o que j\u00e1 temos (para manter a compatibilidade). Configurando \u00b6 Na pasta do buildroot clonada, execute o seguinte comando: $ make ARCH = arm nconfig Ele ir\u00e1 abrir uma tela de configura\u00e7\u00e3o : para voltar para essa tela, basta aperta duas vezes a tecla ESC 1. Target Options \u00b6 A primeira parte que iremos configurar \u00e9 o alvo da gera\u00e7\u00e3o do filesystem ( Target options ), devemos informar para o buildroot que ele est\u00e1 gerando arquivos para um ARM e indicar algumas op\u00e7\u00f5es do nosso compilador. Para isso: Menu principal -> Target Options Target Architecture: ARM (little endian). Essa op\u00e7\u00e3o j\u00e1 deve estar certa pois passamos via a chamada do make (make ARCH=ARM ...) Target Architecture Variant: cortex-A9 Enable NEON SIMD extension support Enable VFP extension support Floating point strategy: NEON https://developer.arm.com/technologies/neon Target ABI: EABIhf Indicamos ao buildroot que nossa arquitetura possui ponto flutuante em HW. 2. Build options \u00b6 Deixe padr\u00e3o 3. Toolchain \u00b6 Vamos indicar agora para o buildroot qual toolchain que ele deve utilizar e suas configura\u00e7\u00f5es : Menu principal -> Toolchain Toolchain type: External toolchain o buildroot ir\u00e1 usar o toolchain que especificarmos. Note que dentro dessa op\u00e7\u00e3o existe a : Buildroot toolchain , que se ativada faria com que o buildroot baixasse de forma autom\u00e1tica todo o toolchain. Toolchain path: $(ARM_GCC) o buildroot ir\u00e1 usar essa vari\u00e1vel do sistema como path do toolchain. Temos duas op\u00e7\u00f5es aqui : Podemos declarar essa vari\u00e1vel no bash Podemos editar essa op\u00e7\u00e3o j\u00e1 com o path do nosso toolchain Vamos escolher por hora a op\u00e7\u00e3o 1. Toolchain prefix: $(ARCH)-linux-gnueabihf o prefix \u00e9 como o toolchain ir\u00e1 ser chamado, por exemplo para acessar o gcc: $(ARM_GCC)/bin/$(ARCH)-linux-gnueabihf-gcc Sendo : ARM_GCC = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf ARCH = arm (passado no call do make) Resulta em : /home/corsi/work/gcc-linaro-7.1-2017.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc Toolchain gcc version: 7.x \u00e9 a vers\u00e3o do nosso toolchain: External toolchain C library: glibc/eglibc Ativar : Toolchain has SSP support Ativar : Toolchain has RCP support Ativar : Toolchain has C++ support $ $GCC_Linaro/bin/arm-linux-gnueabihf-gcc -v ... gcc version 7.2.1 20171011 - External toolchain kernel headers series: 4.10.x 4. System Configuration \u00b6 Nessa etapa vamos configurar informa\u00e7\u00f5es como: hostname, user, password gerenciador de inicializa\u00e7\u00e3o (init)... Menu principal -> System Configuration System hostname: SoC-Corsi (escolha o que preferir) System banner: Embarcados Avancados Init system: BusyBox Root password: 1234 (escolha o que preferir) /bin/sh: busybox O shell a ser inserido no sistema, temos v\u00e1rias outras op\u00e7\u00f5es: bash, zsh. Todas elas ir\u00e3o aumentar o tamanho e a complexidade da imagem. 5. Kernel / bootloader \u00b6 O busybox pode baixar e compilar o kernel e o uboot para n\u00f3s. N\u00e3o vamos usar essa configura\u00e7\u00e3o. Menu principal -> Kernel 6. Target packages \u00b6 Nesse menu temos a op\u00e7\u00e3o de quais programas e sistemas ser\u00e3o inseridos na imagem para o target. Se quisermos por exemplo inserir um webserver (apache ?) no nosso linux embarcado, devemos selecionar aqui. Vamos deixar como padr\u00e3o por hora. Mais tarde iremos voltar a essa etapa mais tarde. 7. Filesystem images \u00b6 Menu principal -> Filesystem images Selecionar: tar the root filesystem Esse menu descreve para o busybox como deve ser a sa\u00edda final da imagem do filesystem gerada. O busybox necessita gerar filesystem que \u00e9 capaz de configurar as permiss\u00f5es dos arquivos corretamente (ele n\u00e3o pode simplesmente gerar uma pasta com todos os arquivos e programas). 8. Finalizando \u00b6 Salve a sua configura\u00e7\u00e3o (ESC ESC save) e volte ao terminal. Vamos agora gerar a imagem do nosso filesystem. Compilando \u00b6 Para compilar e gerar o filesystem : $ make all -j 4 Nessa etapa o buildroot ir\u00e1 baixar da web todos os pacotes e programas que foram selecionados no menu de configura\u00e7\u00e3o, e ir\u00e1 compilar o source code com o toolchain que passamos para ele. Isso pode levar um tempinho . Gr\u00e1ficos ! \u00b6 Uma vez acabado o processo de gera\u00e7\u00e3o do FS, podemos gerar alguns gr\u00e1ficos muito importantes: https://buildroot.org/downloads/manual/manual.html#_graphing_the_filesystem_size_contribution_of_packages Depend\u00eancia dos pacotes: make graph-depends Tempo de compila\u00e7\u00e3o: make graph-build Contribui\u00e7\u00e3o do tamanho do FS de cada pacote: make graph-size Os gr\u00e1ficos s\u00e3o salvos na pasta: output/graphs/ - Gere os tr\u00eas gr\u00e1ficos e analise o resultado Outputs \u00b6 Existem duas sa\u00eddas do buildroot na pasta: ~/work/buildroot/output/ o arquivo ./images/rootfs.tar : que cont\u00e9m o fileSystem do target (com as permiss\u00f5es corretas) u pasta ./images/target/ : com os arquivos contidos no .tar mas sem as permiss\u00f5es corretas para executar no target. Inclusive essa pasta possui um arquivo : THIS_IS_NOT_YOUR_ROOT_FILESYSTEM * Warning! \u00b6 This directory does not contain the root filesystem that you can use on your embedded system. Since Buildroot does not run as root, it cannot create device files and set the permissions and ownership of files correctly in this directory to make it usable as a root filesystem. .... Copie o tar para a nossa pasta de sa\u00eddas: $ cp ~/work/buildroot/output/images/rootfs.tar ~/work/HPS-Linux/ Esse arquivo ser\u00e1 extra\u00eddo para o nosso SDCARD, que ser\u00e1 lido quando pelo kernel. Testando \u00b6 Siga o tutorial em : https://github.com/Insper/EmbarcadosAvancados/wiki/Tutorial---HPS---SDCard#filesystem Perguntas \u00b6 (cap. 6 ) - descreva o que \u00e9 o root file system - initd process - para que serve e como funciona o /linuxrc - para que serve o /proc Refer\u00eancias \u00b6 dtb : https://rocketboards.org/foswiki/Documentation/HOWTOCreateADeviceTree Generating and Compiling the Preloader : https://rocketboards.org/foswiki/Documentation/GSRD141Preloader Compilando o kernel : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Entrega \u00b6 Entrega 5","title":"Buildroot"},{"location":"Tutorial-HPS-FileSystem-buildroot/#buildroot","text":"Ferramentas e configura\u00e7\u00f5es necess\u00e1rias para compilarmos um projeto (hardware e software) para o HPS. Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system https://en.wikipedia.org/wiki/Buildroot Iremos utilizar o buildroot para gerar o filesystem ( /bin , /etc , ...) do nosso sistema embarcado. No buildroot teremos a op\u00e7\u00e3o de configura\u00e7\u00e3o de quais softwares queremos no dispositivo. Por exemplo, se desejarmos acessar o HPS via ssh, teremos que no buildroot adicionar um ssh server para ser compilado e adicionado ao filesystem e executado no boot. O buildroot \u00e9 uma alternativa a outro projeto bem conhecido: Yocto. O v\u00eddeo a seguir s\u00e3o dois desenvolvedores, um de cada projeto, fazendo a compara\u00e7\u00e3o entre as duas ferramentas : https://www.youtube.com/watch?v=13LZ0szWSVg O Yocto tem um problema de n\u00e3o funcionar em vers\u00f5es mais recentes do Ubuntu/Fedora, por isso a escolha pelo buildroot. Mas \u00e9 prov\u00e1vel que tenhamos que usar o yocto em um outro projeto !","title":"Buildroot"},{"location":"Tutorial-HPS-FileSystem-buildroot/#buildroot_1","text":"Ler getting Started: https://buildroot.org/downloads/manual/manual.html#_getting_started Primeiramente devemos fazer o download do buildroot : $ git clone https://github.com/buildroot/buildroot ~/work/buildroot $ cd ~/work/buildroot/ O buildroot possui uma ferramenta de configura\u00e7\u00e3o similar ao do kernel do linux (nconfig) iremos utilizar-la para configurar o filesystem assim como quais programas ser\u00e3o compilados e inseridos no /root/ . Lembre que j\u00e1 possu\u00edmos um toolchain (o que compilamos o kernel) na pasta ~/work/ , iremos utilizar para a compila\u00e7\u00e3o de todos os programas que iremos carregar no embarcado. O buildroot tem a op\u00e7\u00e3o de fazer o download do toolchain (ele tamb\u00e9m pode compilar o kernel e gerar o uboot, \u00e9 uma ferramenta bem completa), mas dessa vez iremos utilizar o que j\u00e1 temos (para manter a compatibilidade).","title":"buildroot"},{"location":"Tutorial-HPS-FileSystem-buildroot/#configurando","text":"Na pasta do buildroot clonada, execute o seguinte comando: $ make ARCH = arm nconfig Ele ir\u00e1 abrir uma tela de configura\u00e7\u00e3o : para voltar para essa tela, basta aperta duas vezes a tecla ESC","title":"Configurando"},{"location":"Tutorial-HPS-FileSystem-buildroot/#1-target-options","text":"A primeira parte que iremos configurar \u00e9 o alvo da gera\u00e7\u00e3o do filesystem ( Target options ), devemos informar para o buildroot que ele est\u00e1 gerando arquivos para um ARM e indicar algumas op\u00e7\u00f5es do nosso compilador. Para isso: Menu principal -> Target Options Target Architecture: ARM (little endian). Essa op\u00e7\u00e3o j\u00e1 deve estar certa pois passamos via a chamada do make (make ARCH=ARM ...) Target Architecture Variant: cortex-A9 Enable NEON SIMD extension support Enable VFP extension support Floating point strategy: NEON https://developer.arm.com/technologies/neon Target ABI: EABIhf Indicamos ao buildroot que nossa arquitetura possui ponto flutuante em HW.","title":"1. Target Options"},{"location":"Tutorial-HPS-FileSystem-buildroot/#2-build-options","text":"Deixe padr\u00e3o","title":"2. Build options"},{"location":"Tutorial-HPS-FileSystem-buildroot/#3-toolchain","text":"Vamos indicar agora para o buildroot qual toolchain que ele deve utilizar e suas configura\u00e7\u00f5es : Menu principal -> Toolchain Toolchain type: External toolchain o buildroot ir\u00e1 usar o toolchain que especificarmos. Note que dentro dessa op\u00e7\u00e3o existe a : Buildroot toolchain , que se ativada faria com que o buildroot baixasse de forma autom\u00e1tica todo o toolchain. Toolchain path: $(ARM_GCC) o buildroot ir\u00e1 usar essa vari\u00e1vel do sistema como path do toolchain. Temos duas op\u00e7\u00f5es aqui : Podemos declarar essa vari\u00e1vel no bash Podemos editar essa op\u00e7\u00e3o j\u00e1 com o path do nosso toolchain Vamos escolher por hora a op\u00e7\u00e3o 1. Toolchain prefix: $(ARCH)-linux-gnueabihf o prefix \u00e9 como o toolchain ir\u00e1 ser chamado, por exemplo para acessar o gcc: $(ARM_GCC)/bin/$(ARCH)-linux-gnueabihf-gcc Sendo : ARM_GCC = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf ARCH = arm (passado no call do make) Resulta em : /home/corsi/work/gcc-linaro-7.1-2017.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc Toolchain gcc version: 7.x \u00e9 a vers\u00e3o do nosso toolchain: External toolchain C library: glibc/eglibc Ativar : Toolchain has SSP support Ativar : Toolchain has RCP support Ativar : Toolchain has C++ support $ $GCC_Linaro/bin/arm-linux-gnueabihf-gcc -v ... gcc version 7.2.1 20171011 - External toolchain kernel headers series: 4.10.x","title":"3. Toolchain"},{"location":"Tutorial-HPS-FileSystem-buildroot/#4-system-configuration","text":"Nessa etapa vamos configurar informa\u00e7\u00f5es como: hostname, user, password gerenciador de inicializa\u00e7\u00e3o (init)... Menu principal -> System Configuration System hostname: SoC-Corsi (escolha o que preferir) System banner: Embarcados Avancados Init system: BusyBox Root password: 1234 (escolha o que preferir) /bin/sh: busybox O shell a ser inserido no sistema, temos v\u00e1rias outras op\u00e7\u00f5es: bash, zsh. Todas elas ir\u00e3o aumentar o tamanho e a complexidade da imagem.","title":"4. System Configuration"},{"location":"Tutorial-HPS-FileSystem-buildroot/#5-kernel-bootloader","text":"O busybox pode baixar e compilar o kernel e o uboot para n\u00f3s. N\u00e3o vamos usar essa configura\u00e7\u00e3o. Menu principal -> Kernel","title":"5. Kernel / bootloader"},{"location":"Tutorial-HPS-FileSystem-buildroot/#6-target-packages","text":"Nesse menu temos a op\u00e7\u00e3o de quais programas e sistemas ser\u00e3o inseridos na imagem para o target. Se quisermos por exemplo inserir um webserver (apache ?) no nosso linux embarcado, devemos selecionar aqui. Vamos deixar como padr\u00e3o por hora. Mais tarde iremos voltar a essa etapa mais tarde.","title":"6. Target packages"},{"location":"Tutorial-HPS-FileSystem-buildroot/#7-filesystem-images","text":"Menu principal -> Filesystem images Selecionar: tar the root filesystem Esse menu descreve para o busybox como deve ser a sa\u00edda final da imagem do filesystem gerada. O busybox necessita gerar filesystem que \u00e9 capaz de configurar as permiss\u00f5es dos arquivos corretamente (ele n\u00e3o pode simplesmente gerar uma pasta com todos os arquivos e programas).","title":"7. Filesystem images"},{"location":"Tutorial-HPS-FileSystem-buildroot/#8-finalizando","text":"Salve a sua configura\u00e7\u00e3o (ESC ESC save) e volte ao terminal. Vamos agora gerar a imagem do nosso filesystem.","title":"8. Finalizando"},{"location":"Tutorial-HPS-FileSystem-buildroot/#compilando","text":"Para compilar e gerar o filesystem : $ make all -j 4 Nessa etapa o buildroot ir\u00e1 baixar da web todos os pacotes e programas que foram selecionados no menu de configura\u00e7\u00e3o, e ir\u00e1 compilar o source code com o toolchain que passamos para ele. Isso pode levar um tempinho .","title":"Compilando"},{"location":"Tutorial-HPS-FileSystem-buildroot/#graficos","text":"Uma vez acabado o processo de gera\u00e7\u00e3o do FS, podemos gerar alguns gr\u00e1ficos muito importantes: https://buildroot.org/downloads/manual/manual.html#_graphing_the_filesystem_size_contribution_of_packages Depend\u00eancia dos pacotes: make graph-depends Tempo de compila\u00e7\u00e3o: make graph-build Contribui\u00e7\u00e3o do tamanho do FS de cada pacote: make graph-size Os gr\u00e1ficos s\u00e3o salvos na pasta: output/graphs/ - Gere os tr\u00eas gr\u00e1ficos e analise o resultado","title":"Gr\u00e1ficos !"},{"location":"Tutorial-HPS-FileSystem-buildroot/#outputs","text":"Existem duas sa\u00eddas do buildroot na pasta: ~/work/buildroot/output/ o arquivo ./images/rootfs.tar : que cont\u00e9m o fileSystem do target (com as permiss\u00f5es corretas) u pasta ./images/target/ : com os arquivos contidos no .tar mas sem as permiss\u00f5es corretas para executar no target. Inclusive essa pasta possui um arquivo : THIS_IS_NOT_YOUR_ROOT_FILESYSTEM *","title":"Outputs"},{"location":"Tutorial-HPS-FileSystem-buildroot/#warning","text":"This directory does not contain the root filesystem that you can use on your embedded system. Since Buildroot does not run as root, it cannot create device files and set the permissions and ownership of files correctly in this directory to make it usable as a root filesystem. .... Copie o tar para a nossa pasta de sa\u00eddas: $ cp ~/work/buildroot/output/images/rootfs.tar ~/work/HPS-Linux/ Esse arquivo ser\u00e1 extra\u00eddo para o nosso SDCARD, que ser\u00e1 lido quando pelo kernel.","title":"Warning!"},{"location":"Tutorial-HPS-FileSystem-buildroot/#testando","text":"Siga o tutorial em : https://github.com/Insper/EmbarcadosAvancados/wiki/Tutorial---HPS---SDCard#filesystem","title":"Testando"},{"location":"Tutorial-HPS-FileSystem-buildroot/#perguntas","text":"(cap. 6 ) - descreva o que \u00e9 o root file system - initd process - para que serve e como funciona o /linuxrc - para que serve o /proc","title":"Perguntas"},{"location":"Tutorial-HPS-FileSystem-buildroot/#referencias","text":"dtb : https://rocketboards.org/foswiki/Documentation/HOWTOCreateADeviceTree Generating and Compiling the Preloader : https://rocketboards.org/foswiki/Documentation/GSRD141Preloader Compilando o kernel : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8","title":"Refer\u00eancias"},{"location":"Tutorial-HPS-FileSystem-buildroot/#entrega","text":"Entrega 5","title":"Entrega"},{"location":"Tutorial-HPS-Kernel/","text":"e executando o kernel do Linux Nesse tutorial iremos compilar o kernel do Linux para o ARM na nossa FPGA, usando o toolchain que j\u00e1 temos configurado. Kernel \u00b6 Clone o kernel do linux fornecido pela altera/intel para a nossa pasta work : $ git clone https://git.kernel.org $ cd Kernel 4.4 \u00b6 Vamos trabalhar com a vers\u00e3o 4.4 do kernel que \u00e9 uma vers\u00e3o com: Long Time Suport (LTS), ou seja, ser\u00e1 mantida por muito mais tempo que as outras vers\u00f5es. A vers\u00e3o 4.4 foi lan\u00e7ada em 10 de Janeiro e ser\u00e1 mantida oficialmente at\u00e9 2021, ela \u00e9 tamb\u00e9m a vers\u00e3o Super LTS, com suporte estendido at\u00e9 2036. Linux Pense que um desenvolvedor de um sistema embarcado, que vai criar toda uma infra dedicada n\u00e3o quer ficar ter que ajustando e validando tudo novamente s\u00f3 para ter a vers\u00e3o mais nova do kenrel. A ideia de usar uma com maior suporte \u00e9 minimizar esfor\u00e7os. O kernel utiliza o sistema de tag do git: $ git tag ... v2.6.11 v2.6.11-tree v2.6.12 v2.6.12-rc2 v2.6.12-rc3 v2.6.12-rc4 v2.6.12-rc5 v2.6.12-rc6 v2.6.13-rc2 v2.6.14-rc2 v2.6.14-rc3 ... Note que revis\u00f5es \u00edmpares s\u00e3o para Karnel em est\u00e1gio de desenvolvimento, e n\u00fameros pares para vers\u00e3o de produ\u00e7\u00e3o, exemplo : Linux 2.4.x - Produ\u00e7\u00e3o Linux 2.5.x - Desenvolvimento Linux 2.6.x - Produ\u00e7\u00e3o .... Vamos criar um branch da vers\u00e3o v4.4, para isso execute o comando a seguir: $ git checkout v4.4 $ git checkout -b 4 .4-SoC Uma vez no branch 4.4-SoC precisamos configurar o kernel para nosso processador (ARM) e fazer as configura\u00e7\u00f5es necess\u00e1rias no kernel. Primeiramente iremos gerar um arquivo de configura\u00e7\u00e3o .config padr\u00e3o para SoCs ARM Altera: $ export ARCH = arm # indica a arquitetura do Kernel $ make socfpga_defconfig # gera o arquivo padr\u00e3o de configura\u00e7\u00e3o para soc Agora vamos configurar o Kernel do Linux para a nossa aplica\u00e7\u00e3o : $ make ARCH = arm menuconfig Note Talvez seja necess\u00e1rio instalar o pacote libncurses5-dev Esse comando ir\u00e1 abrir a interface de configura\u00e7\u00e3o do Kernel do Linux (existem outras op\u00e7\u00f5es: make xconfig ; make config ; make gconfig , ...). Essa interface permite selecionarmos v\u00e1rias configura\u00e7\u00f5es do Kernel. Agora iremos seguir o roteiro proposto no tutorial a seguir, traduzido de maneira reduzida nesse tutorial. https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide Configurando \u00b6 Automatically append version information to the version string General Setup Desabilite : Automatically append version information to the version string ref : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Go into the \u201cGeneral Setup\u201d menu. Uncheck \u201cAutomatically append version information to the version string\u201d. This will prevent the kernel from adding extra \u201cversion\u201d information to the kernel. Whenever we try to dynamically load a driver (also called kernel modules, as discussed in a later section) the kernel will check to see if the driver was built with the same version of the source code as itself. If it isn\u2019t, it will reject to load that driver. For development, it\u2019s useful to disable these options to make it easier to test out different versions of drivers. In a production system however, it\u2019s recommend to keep this option enabled and only use drivers that were compiled with the correct version of the kernel. I encourage you to peruse the options in the General Setup menu and see what\u2019s available to you (hitting \u201c?\u201d to view the help info for the highlighted option). Of particular importance to us is the \u201cEmbedded System\u201d option (turns on advanced features) and the type of SLAB allocator used (determines how memory will be dynamically allocated in the kernel). If you want to use an initial ram disk or ram filesystem that would be enabled here as well (these will be explained in the next section). (texto extra\u00eddo da refer\u00eancia) Enable loadable module support Volte para o menu principal (ESC ESC) Note que o Enable loadable module support est\u00e1 ativado. Isso permite que o kernel seja modificado (pelo carregamento de drivers) ap\u00f3s a sua execu\u00e7\u00e3o. Isso ser\u00e1 \u00fatil quando formos desenvolver nosso pr\u00f3prio device driver, sem a necessidade de recompilarmos o kernel toda vez que desejamos testar uma modifica\u00e7\u00e3o no c\u00f3digo. \u00c9 essa configura\u00e7\u00e3o que permite utilizarmos USBs, SSDs, placas de rede via a possibilidade do carregamento de drivers de forma din\u00e2mica pelo sistema operacional. Support for large (2TB+) block devices and files** No menu principal Enable the block layer Ative : Support for large (2TB+) block devices and files Essa op\u00e7\u00e3o ir\u00e1 permitir a utiliza\u00e7\u00e3o de parti\u00e7\u00f5es do tipo EXT4. Se esquecer essa op\u00e7\u00e3o e o kernel tiver em uma parti\u00e7\u00e3o EXT4 a mesma ser\u00e1 montada como READ-ONLY. The Extended 4 (ext4) filesystem Menu principal File systems Ative : The Extended 4 (ext4) filesystem Essa op\u00e7\u00e3o ir\u00e1 possibilitar que o kernel monte dispositivos formatados em EXT4. Pretendemos usar isso no SDCARD. Altera SOCFPGA family Menu principal System Type Ative : Altera SOCFGPA family Isso indica para o kernel qual ser\u00e1 o dispositivo que o mesmo ser\u00e1 executado, note que esssa op\u00e7\u00e3o possui um novo menu onde podemos ativar ou n\u00e3o a suspens\u00e3o para RAM. Symmetric Multi-Processing Menu principal Kernel Features Ative : Symmmetric Multi-Processing Essa op\u00e7\u00e3o indica para o kernel que ele deve utilizar os dois cores presente no ARM HPS da FPGA. Device Drivers Menu principal Device Drivers Indica quais drivers ser\u00e3o compilados junto com o kernel, note que j\u00e1 temos configurado drivers de rede (Network device support); GPIO (GPIO Support); RTC; DMA; ... . Lembre que j\u00e1 inicializamos o .config com uma configura\u00e7\u00e3o padr\u00e3o para SoCs Altera. Salvando \u00b6 Aperte ESC duas vezes (ESC ESC) e salve as configura\u00e7\u00f5es no arquivo .config Compilando \u00b6 O makefile utiliza a vari\u00e1vel CROSS_COMPILE para definir o toolchain que ir\u00e1 fazer a compila\u00e7\u00e3o do kernel, vamos definir como sendo o GCC do Linaro baixado recentemente: $ export CROSS_COMPILE = $GCC_Linaro /arm-linux-gnueabihf- Para compilarmos o kernel : make ARCH = arm LOCALVERSION = zImage -j 4 Esse comando faz com que o kernel do linux seja compilado em uma vers\u00e3o compactada que \u00e9 auto-extra\u00edda. Outras op\u00e7\u00f5es seriam : Image : Bin\u00e1rio do kernel zImage: vers\u00e3o compactada que possui self-extracting uImage: uma vers\u00e3o que j\u00e1 possui o bootloader uboot 1^: https://stackoverflow.com/questions/22322304/image-vs-zimage-vs-uimage o zImage \u00e9 salvo em : arch/arm/boot/zImage Testando \u00b6 Agora devemos atualizar o kernel que est\u00e1 no SDCard, para isso segue o tutorial no /info-SDcard.md/ : Atualizando o kernel Executando \u00b6 Para verificar se tudo est\u00e1 certo, basta colocar o cart\u00e3o de mem\u00f3ria no kit e verificar a vers\u00e3o do kernel em execu\u00e7\u00e3o: $ uname -a Linux buildroot 4 .14.0 #1 SMP Mon Jul 16 21:22:58 -03 2018 armv7l GNU/Linux","title":"Tutorial HPS Kernel"},{"location":"Tutorial-HPS-Kernel/#kernel","text":"Clone o kernel do linux fornecido pela altera/intel para a nossa pasta work : $ git clone https://git.kernel.org $ cd","title":"Kernel"},{"location":"Tutorial-HPS-Kernel/#kernel-44","text":"Vamos trabalhar com a vers\u00e3o 4.4 do kernel que \u00e9 uma vers\u00e3o com: Long Time Suport (LTS), ou seja, ser\u00e1 mantida por muito mais tempo que as outras vers\u00f5es. A vers\u00e3o 4.4 foi lan\u00e7ada em 10 de Janeiro e ser\u00e1 mantida oficialmente at\u00e9 2021, ela \u00e9 tamb\u00e9m a vers\u00e3o Super LTS, com suporte estendido at\u00e9 2036. Linux Pense que um desenvolvedor de um sistema embarcado, que vai criar toda uma infra dedicada n\u00e3o quer ficar ter que ajustando e validando tudo novamente s\u00f3 para ter a vers\u00e3o mais nova do kenrel. A ideia de usar uma com maior suporte \u00e9 minimizar esfor\u00e7os. O kernel utiliza o sistema de tag do git: $ git tag ... v2.6.11 v2.6.11-tree v2.6.12 v2.6.12-rc2 v2.6.12-rc3 v2.6.12-rc4 v2.6.12-rc5 v2.6.12-rc6 v2.6.13-rc2 v2.6.14-rc2 v2.6.14-rc3 ... Note que revis\u00f5es \u00edmpares s\u00e3o para Karnel em est\u00e1gio de desenvolvimento, e n\u00fameros pares para vers\u00e3o de produ\u00e7\u00e3o, exemplo : Linux 2.4.x - Produ\u00e7\u00e3o Linux 2.5.x - Desenvolvimento Linux 2.6.x - Produ\u00e7\u00e3o .... Vamos criar um branch da vers\u00e3o v4.4, para isso execute o comando a seguir: $ git checkout v4.4 $ git checkout -b 4 .4-SoC Uma vez no branch 4.4-SoC precisamos configurar o kernel para nosso processador (ARM) e fazer as configura\u00e7\u00f5es necess\u00e1rias no kernel. Primeiramente iremos gerar um arquivo de configura\u00e7\u00e3o .config padr\u00e3o para SoCs ARM Altera: $ export ARCH = arm # indica a arquitetura do Kernel $ make socfpga_defconfig # gera o arquivo padr\u00e3o de configura\u00e7\u00e3o para soc Agora vamos configurar o Kernel do Linux para a nossa aplica\u00e7\u00e3o : $ make ARCH = arm menuconfig Note Talvez seja necess\u00e1rio instalar o pacote libncurses5-dev Esse comando ir\u00e1 abrir a interface de configura\u00e7\u00e3o do Kernel do Linux (existem outras op\u00e7\u00f5es: make xconfig ; make config ; make gconfig , ...). Essa interface permite selecionarmos v\u00e1rias configura\u00e7\u00f5es do Kernel. Agora iremos seguir o roteiro proposto no tutorial a seguir, traduzido de maneira reduzida nesse tutorial. https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide","title":"Kernel 4.4"},{"location":"Tutorial-HPS-Kernel/#configurando","text":"Automatically append version information to the version string General Setup Desabilite : Automatically append version information to the version string ref : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Go into the \u201cGeneral Setup\u201d menu. Uncheck \u201cAutomatically append version information to the version string\u201d. This will prevent the kernel from adding extra \u201cversion\u201d information to the kernel. Whenever we try to dynamically load a driver (also called kernel modules, as discussed in a later section) the kernel will check to see if the driver was built with the same version of the source code as itself. If it isn\u2019t, it will reject to load that driver. For development, it\u2019s useful to disable these options to make it easier to test out different versions of drivers. In a production system however, it\u2019s recommend to keep this option enabled and only use drivers that were compiled with the correct version of the kernel. I encourage you to peruse the options in the General Setup menu and see what\u2019s available to you (hitting \u201c?\u201d to view the help info for the highlighted option). Of particular importance to us is the \u201cEmbedded System\u201d option (turns on advanced features) and the type of SLAB allocator used (determines how memory will be dynamically allocated in the kernel). If you want to use an initial ram disk or ram filesystem that would be enabled here as well (these will be explained in the next section). (texto extra\u00eddo da refer\u00eancia) Enable loadable module support Volte para o menu principal (ESC ESC) Note que o Enable loadable module support est\u00e1 ativado. Isso permite que o kernel seja modificado (pelo carregamento de drivers) ap\u00f3s a sua execu\u00e7\u00e3o. Isso ser\u00e1 \u00fatil quando formos desenvolver nosso pr\u00f3prio device driver, sem a necessidade de recompilarmos o kernel toda vez que desejamos testar uma modifica\u00e7\u00e3o no c\u00f3digo. \u00c9 essa configura\u00e7\u00e3o que permite utilizarmos USBs, SSDs, placas de rede via a possibilidade do carregamento de drivers de forma din\u00e2mica pelo sistema operacional. Support for large (2TB+) block devices and files** No menu principal Enable the block layer Ative : Support for large (2TB+) block devices and files Essa op\u00e7\u00e3o ir\u00e1 permitir a utiliza\u00e7\u00e3o de parti\u00e7\u00f5es do tipo EXT4. Se esquecer essa op\u00e7\u00e3o e o kernel tiver em uma parti\u00e7\u00e3o EXT4 a mesma ser\u00e1 montada como READ-ONLY. The Extended 4 (ext4) filesystem Menu principal File systems Ative : The Extended 4 (ext4) filesystem Essa op\u00e7\u00e3o ir\u00e1 possibilitar que o kernel monte dispositivos formatados em EXT4. Pretendemos usar isso no SDCARD. Altera SOCFPGA family Menu principal System Type Ative : Altera SOCFGPA family Isso indica para o kernel qual ser\u00e1 o dispositivo que o mesmo ser\u00e1 executado, note que esssa op\u00e7\u00e3o possui um novo menu onde podemos ativar ou n\u00e3o a suspens\u00e3o para RAM. Symmetric Multi-Processing Menu principal Kernel Features Ative : Symmmetric Multi-Processing Essa op\u00e7\u00e3o indica para o kernel que ele deve utilizar os dois cores presente no ARM HPS da FPGA. Device Drivers Menu principal Device Drivers Indica quais drivers ser\u00e3o compilados junto com o kernel, note que j\u00e1 temos configurado drivers de rede (Network device support); GPIO (GPIO Support); RTC; DMA; ... . Lembre que j\u00e1 inicializamos o .config com uma configura\u00e7\u00e3o padr\u00e3o para SoCs Altera.","title":"Configurando"},{"location":"Tutorial-HPS-Kernel/#salvando","text":"Aperte ESC duas vezes (ESC ESC) e salve as configura\u00e7\u00f5es no arquivo .config","title":"Salvando"},{"location":"Tutorial-HPS-Kernel/#compilando","text":"O makefile utiliza a vari\u00e1vel CROSS_COMPILE para definir o toolchain que ir\u00e1 fazer a compila\u00e7\u00e3o do kernel, vamos definir como sendo o GCC do Linaro baixado recentemente: $ export CROSS_COMPILE = $GCC_Linaro /arm-linux-gnueabihf- Para compilarmos o kernel : make ARCH = arm LOCALVERSION = zImage -j 4 Esse comando faz com que o kernel do linux seja compilado em uma vers\u00e3o compactada que \u00e9 auto-extra\u00edda. Outras op\u00e7\u00f5es seriam : Image : Bin\u00e1rio do kernel zImage: vers\u00e3o compactada que possui self-extracting uImage: uma vers\u00e3o que j\u00e1 possui o bootloader uboot 1^: https://stackoverflow.com/questions/22322304/image-vs-zimage-vs-uimage o zImage \u00e9 salvo em : arch/arm/boot/zImage","title":"Compilando"},{"location":"Tutorial-HPS-Kernel/#testando","text":"Agora devemos atualizar o kernel que est\u00e1 no SDCard, para isso segue o tutorial no /info-SDcard.md/ : Atualizando o kernel","title":"Testando"},{"location":"Tutorial-HPS-Kernel/#executando","text":"Para verificar se tudo est\u00e1 certo, basta colocar o cart\u00e3o de mem\u00f3ria no kit e verificar a vers\u00e3o do kernel em execu\u00e7\u00e3o: $ uname -a Linux buildroot 4 .14.0 #1 SMP Mon Jul 16 21:22:58 -03 2018 armv7l GNU/Linux","title":"Executando"},{"location":"Tutorial-HPS-Linux/","text":"O HPS espera um SDCARD formatado com o esquema a seguir para que o possa carregar o boot loader e depois o kernel : Esse roteiro n\u00e3o trata a fundo a cria\u00e7\u00e3o das parti\u00e7\u00f5es no SDCARD, que podem ser ~facilmente~ geradas com o fsdisk do Linux. Aqui iremos usar uma imagem padr\u00e3o que j\u00e1 possui a formata\u00e7\u00e3o e atualizar o SDCARD com o nosso uboot / kernel e filesystem. Imagem padr\u00e3o \u00b6 Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem): O conte\u00fado da imagem e como a mesma foi criada \u00e9 detalhado no p\u00e1gina (acesse para fazer o download da iso): SDcard img base . Para usar, basta fazer o download e salvar no SDCard. Note que no comando DD deve-se substituir o SeuDevice pelo caminho que o seu Linux atribuiu ao dispositivo. Para saber basta verificar o dmesg: $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 Estamos interessados no: mmcblk0 . Agora vamos salvar a .iso no SDcard. Cuidado, se errar o dispositivo (of=/dev/mmcblk0) pode acontecer muitas coisas ruins $ sudo dd bs = 4M if = SDCardEmptyCycloneV of = /dev/mmcblk0 conv = fsync status = progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 819,2 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1,0 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 2121728 3799448 1677721 819 ,2M b W95 FAT32 /dev/mmcblk0p2 14336 2111488 2097153 1G 83 Linux /dev/mmcblk0p3 2048 4096 2049 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Pr\u00f3ximos passo \u00b6 Se \u00e9 a primeira vez nesse tutorial siga direto para o Tutorial HPS BlinkLED . Atualizando os arquivos \u00b6 Para atualizar o SDCARD com a vers\u00e3o rec\u00e9m gerada siga os passo a seguir. Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9 : /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildrrot. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6 $ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"Embarcados Avan\u00e7ados - Linux"},{"location":"Tutorial-HPS-Linux/#imagem-padrao","text":"Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem): O conte\u00fado da imagem e como a mesma foi criada \u00e9 detalhado no p\u00e1gina (acesse para fazer o download da iso): SDcard img base . Para usar, basta fazer o download e salvar no SDCard. Note que no comando DD deve-se substituir o SeuDevice pelo caminho que o seu Linux atribuiu ao dispositivo. Para saber basta verificar o dmesg: $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 Estamos interessados no: mmcblk0 . Agora vamos salvar a .iso no SDcard. Cuidado, se errar o dispositivo (of=/dev/mmcblk0) pode acontecer muitas coisas ruins $ sudo dd bs = 4M if = SDCardEmptyCycloneV of = /dev/mmcblk0 conv = fsync status = progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 819,2 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1,0 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 2121728 3799448 1677721 819 ,2M b W95 FAT32 /dev/mmcblk0p2 14336 2111488 2097153 1G 83 Linux /dev/mmcblk0p3 2048 4096 2049 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot .","title":"Imagem padr\u00e3o"},{"location":"Tutorial-HPS-Linux/#proximos-passo","text":"Se \u00e9 a primeira vez nesse tutorial siga direto para o Tutorial HPS BlinkLED .","title":"Pr\u00f3ximos passo"},{"location":"Tutorial-HPS-Linux/#atualizando-os-arquivos","text":"Para atualizar o SDCARD com a vers\u00e3o rec\u00e9m gerada siga os passo a seguir.","title":"Atualizando os arquivos"},{"location":"Tutorial-HPS-Linux/#kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9 : /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Kernel"},{"location":"Tutorial-HPS-Linux/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildrrot. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"Tutorial-HPS-Linux/#uboot-script-e-device-tree","text":"$ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"uboot script e device tree"},{"location":"Tutorial-HPS-Running/","text":"Executando o Linux \u00b6 Danger Nesse tutorial mexemos com grava\u00e7\u00e3o de disco, se errar o dispositivo pode corromper seus arquivos!!! Vamos nessa etapa executar um linux de exemplo fornecido pela Terasic, para isso, ser\u00e1 necess\u00e1rio programarmos um SDcard com a imagem. Esse Linux \u00e9 um ubuntu para sistemas embarcados. Vamos executar os seguintes passos: Download e gravar a Imagem padr\u00e3o (iso) no SDcard Insira o SDCard na FPGA Conecte o USB na porta UART (perto da porta Ethernet) Conecte a alimenta\u00e7\u00e3o Conecte-se ao terminal via UART Imagem padr\u00e3o (sdcard) \u00b6 Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem), essa imagem \u00e9 um ubuntu para ARM com algumas configura\u00e7\u00f5es espec\u00edficas para FPGA Cyclone V (vamos ver isso mais para frente). Download Fa\u00e7a o download da imagem Linux Console (Kernel 4.5) do site da terasic: - \"Linux BSP (Board Support Package): MicroSD Card Image\" Extraia o arquio de10_standard_linux_console.img do arquivo zipado, esse .img \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Agora temos que copiar o img para o cart\u00e3o de mem\u00f3ria. Insira o cart\u00e3o de mem\u00f3ria no computador Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg , que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: Cuidado, estou assumindo que nenhum dispositivo foi inserido ap\u00f3s o SDcard $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 O dmesg possui o log que o meu SDCARD foi alocado ao: /dev/mmclk0 , no seu linux pode ser outro nome! Warning Isso pode mudar de PC para PC! Agora vamos salvar a .iso no SDcard. Danger Cuidado, se errar o dispositivo (no meu caso: of=/dev/mmcblk0) pode acontecer coisas muito ruins com os seus dados $ sudo dd bs = 4M if = de10_standard_linux_console.img of = /dev/mmcblk0 conv = fsync status = progress $ sync dd O comando dd executa uma c\u00f3pia bit a bit de um arquivo de entrada input file: if para um output file: of O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 3,3 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 4096 1028095 1024000 500M b W95 FAT32 /dev/mmcblk0p2 1028096 7376895 6348800 3G 83 Linux /dev/mmcblk0p3 2048 4095 2048 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Success Agora remova o SDCard e o coloque na FPGA USB - UART \u00b6 O USB UART \u00e9 um conector que possibilita acessar a sa\u00edda serial do HPS via porta serial. No linux o driver \u00e9 reconhecido automaticamente, no Windows ser\u00e1 necess\u00e1rio instalar manualmente o driver da serial.. Uma vez conectado no linux host, verificamos que o mesmo foi mapeado para um dispositivo do tipo serial ( no meu caso com nome ttyUSB0 ): $ dmesg | tail .... [80473.426308] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected [80473.426333] usb 1-2: Detected FT232RL [80473.426456] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0 ... Warning Isso pode mudar de PC para PC! Para conectarmos nessa porta, precisamos usar um programa do tipo: emulador de terminal. No caso iremos utilizar o screen (verificar se possui instalado). Note que o comando a seguir deve ser modificado para o device ( /dev/ttyxxx ) na qual o seu linux associou a porta USB-Serial, extra\u00eddo do dmesg. $ screen /dev/ttyUSB0 115200,cs8 Para sair do terminal: ctrl+A : quit Linux \u00b6 Logue no linux com o usu\u00e1rio: root , sem senha. No linux verifique que existem um execut\u00e1vel chamado HPS_FPGA_LED na pasta /home/root/ . Esse programa faz com que os LEDs da FPGA pisquem. user e password user: root pass: `` Legal! Vamos agora descobrir como executar um kernel compilado por n\u00f3s!","title":"Executando o Linux"},{"location":"Tutorial-HPS-Running/#executando-o-linux","text":"Danger Nesse tutorial mexemos com grava\u00e7\u00e3o de disco, se errar o dispositivo pode corromper seus arquivos!!! Vamos nessa etapa executar um linux de exemplo fornecido pela Terasic, para isso, ser\u00e1 necess\u00e1rio programarmos um SDcard com a imagem. Esse Linux \u00e9 um ubuntu para sistemas embarcados. Vamos executar os seguintes passos: Download e gravar a Imagem padr\u00e3o (iso) no SDcard Insira o SDCard na FPGA Conecte o USB na porta UART (perto da porta Ethernet) Conecte a alimenta\u00e7\u00e3o Conecte-se ao terminal via UART","title":"Executando o Linux"},{"location":"Tutorial-HPS-Running/#imagem-padrao-sdcard","text":"Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem), essa imagem \u00e9 um ubuntu para ARM com algumas configura\u00e7\u00f5es espec\u00edficas para FPGA Cyclone V (vamos ver isso mais para frente). Download Fa\u00e7a o download da imagem Linux Console (Kernel 4.5) do site da terasic: - \"Linux BSP (Board Support Package): MicroSD Card Image\" Extraia o arquio de10_standard_linux_console.img do arquivo zipado, esse .img \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Agora temos que copiar o img para o cart\u00e3o de mem\u00f3ria. Insira o cart\u00e3o de mem\u00f3ria no computador Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg , que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: Cuidado, estou assumindo que nenhum dispositivo foi inserido ap\u00f3s o SDcard $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 O dmesg possui o log que o meu SDCARD foi alocado ao: /dev/mmclk0 , no seu linux pode ser outro nome! Warning Isso pode mudar de PC para PC! Agora vamos salvar a .iso no SDcard. Danger Cuidado, se errar o dispositivo (no meu caso: of=/dev/mmcblk0) pode acontecer coisas muito ruins com os seus dados $ sudo dd bs = 4M if = de10_standard_linux_console.img of = /dev/mmcblk0 conv = fsync status = progress $ sync dd O comando dd executa uma c\u00f3pia bit a bit de um arquivo de entrada input file: if para um output file: of O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 3,3 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 4096 1028095 1024000 500M b W95 FAT32 /dev/mmcblk0p2 1028096 7376895 6348800 3G 83 Linux /dev/mmcblk0p3 2048 4095 2048 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Success Agora remova o SDCard e o coloque na FPGA","title":"Imagem padr\u00e3o (sdcard)"},{"location":"Tutorial-HPS-Running/#usb-uart","text":"O USB UART \u00e9 um conector que possibilita acessar a sa\u00edda serial do HPS via porta serial. No linux o driver \u00e9 reconhecido automaticamente, no Windows ser\u00e1 necess\u00e1rio instalar manualmente o driver da serial.. Uma vez conectado no linux host, verificamos que o mesmo foi mapeado para um dispositivo do tipo serial ( no meu caso com nome ttyUSB0 ): $ dmesg | tail .... [80473.426308] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected [80473.426333] usb 1-2: Detected FT232RL [80473.426456] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0 ... Warning Isso pode mudar de PC para PC! Para conectarmos nessa porta, precisamos usar um programa do tipo: emulador de terminal. No caso iremos utilizar o screen (verificar se possui instalado). Note que o comando a seguir deve ser modificado para o device ( /dev/ttyxxx ) na qual o seu linux associou a porta USB-Serial, extra\u00eddo do dmesg. $ screen /dev/ttyUSB0 115200,cs8 Para sair do terminal: ctrl+A : quit","title":"USB - UART"},{"location":"Tutorial-HPS-Running/#linux","text":"Logue no linux com o usu\u00e1rio: root , sem senha. No linux verifique que existem um execut\u00e1vel chamado HPS_FPGA_LED na pasta /home/root/ . Esse programa faz com que os LEDs da FPGA pisquem. user e password user: root pass: `` Legal! Vamos agora descobrir como executar um kernel compilado por n\u00f3s!","title":"Linux"},{"location":"Tutorial-HPS-SDcard/","text":"Atualizando o SDCARD \u00b6 Atualizando Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. Atualizando o dts \u00b6 FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6 $ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"Atualizando o SDCARD"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-sdcard","text":"","title":"Atualizando o SDCARD"},{"location":"Tutorial-HPS-SDcard/#atualizando-kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Atualizando Kernel"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-dts","text":"","title":"Atualizando o dts"},{"location":"Tutorial-HPS-SDcard/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"Tutorial-HPS-SDcard/#uboot-script-e-device-tree","text":"$ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"uboot script e device tree"},{"location":"Tutorial-HPS/","text":"Tutorial HPS \u00b6 A FPGA contida no kit DE10-Standard \u00e9 um chip SoC que em um \u00fanico dispositivo que possui duas partes: o fabric da FPGA e um Hardware Process System (HPS). HPS \u00e9 o termo utilizado pela Intel-Altera para definir a parte da FPGA que \u00e9 fixa e relativa ao processador ARM A9 (pode ser outro ARM, depende da fam\u00edlia da FPGA). O HPS possui uma unidade de processamento com um ou dois Cores (depende do chip, no nosso caso \u00e9 dual core ) e alguns perif\u00e9ricos conectados em seu barramento (DMA, UART, USB, EMACS, ...). Al\u00e9m dos perif\u00e9ricos j\u00e1 contidos no HPS \u00e9 poss\u00edvel conectarmos novos perif\u00e9ricos sintetizados na FPGA via a interface HPS FPGA Interfaces . Ler Introdu\u00e7\u00e3o: 1 Introduction to Cyclone V Hard Processor System (HPS) Fam\u00edlia de FPGAs \u00b6 A Altera possui quatro fam\u00edlia de FPGAs-SoC : Stratix 10 SoC: High end, 14nm com ARM-Cortex-A53 de 64bits quad-core Arria 10 SoC: 20nm, Cortex A9 duas core com grande capacidade na FPGA Temos um kit no lab Arria V SoC: 28nm, Cortex A9 com foco em telecomunica\u00e7\u00f5es Cyclone V SoC : Fam\u00edlia low end com valor mais baixo e mais low power. Cortex A9 \u00b6 O Cortex A9 existente no HPS da Cyclone V possui as caracter\u00edsticas a seguir (extra\u00eddo do datasheet ): ARM Cortex-A9 MPCore One or two ARM Cortex-A9 processors in a cluster NEON SIMD coprocessor and VFPv3 per processor Snoop Control Unit (SCU) to ensure coherency within the cluster Accelerator coherency port (ACP) that accepts coherency memory access requests Interrupt controller One general-purpose timer and one watchdog timer per processor \u2022 Debug and trace features 32 KB instruction and 32 KB data level 1 (L1) caches per processor Memory management unit (MMU) per processor ARM L2-310 level 2 (L2) cache Shared 512 KB L2 cache A seguir um diagrama detalhado do HPS: Conex\u00e3o entre HPS e FPGA \u00b6 Note que existe no diagrama anterior algumas interfaces definidas no \"FPGA Portion\", essas interfaces permitem a ponte entre o Fabric da FPGA e o ARM hard core do chip. As interfaces s\u00e3o, resumidamente: FPGA to HPS: Barramento na qual um Master na FPGA (Platform Designer) acessa o ARM HPS to FPGA: Barramento pelo qual o ARM acessa um perif\u00e9rico (slave) na FPGA Lightweight HPS to FPGA: Barramento de menor banda que conecta o ARM em um perif\u00e9rico na FPGA (slave) 1-6 Masters SDRAM Controller: Permite a FPGA ler e escrever da mem\u00f3ria SDRAM externa ao chip AXI \u00b6 Os barramentos s\u00e3o todos do tipo AXI , um padr\u00e3o definido pela pr\u00f3pria ARM e usada em seus microcontroladores. AXI - AVALON Via Platform Designer podemos conectarmos perif\u00e9ricos com o barramento Avalon (mm) no barramento AXI do ARM, isso \u00e9 poss\u00edvel por uma \"m\u00e1gica\" que a PD faz convertendo um barramento no outro de forma transparente ao usu\u00e1rio. SDRAM \u00b6 A SDRAM deve ser usada com muita cautela pois ela ser\u00e1 compartilhada com o Linux que estar\u00e1 em execu\u00e7\u00e3o no ARM, caso um perif\u00e9rico da FPGA acesse \"aleatoriamente\" a mem\u00f3ria SDRAM ele pode sobrescrever dados importantes do kernel e crashar todo o sistema. Essa aloca\u00e7\u00e3o deve ser realizada no boot do Linux onde iremos dizer qual regi\u00e3o de mem\u00f3ria o kernel pode utilizar. Note Essa mem\u00f3ria que \u00e9 acess\u00edvel tanto pelo Linux quanto pela FPGA \u00e9 uma boa maneira de compartilhamento de dados a serem processados. Aplica\u00e7\u00f5es \u00b6 Com isso agora \u00e9 poss\u00edvel unir o melhor dos dois mundos: flexibilidade e paralelismo da FPGA com o melhor dos processadores embarcados ARM. Nos nossos projetos, o NIOS ser\u00e1 substitu\u00eddo pelo ARM, possibilitando maior poder de processamento e tamb\u00e9m suportando a execu\u00e7\u00e3o de sistemas mais complexos, tal como o Linux. Pense na aplica\u00e7\u00e3o de uma imagem que ser\u00e1 processada pela FPGA a fim de aumentar o throughtput do sistema. Essa imagem ser\u00e1 lida por exemplo por uma c\u00e2mera USB conectada no HPS, como geralmente o HPS executa um Linux, temos facilidade de acesso ao driver dessa c\u00e2mera USB. A imagem ser\u00e1 ent\u00e3o lida via o driver e ent\u00e3o alocada na mem\u00f3ria SDRAM, o endere\u00e7o da mem\u00f3ria assim como as propriedades do processamento ser\u00e3o transferidas para um perif\u00e9rico customizado no Fabric da FPGA via a interface LT-AXI. O perif\u00e9rico que est\u00e1 em modo wait, ap\u00f3s ser configurado, come\u00e7a a ler a imagem na mem\u00f3ria SDRAM, processar e salvar o resultado na pr\u00f3pria mem\u00f3ria. Ao final da convers\u00e3o uma interrup\u00e7\u00e3o \u00e9 gerada e o Linux ir\u00e1 tratar o dado. Enquanto o perif\u00e9rico processa o dado, a aplica\u00e7\u00e3o pode de forma concorrente, ler uma nova imagem e j\u00e1 alocar em um novo endere\u00e7o de mem\u00f3ria, pois o processamento e a aquisi\u00e7\u00e3o agora funcionam de forma simult\u00e2nea. Pr\u00f3ximos passos \u00b6 Vamos agora subir executar um Linux no ARM, iremos nesse momento trabalhar com uma imagem j\u00e1 pronto. Siga para o tutorial ter que configurar nossa infra para podermos gerar c\u00f3digos para o ARM, siga o para: Tutorial HPS BuildSystem .","title":"Tutorial HPS"},{"location":"Tutorial-HPS/#tutorial-hps","text":"A FPGA contida no kit DE10-Standard \u00e9 um chip SoC que em um \u00fanico dispositivo que possui duas partes: o fabric da FPGA e um Hardware Process System (HPS). HPS \u00e9 o termo utilizado pela Intel-Altera para definir a parte da FPGA que \u00e9 fixa e relativa ao processador ARM A9 (pode ser outro ARM, depende da fam\u00edlia da FPGA). O HPS possui uma unidade de processamento com um ou dois Cores (depende do chip, no nosso caso \u00e9 dual core ) e alguns perif\u00e9ricos conectados em seu barramento (DMA, UART, USB, EMACS, ...). Al\u00e9m dos perif\u00e9ricos j\u00e1 contidos no HPS \u00e9 poss\u00edvel conectarmos novos perif\u00e9ricos sintetizados na FPGA via a interface HPS FPGA Interfaces . Ler Introdu\u00e7\u00e3o: 1 Introduction to Cyclone V Hard Processor System (HPS)","title":"Tutorial HPS"},{"location":"Tutorial-HPS/#familia-de-fpgas","text":"A Altera possui quatro fam\u00edlia de FPGAs-SoC : Stratix 10 SoC: High end, 14nm com ARM-Cortex-A53 de 64bits quad-core Arria 10 SoC: 20nm, Cortex A9 duas core com grande capacidade na FPGA Temos um kit no lab Arria V SoC: 28nm, Cortex A9 com foco em telecomunica\u00e7\u00f5es Cyclone V SoC : Fam\u00edlia low end com valor mais baixo e mais low power.","title":"Fam\u00edlia de FPGAs"},{"location":"Tutorial-HPS/#cortex-a9","text":"O Cortex A9 existente no HPS da Cyclone V possui as caracter\u00edsticas a seguir (extra\u00eddo do datasheet ): ARM Cortex-A9 MPCore One or two ARM Cortex-A9 processors in a cluster NEON SIMD coprocessor and VFPv3 per processor Snoop Control Unit (SCU) to ensure coherency within the cluster Accelerator coherency port (ACP) that accepts coherency memory access requests Interrupt controller One general-purpose timer and one watchdog timer per processor \u2022 Debug and trace features 32 KB instruction and 32 KB data level 1 (L1) caches per processor Memory management unit (MMU) per processor ARM L2-310 level 2 (L2) cache Shared 512 KB L2 cache A seguir um diagrama detalhado do HPS:","title":"Cortex A9"},{"location":"Tutorial-HPS/#conexao-entre-hps-e-fpga","text":"Note que existe no diagrama anterior algumas interfaces definidas no \"FPGA Portion\", essas interfaces permitem a ponte entre o Fabric da FPGA e o ARM hard core do chip. As interfaces s\u00e3o, resumidamente: FPGA to HPS: Barramento na qual um Master na FPGA (Platform Designer) acessa o ARM HPS to FPGA: Barramento pelo qual o ARM acessa um perif\u00e9rico (slave) na FPGA Lightweight HPS to FPGA: Barramento de menor banda que conecta o ARM em um perif\u00e9rico na FPGA (slave) 1-6 Masters SDRAM Controller: Permite a FPGA ler e escrever da mem\u00f3ria SDRAM externa ao chip","title":"Conex\u00e3o entre HPS e FPGA"},{"location":"Tutorial-HPS/#axi","text":"Os barramentos s\u00e3o todos do tipo AXI , um padr\u00e3o definido pela pr\u00f3pria ARM e usada em seus microcontroladores. AXI - AVALON Via Platform Designer podemos conectarmos perif\u00e9ricos com o barramento Avalon (mm) no barramento AXI do ARM, isso \u00e9 poss\u00edvel por uma \"m\u00e1gica\" que a PD faz convertendo um barramento no outro de forma transparente ao usu\u00e1rio.","title":"AXI"},{"location":"Tutorial-HPS/#sdram","text":"A SDRAM deve ser usada com muita cautela pois ela ser\u00e1 compartilhada com o Linux que estar\u00e1 em execu\u00e7\u00e3o no ARM, caso um perif\u00e9rico da FPGA acesse \"aleatoriamente\" a mem\u00f3ria SDRAM ele pode sobrescrever dados importantes do kernel e crashar todo o sistema. Essa aloca\u00e7\u00e3o deve ser realizada no boot do Linux onde iremos dizer qual regi\u00e3o de mem\u00f3ria o kernel pode utilizar. Note Essa mem\u00f3ria que \u00e9 acess\u00edvel tanto pelo Linux quanto pela FPGA \u00e9 uma boa maneira de compartilhamento de dados a serem processados.","title":"SDRAM"},{"location":"Tutorial-HPS/#aplicacoes","text":"Com isso agora \u00e9 poss\u00edvel unir o melhor dos dois mundos: flexibilidade e paralelismo da FPGA com o melhor dos processadores embarcados ARM. Nos nossos projetos, o NIOS ser\u00e1 substitu\u00eddo pelo ARM, possibilitando maior poder de processamento e tamb\u00e9m suportando a execu\u00e7\u00e3o de sistemas mais complexos, tal como o Linux. Pense na aplica\u00e7\u00e3o de uma imagem que ser\u00e1 processada pela FPGA a fim de aumentar o throughtput do sistema. Essa imagem ser\u00e1 lida por exemplo por uma c\u00e2mera USB conectada no HPS, como geralmente o HPS executa um Linux, temos facilidade de acesso ao driver dessa c\u00e2mera USB. A imagem ser\u00e1 ent\u00e3o lida via o driver e ent\u00e3o alocada na mem\u00f3ria SDRAM, o endere\u00e7o da mem\u00f3ria assim como as propriedades do processamento ser\u00e3o transferidas para um perif\u00e9rico customizado no Fabric da FPGA via a interface LT-AXI. O perif\u00e9rico que est\u00e1 em modo wait, ap\u00f3s ser configurado, come\u00e7a a ler a imagem na mem\u00f3ria SDRAM, processar e salvar o resultado na pr\u00f3pria mem\u00f3ria. Ao final da convers\u00e3o uma interrup\u00e7\u00e3o \u00e9 gerada e o Linux ir\u00e1 tratar o dado. Enquanto o perif\u00e9rico processa o dado, a aplica\u00e7\u00e3o pode de forma concorrente, ler uma nova imagem e j\u00e1 alocar em um novo endere\u00e7o de mem\u00f3ria, pois o processamento e a aquisi\u00e7\u00e3o agora funcionam de forma simult\u00e2nea.","title":"Aplica\u00e7\u00f5es"},{"location":"Tutorial-HPS/#proximos-passos","text":"Vamos agora subir executar um Linux no ARM, iremos nesse momento trabalhar com uma imagem j\u00e1 pronto. Siga para o tutorial ter que configurar nossa infra para podermos gerar c\u00f3digos para o ARM, siga o para: Tutorial HPS BuildSystem .","title":"Pr\u00f3ximos passos"},{"location":"info-FPGA-e-Softwares/","text":"Infraestrutura / FPGA e SWs \u00b6 Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente. DE10-Standard \u00b6 Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic ao curso to $350 que possui em seu core uma FPGA Cyclone V com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip. Softwares \u00b6 Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Infraestrutura / FPGA e SWs"},{"location":"info-FPGA-e-Softwares/#infraestrutura-fpga-e-sws","text":"Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente.","title":"Infraestrutura / FPGA e SWs"},{"location":"info-FPGA-e-Softwares/#de10-standard","text":"Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic ao curso to $350 que possui em seu core uma FPGA Cyclone V com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip.","title":"DE10-Standard"},{"location":"info-FPGA-e-Softwares/#softwares","text":"Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Softwares"},{"location":"info-SDcard-img-Detalhes/","text":"Imagem padr\u00e3o Linux para o kit DE10-nano da Terasic: Arquivo MD5 (.tar.gz) de10-nano-insper.tar.gz c43c2d423fde5a01e45e50e135baa84c A iso possui as seguintes especifica\u00e7\u00f5es: Software \u00b6 Toolchain gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf Linux Kernel 4.14 https://github.com/altera-opensource/linux-socfpga FileSystem (buildroot): user: root password: 1234 Networking: aftp, sshfs, dropbear Debuggin, profiling and benchmark: dgb (server), cache-calibrator Graphic libraries direcfb, x.org Crypto openssl, libsha1 u-boot \u00b6 meta-de10-nano VERSION-2017.03.31 Essa vers\u00e3o do u-boot aloca um framebuffer no endere\u00e7o: 0x3F000000 + \"hdmi_fdt_mod=\" \\ + \"load mmc 0:1 ${fdt_addr} \" \\ + \"socfpga_cyclone5_de10_nano.dtb; \" \\ + \"fdt addr ${fdt_addr}; \" \\ + \"fdt resize; \" \\ + \"fdt mknode /soc framebuffer@3F000000; \" \\ + \"setenv fdt_frag /soc/framebuffer@3F000000; \" \\ + \"fdt set ${fdt_frag} compatible \\\"simple-framebuffer\\\"; \"\\ + \"fdt set ${fdt_frag} reg <0x3F000000 8294400>; \" \\ + \"fdt set ${fdt_frag} format \\\"x8r8g8b8\\\"; \" \\ + \"fdt set ${fdt_frag} width <${HDMI_h_active_pix}>; \" \\ + \"fdt set ${fdt_frag} height <${HDMI_v_active_lin}>; \" \\ + \"fdt set ${fdt_frag} stride <${HDMI_stride}>; \" \\ + \"fdt set /soc stdout-path \\\"display0\\\"; \" \\ + \"fdt set /aliases display0 \\\"/soc/framebuffer@3F000000\\\";\"\\ Assumi-se que o kernel possui nome zImage , que o baudrate do console \u00e9 115200 e que o hardware a ser carregado na FPGA \u00e9 o arquivo de10-nano.rbf e o device tree com nome socfpga_cyclone5_de10_nano.dtb #define CONFIG_BOOTFILE \"zImage\" #define CONFIG_BOOTARGS \"console=ttyS0,\" _stringify(CONFIG_BAUDRATE) #define CONFIG_BOOTCOMMAND \"run mmcload; run mmcboot\" Hardware \u00b6 O Hardware contido nessa ISO \u00e9 o de10-nano-fft fornecido no reposit\u00f3rio do github da Intel. Com o hardware detalhado a seguir: Flow Status Successful - Mon Oct 1 17:47:53 2018 Quartus Prime Version 16.1.0 Build 196 10/24/2016 SJ Standard Edition Revision Name de10-nano-fft Top-level Entity Name top Family Cyclone V Device 5CSEBA6U23I7DK Timing Models Final Logic utilization (in ALMs) 20,797 / 41,910 ( 50 % ) Total registers 34901 Total pins 265 / 314 ( 84 % ) Total virtual pins 0 Total block memory bits 1,798,248 / 5,662,720 ( 32 % ) Total DSP Blocks 18 / 112 ( 16 % ) Total HSSI RX PCSs 0 Total HSSI PMA RX Deserializers 0 Total HSSI TX PCSs 0 Total HSSI PMA TX Serializers 0 Total PLLs 1 / 6 ( 17 % ) Total DLLs 1 / 4 ( 25 % )","title":"info SDcard img Detalhes"},{"location":"info-SDcard-img-Detalhes/#software","text":"Toolchain gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf Linux Kernel 4.14 https://github.com/altera-opensource/linux-socfpga FileSystem (buildroot): user: root password: 1234 Networking: aftp, sshfs, dropbear Debuggin, profiling and benchmark: dgb (server), cache-calibrator Graphic libraries direcfb, x.org Crypto openssl, libsha1","title":"Software"},{"location":"info-SDcard-img-Detalhes/#u-boot","text":"meta-de10-nano VERSION-2017.03.31 Essa vers\u00e3o do u-boot aloca um framebuffer no endere\u00e7o: 0x3F000000 + \"hdmi_fdt_mod=\" \\ + \"load mmc 0:1 ${fdt_addr} \" \\ + \"socfpga_cyclone5_de10_nano.dtb; \" \\ + \"fdt addr ${fdt_addr}; \" \\ + \"fdt resize; \" \\ + \"fdt mknode /soc framebuffer@3F000000; \" \\ + \"setenv fdt_frag /soc/framebuffer@3F000000; \" \\ + \"fdt set ${fdt_frag} compatible \\\"simple-framebuffer\\\"; \"\\ + \"fdt set ${fdt_frag} reg <0x3F000000 8294400>; \" \\ + \"fdt set ${fdt_frag} format \\\"x8r8g8b8\\\"; \" \\ + \"fdt set ${fdt_frag} width <${HDMI_h_active_pix}>; \" \\ + \"fdt set ${fdt_frag} height <${HDMI_v_active_lin}>; \" \\ + \"fdt set ${fdt_frag} stride <${HDMI_stride}>; \" \\ + \"fdt set /soc stdout-path \\\"display0\\\"; \" \\ + \"fdt set /aliases display0 \\\"/soc/framebuffer@3F000000\\\";\"\\ Assumi-se que o kernel possui nome zImage , que o baudrate do console \u00e9 115200 e que o hardware a ser carregado na FPGA \u00e9 o arquivo de10-nano.rbf e o device tree com nome socfpga_cyclone5_de10_nano.dtb #define CONFIG_BOOTFILE \"zImage\" #define CONFIG_BOOTARGS \"console=ttyS0,\" _stringify(CONFIG_BAUDRATE) #define CONFIG_BOOTCOMMAND \"run mmcload; run mmcboot\"","title":"u-boot"},{"location":"info-SDcard-img-Detalhes/#hardware","text":"O Hardware contido nessa ISO \u00e9 o de10-nano-fft fornecido no reposit\u00f3rio do github da Intel. Com o hardware detalhado a seguir: Flow Status Successful - Mon Oct 1 17:47:53 2018 Quartus Prime Version 16.1.0 Build 196 10/24/2016 SJ Standard Edition Revision Name de10-nano-fft Top-level Entity Name top Family Cyclone V Device 5CSEBA6U23I7DK Timing Models Final Logic utilization (in ALMs) 20,797 / 41,910 ( 50 % ) Total registers 34901 Total pins 265 / 314 ( 84 % ) Total virtual pins 0 Total block memory bits 1,798,248 / 5,662,720 ( 32 % ) Total DSP Blocks 18 / 112 ( 16 % ) Total HSSI RX PCSs 0 Total HSSI PMA RX Deserializers 0 Total HSSI TX PCSs 0 Total HSSI PMA TX Serializers 0 Total PLLs 1 / 6 ( 17 % ) Total DLLs 1 / 4 ( 25 % )","title":"Hardware"},{"location":"info-SDcard/","text":"Atualizando o SDCARD \u00b6 Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6 $ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"Atualizando o SDCARD"},{"location":"info-SDcard/#atualizando-o-sdcard","text":"","title":"Atualizando o SDCARD"},{"location":"info-SDcard/#kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Kernel"},{"location":"info-SDcard/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"info-SDcard/#uboot-script-e-device-tree","text":"$ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"uboot script e device tree"},{"location":"info-VHDL/","text":"VHDL \u00b6 Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"},{"location":"info-VHDL/#vhdl","text":"Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"}]}