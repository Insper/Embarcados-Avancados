{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo a Eletica - Embarcados Avan\u00e7ados! \u00b6 Disciplina eletiva da Engenharia da Computa\u00e7\u00e3o Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Material de Aula dispon\u00edvel na wiki OBJETIVOS: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Geral \u00b6 Sobre FPGA e Softwares VHDL Projeto Final \u00b6 Overview Entrega 1 Tutorias \u00b6 FPGA \u00b6 1. RTL Entrega 1 2. NIOS Entrega 2 3. IP core Entrega 3 SoC \u00b6 4. u-boot 5. Linux Kernel 6. buildroot 7. Aplica\u00e7\u00e3o SoC + FPGA \u00b6 8. User space 9. Kernel space Acelera\u00e7\u00e3o \u00b6 10. HLS 11. OpenCl Din\u00e2mica \u00b6 A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado. Bibliografia \u00b6 B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008. Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na wiki do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final. Infraestrutura \u00b6 Vamos precisar dos softwares listados (aqui)[ https://github.com/Insper/Embarcados-Avancados/wiki/FPGA-e-Softwares#softwares ]. Iremos ao longo do curso trabalhar com uma FPGA Intel, o kit \u00e9 o DE10-Standard . Aulas \u00b6 Aulas segunda 19 / 8 e quarta 21 / 8 \u00b6 \u2757\ufe0f Sem aula \u2757\ufe0f Professor no evento Embedded Linux Usar o tempo para estudar os temas poss\u00edveis de tutorial e o que gostaria de atacar. Aula 3 - 14 / 8 \u00b6 Introdu\u00e7\u00e3o tutorial 2 Aula 2 - 7 / 8 \u00b6 Tutorial 1 Entrega 1 Aula 1 - 5 / 8 \u00b6 Objetivo da aula: Contextualiza\u00e7\u00e3o/ Aplica\u00e7\u00f5es/ Tecnologia/ Infraestrutura para o curso Assuntos \u00b6 O que \u00e9 um System On Chip (SoC) ? Qual a vantagem/desvantagem do uso de um SoC? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e Hard-Processor? NIOS x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / apple 2 / microsoft / amazon Para pr\u00f3xima aula \u00b6 Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Home"},{"location":"#bem-vindo-a-eletica-embarcados-avancados","text":"Disciplina eletiva da Engenharia da Computa\u00e7\u00e3o Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Material de Aula dispon\u00edvel na wiki OBJETIVOS: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"Bem vindo a Eletica - Embarcados Avan\u00e7ados!"},{"location":"#geral","text":"Sobre FPGA e Softwares VHDL","title":"Geral"},{"location":"#projeto-final","text":"Overview Entrega 1","title":"Projeto Final"},{"location":"#tutorias","text":"","title":"Tutorias"},{"location":"#fpga","text":"1. RTL Entrega 1 2. NIOS Entrega 2 3. IP core Entrega 3","title":"FPGA"},{"location":"#soc","text":"4. u-boot 5. Linux Kernel 6. buildroot 7. Aplica\u00e7\u00e3o","title":"SoC"},{"location":"#soc-fpga","text":"8. User space 9. Kernel space","title":"SoC + FPGA"},{"location":"#aceleracao","text":"10. HLS 11. OpenCl","title":"Acelera\u00e7\u00e3o"},{"location":"#dinamica","text":"A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado.","title":"Din\u00e2mica"},{"location":"#bibliografia","text":"B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008.","title":"Bibliografia"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na wiki do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final.","title":"Avalia\u00e7\u00e3o"},{"location":"#infraestrutura","text":"Vamos precisar dos softwares listados (aqui)[ https://github.com/Insper/Embarcados-Avancados/wiki/FPGA-e-Softwares#softwares ]. Iremos ao longo do curso trabalhar com uma FPGA Intel, o kit \u00e9 o DE10-Standard .","title":"Infraestrutura"},{"location":"#aulas","text":"","title":"Aulas"},{"location":"#aulas-segunda-19-8-e-quarta-21-8","text":"\u2757\ufe0f Sem aula \u2757\ufe0f Professor no evento Embedded Linux Usar o tempo para estudar os temas poss\u00edveis de tutorial e o que gostaria de atacar.","title":"Aulas segunda 19 / 8 e quarta 21 / 8"},{"location":"#aula-3-14-8","text":"Introdu\u00e7\u00e3o tutorial 2","title":"Aula 3 - 14 / 8"},{"location":"#aula-2-7-8","text":"Tutorial 1 Entrega 1","title":"Aula 2 - 7 / 8"},{"location":"#aula-1-5-8","text":"Objetivo da aula: Contextualiza\u00e7\u00e3o/ Aplica\u00e7\u00f5es/ Tecnologia/ Infraestrutura para o curso","title":"Aula 1  - 5 / 8"},{"location":"#assuntos","text":"O que \u00e9 um System On Chip (SoC) ? Qual a vantagem/desvantagem do uso de um SoC? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e Hard-Processor? NIOS x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / apple 2 / microsoft / amazon","title":"Assuntos"},{"location":"#para-proxima-aula","text":"Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Para pr\u00f3xima aula"},{"location":"Entrega-1/","text":"Entrega 1 \u00b6 Entrega: Pasta Entrega-1 no git Demonstra\u00e7\u00e3o em sala A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e com o Quartus e que tamb\u00e9m relembrem como desenvolver um projeto de forma hier\u00e1rquica. A partir do tutorial, voc\u00eas devem modificar o projeto para que o controle do LED seja feito por um componente (chamado de LED_peripheral ). Esse componente deve variar a frequ\u00eancia na qual os LEDs piscam com base um vetor de 4 bits, que ser\u00e1 ao final atribuido as chaves SW. E tamb\u00e9m deve possuir um sinal de enable (EN), que s\u00f3 deve funcionar caso positivo. Esse sinal de EN ser\u00e1 atribuido a bot\u00e3o KEY0. Depois de criarem esse novo componente, voc\u00eas devem o utilizar no topLevel para controlar efetivamente os pinos. Rubrica \u00b6 A Entregue um testbench capaz de testar o projeto. A Entregue um testbench capaz de testar o projeto. B O componente faz uso de generics para configura\u00e7\u00e3o interna. C Criou um componente em VHDL que \u00e9 respons\u00e1vel pelo controle do LED Esse componente possui um sinal de entrada de 4 bits que controla a frequ\u00eancia do LEDs, mapeado para as chaves SW. Esse componente possui um sinal de EN, mapeado para o bot\u00e3o KEY0 D Entregou o tutorial I N\u00e3o entregou nada Pr\u00f3ximo passo \u00b6 Siga para o tutorial Tutorial FPGA NIOS","title":"Entrega 1"},{"location":"Entrega-1/#entrega-1","text":"Entrega: Pasta Entrega-1 no git Demonstra\u00e7\u00e3o em sala A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e com o Quartus e que tamb\u00e9m relembrem como desenvolver um projeto de forma hier\u00e1rquica. A partir do tutorial, voc\u00eas devem modificar o projeto para que o controle do LED seja feito por um componente (chamado de LED_peripheral ). Esse componente deve variar a frequ\u00eancia na qual os LEDs piscam com base um vetor de 4 bits, que ser\u00e1 ao final atribuido as chaves SW. E tamb\u00e9m deve possuir um sinal de enable (EN), que s\u00f3 deve funcionar caso positivo. Esse sinal de EN ser\u00e1 atribuido a bot\u00e3o KEY0. Depois de criarem esse novo componente, voc\u00eas devem o utilizar no topLevel para controlar efetivamente os pinos.","title":"Entrega 1"},{"location":"Entrega-1/#rubrica","text":"A Entregue um testbench capaz de testar o projeto. A Entregue um testbench capaz de testar o projeto. B O componente faz uso de generics para configura\u00e7\u00e3o interna. C Criou um componente em VHDL que \u00e9 respons\u00e1vel pelo controle do LED Esse componente possui um sinal de entrada de 4 bits que controla a frequ\u00eancia do LEDs, mapeado para as chaves SW. Esse componente possui um sinal de EN, mapeado para o bot\u00e3o KEY0 D Entregou o tutorial I N\u00e3o entregou nada","title":"Rubrica"},{"location":"Entrega-1/#proximo-passo","text":"Siga para o tutorial Tutorial FPGA NIOS","title":"Pr\u00f3ximo passo"},{"location":"Entrega-2/","text":"Entrega 2 \u00b6 O que deve ser entregue? - Pasta Entrega-1 no git - Demonstra\u00e7\u00e3o em sala Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com os LEDs e bot\u00f5es sendo acionados e lidos pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf Rubrica: \u00b6 I N\u00e3o entregou nada D Entregou somente tutorial C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx e KEYx) Adicione um novo PIO para ler o valor dos bot\u00f5es Interrup\u00e7\u00e3o na leitura do bot\u00e3o B Crie um driver para controlar os LEDs e Ler as chaves (criar uma biblioteca com arquivos .c e .h separados e fun\u00e7\u00f5es), ou : Adicione e fa\u00e7a uso de um timer (Platform Design) A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o","title":"Entrega 2"},{"location":"Entrega-2/#entrega-2","text":"O que deve ser entregue? - Pasta Entrega-1 no git - Demonstra\u00e7\u00e3o em sala Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com os LEDs e bot\u00f5es sendo acionados e lidos pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf","title":"Entrega 2"},{"location":"Entrega-2/#rubrica","text":"I N\u00e3o entregou nada D Entregou somente tutorial C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx e KEYx) Adicione um novo PIO para ler o valor dos bot\u00f5es Interrup\u00e7\u00e3o na leitura do bot\u00e3o B Crie um driver para controlar os LEDs e Ler as chaves (criar uma biblioteca com arquivos .c e .h separados e fun\u00e7\u00f5es), ou : Adicione e fa\u00e7a uso de um timer (Platform Design) A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o","title":"Rubrica:"},{"location":"Entrega-3-old/","text":"Entrega 3 - (OLD) 2018-1 \u00b6 Warning semestre passado cada aluno teve que desenvolver um perif\u00e9rico para um hardware externo a FPGA, por diversas raz\u00f5es eles gastaram muito tempo nisso, nesse semestre eu quero facilitar um pouco para que possamos avan\u00e7ar em outras coisas, vou deixar a entrega aqui de refer\u00eancia para voc\u00eas verem o que foi feito!!! Criar um IP dedicado para interfacear com um hardware externo a FPGA, cada aluno (ou dupla) dever\u00e1 escolher um perif\u00e9rico e criar tanto o componente em HDL que conecta-se ao barramento Avalon quanto uma camada de abstra\u00e7\u00e3o de hardware (especificada a seguir) para comandar esse perif\u00e9rico. Os perif\u00e9ricos que podem ser escolhidos s\u00e3o: Teclado matricial de membrana 12 teclas Sabrina Motor de passo : Implementado por: Gustavo / Astur Motor DC com ponte H Implementado por: Cunial Sensor ultrass\u00f4nico HC-SR04 Implementado por: Raphael Encoder rotacional KY 040 Implementado por: Marcelo Sensor de temperatura e umidade AM2302 : Driver software \u00b6 https://www.intel.com/content/www/us/en/programmable/documentation/iga1430779693885.html https://www.intel.com/content/dam/altera-www/global/ja_JP/pdfs/literature/hb/nios2/n2sw_nii52003.pdf Para cada sensor deve ser desenvolvido um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: int NAME_init ( ..... ); // Inicializa o perif\u00e9rico int NAME_config ( ..... ); // Configura o perif\u00e9rico int NAME_halt ( ..... ); // Desativa o perif\u00e9rico int NAME_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int NAME_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o int NAME_read_xxxxx ( ..... ); // read data xxxx from device int NAME_write_xxxxx ( ..... ); // write data to xxxx device Esse driver deve estar distribu\u00eddo em dois arquivos: NAME.c e NAME.h . Rubricas gerais do projeto: \u00b6 I N\u00e3o entregou D Entregou o tutorial C (individual) Fornecido exemplo que utiliza o perif\u00e9rico Desenvolvido biblioteca em C para abstra\u00e7\u00e3o do perif\u00e9rico (de acordo com documenta\u00e7\u00e3o) Perif\u00e9rico possui registrador de configura\u00e7\u00e3o que o possibilita ligar e desligar rubrica espec\u00edfica B (individual) / C (dupla) rubrica espec\u00edfica A (individual) / B (dupla) um item da rubrica espec\u00edfica A+ (individual/dupla) dois itens do A Sensores \u00b6 Detalhamento dos sensores e das rubricas. Teclado matricial \u00b6 O perif\u00e9rico deve fazer a varredura autom\u00e1tica das teclas e gravar em um registrador o \u00faltimo valor referente ao bot\u00e3o pressionado. Rubrica: C Perif\u00e9rico faz varredura das teclas e salva bot\u00e3o em registrador B Sempre que uma tecla nova for detectada, gera uma interrup\u00e7\u00e3o A Suporta diferentes configura\u00e7\u00f5es (frequ\u00eancia de varredura, diferentes teclados: 12, 16, ...) Implementa debouncing Armazena um vetor de teclas pressionadas Motor de passo \u00b6 O perif\u00e9rico deve receber uma quantidade de pulsos e dire\u00e7\u00e3o e realizar o controle das fases do motor de passo a fim de realizar tal opera\u00e7\u00e3o. Rubrica: C Aciona motor com base em passos fornecidos B Sempre que uma a\u00e7\u00e3o de movimenta\u00e7\u00e3o for finalizada, gera uma interrup\u00e7\u00e3o. A Velocidade de rota\u00e7\u00e3o \u00e9 configur\u00e1vel Perif\u00e9rico pode ser acionado tanto por passos quanto por graus Motor DC (Ponte H) \u00b6 O perif\u00e9rico deve controlar a velocidade e dire\u00e7\u00e3o de um motor DC modulando um sinal PWM. Esse perif\u00e9rico deve ser capaz de receber um valor de duty cycle, esse motor deve ficar acionado por um tempo determinado. Rubrica: C Aciona motor com base em duty cycle e dire\u00e7\u00e3o fornecido. Possui um timer interno que especifica por quanto tempo o motor ficar\u00e1 acionado. B Gera uma interrup\u00e7\u00e3o quando o timer estourar. A (um item) Implementa um controle em malha aberta . HC \u00b6 Faz a leitura da dist\u00e2ncia de um objeto gerando o sinal de trigger no m\u00f3dulo e lendo o tempo de resposta para o echo. Deve possuir dois modos: Leitura peri\u00f3dica / Single shot. Rubrica: C Armazena em um registrador o valor do tempo da chegada do echo dado o inicio do trigger Possui dois modos de opera\u00e7\u00e3o: Peri\u00f3dico / Single shot Per\u00edodo deve ser configur\u00e1vel por reg. B Gera interrup\u00e7\u00e3o a cada nova leitura A Armazena a dist\u00e2ncia em metros, n\u00e3o o tempo percorrido. Armazena um buffer de leituras. Filtra os dados de leitura para remover ru\u00eddo Encoder de quadratura rotacional \u00b6 Contabiliza a leitura dos pulsos de um encoder de quadratura para um valor, indicando o sentido de rota\u00e7\u00e3o. Deve possuir uma maneira de zerar a quantia de pulsos j\u00e1 contabilizada. C Faz a leitura da quantidade de pulsos e a dire\u00e7\u00e3o B Gera interrup\u00e7\u00e3o a cada novo pulso detecado A Armazena a informa\u00e7\u00e3o em graus Faz a leitura por quadratura (sobida e descida) para aumentar a resolu\u00e7\u00e3o Sensor de temperatura e umidade AM2302 \u00b6 Perif\u00e9rico respons\u00e1vel por estabelecer comunica\u00e7\u00e3o com o sensor AM2302 e extrair dados de temperatura e umidade. Deve possuir dois modos de opera\u00e7\u00e3o: Peri\u00f3dico e Single Shot. C Faz a leitura da temperatura e umidade Per\u00edodo deve ser configur\u00e1vel por reg. B Dois modos de opera\u00e7\u00e3o: Peri\u00f3dico / Single Shot Gera interrup\u00e7\u00e3o a cada novo valor A Valida checksum e gera erro caso detectado algo errado","title":"Entrega 3 - (OLD) 2018-1"},{"location":"Entrega-3-old/#entrega-3-old-2018-1","text":"Warning semestre passado cada aluno teve que desenvolver um perif\u00e9rico para um hardware externo a FPGA, por diversas raz\u00f5es eles gastaram muito tempo nisso, nesse semestre eu quero facilitar um pouco para que possamos avan\u00e7ar em outras coisas, vou deixar a entrega aqui de refer\u00eancia para voc\u00eas verem o que foi feito!!! Criar um IP dedicado para interfacear com um hardware externo a FPGA, cada aluno (ou dupla) dever\u00e1 escolher um perif\u00e9rico e criar tanto o componente em HDL que conecta-se ao barramento Avalon quanto uma camada de abstra\u00e7\u00e3o de hardware (especificada a seguir) para comandar esse perif\u00e9rico. Os perif\u00e9ricos que podem ser escolhidos s\u00e3o: Teclado matricial de membrana 12 teclas Sabrina Motor de passo : Implementado por: Gustavo / Astur Motor DC com ponte H Implementado por: Cunial Sensor ultrass\u00f4nico HC-SR04 Implementado por: Raphael Encoder rotacional KY 040 Implementado por: Marcelo Sensor de temperatura e umidade AM2302 :","title":"Entrega 3 - (OLD) 2018-1"},{"location":"Entrega-3-old/#driver-software","text":"https://www.intel.com/content/www/us/en/programmable/documentation/iga1430779693885.html https://www.intel.com/content/dam/altera-www/global/ja_JP/pdfs/literature/hb/nios2/n2sw_nii52003.pdf Para cada sensor deve ser desenvolvido um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: int NAME_init ( ..... ); // Inicializa o perif\u00e9rico int NAME_config ( ..... ); // Configura o perif\u00e9rico int NAME_halt ( ..... ); // Desativa o perif\u00e9rico int NAME_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int NAME_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o int NAME_read_xxxxx ( ..... ); // read data xxxx from device int NAME_write_xxxxx ( ..... ); // write data to xxxx device Esse driver deve estar distribu\u00eddo em dois arquivos: NAME.c e NAME.h .","title":"Driver software"},{"location":"Entrega-3-old/#rubricas-gerais-do-projeto","text":"I N\u00e3o entregou D Entregou o tutorial C (individual) Fornecido exemplo que utiliza o perif\u00e9rico Desenvolvido biblioteca em C para abstra\u00e7\u00e3o do perif\u00e9rico (de acordo com documenta\u00e7\u00e3o) Perif\u00e9rico possui registrador de configura\u00e7\u00e3o que o possibilita ligar e desligar rubrica espec\u00edfica B (individual) / C (dupla) rubrica espec\u00edfica A (individual) / B (dupla) um item da rubrica espec\u00edfica A+ (individual/dupla) dois itens do A","title":"Rubricas gerais do projeto:"},{"location":"Entrega-3-old/#sensores","text":"Detalhamento dos sensores e das rubricas.","title":"Sensores"},{"location":"Entrega-3-old/#teclado-matricial","text":"O perif\u00e9rico deve fazer a varredura autom\u00e1tica das teclas e gravar em um registrador o \u00faltimo valor referente ao bot\u00e3o pressionado. Rubrica: C Perif\u00e9rico faz varredura das teclas e salva bot\u00e3o em registrador B Sempre que uma tecla nova for detectada, gera uma interrup\u00e7\u00e3o A Suporta diferentes configura\u00e7\u00f5es (frequ\u00eancia de varredura, diferentes teclados: 12, 16, ...) Implementa debouncing Armazena um vetor de teclas pressionadas","title":"Teclado matricial"},{"location":"Entrega-3-old/#motor-de-passo","text":"O perif\u00e9rico deve receber uma quantidade de pulsos e dire\u00e7\u00e3o e realizar o controle das fases do motor de passo a fim de realizar tal opera\u00e7\u00e3o. Rubrica: C Aciona motor com base em passos fornecidos B Sempre que uma a\u00e7\u00e3o de movimenta\u00e7\u00e3o for finalizada, gera uma interrup\u00e7\u00e3o. A Velocidade de rota\u00e7\u00e3o \u00e9 configur\u00e1vel Perif\u00e9rico pode ser acionado tanto por passos quanto por graus","title":"Motor de passo"},{"location":"Entrega-3-old/#motor-dc-ponte-h","text":"O perif\u00e9rico deve controlar a velocidade e dire\u00e7\u00e3o de um motor DC modulando um sinal PWM. Esse perif\u00e9rico deve ser capaz de receber um valor de duty cycle, esse motor deve ficar acionado por um tempo determinado. Rubrica: C Aciona motor com base em duty cycle e dire\u00e7\u00e3o fornecido. Possui um timer interno que especifica por quanto tempo o motor ficar\u00e1 acionado. B Gera uma interrup\u00e7\u00e3o quando o timer estourar. A (um item) Implementa um controle em malha aberta .","title":"Motor DC (Ponte H)"},{"location":"Entrega-3-old/#hc","text":"Faz a leitura da dist\u00e2ncia de um objeto gerando o sinal de trigger no m\u00f3dulo e lendo o tempo de resposta para o echo. Deve possuir dois modos: Leitura peri\u00f3dica / Single shot. Rubrica: C Armazena em um registrador o valor do tempo da chegada do echo dado o inicio do trigger Possui dois modos de opera\u00e7\u00e3o: Peri\u00f3dico / Single shot Per\u00edodo deve ser configur\u00e1vel por reg. B Gera interrup\u00e7\u00e3o a cada nova leitura A Armazena a dist\u00e2ncia em metros, n\u00e3o o tempo percorrido. Armazena um buffer de leituras. Filtra os dados de leitura para remover ru\u00eddo","title":"HC"},{"location":"Entrega-3-old/#encoder-de-quadratura-rotacional","text":"Contabiliza a leitura dos pulsos de um encoder de quadratura para um valor, indicando o sentido de rota\u00e7\u00e3o. Deve possuir uma maneira de zerar a quantia de pulsos j\u00e1 contabilizada. C Faz a leitura da quantidade de pulsos e a dire\u00e7\u00e3o B Gera interrup\u00e7\u00e3o a cada novo pulso detecado A Armazena a informa\u00e7\u00e3o em graus Faz a leitura por quadratura (sobida e descida) para aumentar a resolu\u00e7\u00e3o","title":"Encoder de quadratura rotacional"},{"location":"Entrega-3-old/#sensor-de-temperatura-e-umidade-am2302","text":"Perif\u00e9rico respons\u00e1vel por estabelecer comunica\u00e7\u00e3o com o sensor AM2302 e extrair dados de temperatura e umidade. Deve possuir dois modos de opera\u00e7\u00e3o: Peri\u00f3dico e Single Shot. C Faz a leitura da temperatura e umidade Per\u00edodo deve ser configur\u00e1vel por reg. B Dois modos de opera\u00e7\u00e3o: Peri\u00f3dico / Single Shot Gera interrup\u00e7\u00e3o a cada novo valor A Valida checksum e gera erro caso detectado algo errado","title":"Sensor de temperatura e umidade AM2302"},{"location":"Entrega-3/","text":"Entrega 3 \u00b6 Nessa entrega iremos melhorar o perif\u00e9rico rec\u00e9m criado adicionando mais funcionalidades a ele (pelo menos as necess\u00e1rias). Modifica\u00e7\u00f5es: Criar um registrador de configura\u00e7\u00e3o: REG_CONFIG onde deve ser poss\u00edvel ativar ou n\u00e3o o controle de um pino Permitir que um pino seja configur\u00e1vel como IN ou OUT pelo registrador REG_SET_OUTPUT Gerar interrup\u00e7\u00e3o registrador de configura\u00e7\u00e3o: REG_CONFIG O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: Esse driver deve estar distribu\u00eddo em dois arquivos: NAME.c e NAME.h . int NAME_init ( ..... ); // Inicializa o perif\u00e9rico int NAME_config ( ..... ); // Configura o perif\u00e9rico int NAME_halt ( ..... ); // Desativa o perif\u00e9rico int NAME_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int NAME_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o int NAME_read_xxxxx ( ..... ); // read data xxxx from device int NAME_write_xxxxx ( ..... ); // write data to xxxx device","title":"Entrega 3"},{"location":"Entrega-3/#entrega-3","text":"Nessa entrega iremos melhorar o perif\u00e9rico rec\u00e9m criado adicionando mais funcionalidades a ele (pelo menos as necess\u00e1rias). Modifica\u00e7\u00f5es: Criar um registrador de configura\u00e7\u00e3o: REG_CONFIG onde deve ser poss\u00edvel ativar ou n\u00e3o o controle de um pino Permitir que um pino seja configur\u00e1vel como IN ou OUT pelo registrador REG_SET_OUTPUT Gerar interrup\u00e7\u00e3o registrador de configura\u00e7\u00e3o: REG_CONFIG O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: Esse driver deve estar distribu\u00eddo em dois arquivos: NAME.c e NAME.h . int NAME_init ( ..... ); // Inicializa o perif\u00e9rico int NAME_config ( ..... ); // Configura o perif\u00e9rico int NAME_halt ( ..... ); // Desativa o perif\u00e9rico int NAME_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int NAME_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o int NAME_read_xxxxx ( ..... ); // read data xxxx from device int NAME_write_xxxxx ( ..... ); // write data to xxxx device","title":"Entrega 3"},{"location":"FPGA-e-Softwares/","text":"Infraestrutura / FPGA e SWs \u00b6 Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente. DE10-Standard \u00b6 Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic ao curso to $350 que possui em seu core uma FPGA Cyclone V com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip. Softwares \u00b6 Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Infraestrutura / FPGA e SWs"},{"location":"FPGA-e-Softwares/#infraestrutura-fpga-e-sws","text":"Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente.","title":"Infraestrutura / FPGA e SWs"},{"location":"FPGA-e-Softwares/#de10-standard","text":"Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic ao curso to $350 que possui em seu core uma FPGA Cyclone V com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip.","title":"DE10-Standard"},{"location":"FPGA-e-Softwares/#softwares","text":"Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Softwares"},{"location":"Projeto-Entrega-1/","text":"Nessa primeira entrega voc\u00ea deve ter uma sugest\u00e3o de t\u00f3picos que gostaria de atacar e ter em mente qual hardware seria necess\u00e1rio para a execu\u00e7\u00e3o do mesmo, de onde voc\u00ea quer sair e onde quer chegar... Tecnologia Hardware Ponto de partida / Ponto de chegada Exemplos/ sites/ manuais que leu e achou que pode servir como refer\u00eancia","title":"Projeto Entrega 1"},{"location":"Projeto-Overview/","text":"O projeto final da disciplina deve ser um tutorial com alguma rela\u00e7\u00e3o aos objetivos de aprendizagem da mat\u00e9ria: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Alguns exemplos de \u00e1reas que podem ser atacadas: Acelera\u00e7\u00e3o/ implementa\u00e7\u00e3o de algum algor\u00edtimo em hardware processamento de dados, FFT, compress\u00e3o, criptografia, ... HLD/ HLS/ OpenCL/ FPGA Amazon Compara\u00e7\u00e3o de performance entre diferentes tecnologias SoC vs GPU vs FPGA vs uC Sistema operacional Escalonador real time kernel linux, Android, RTOS embarcado Tecnologias/ Ferramentas \u00b6 A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) \ud83d\udc4d OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL .... Hardwares \u00b6 Temos os seguintes kits de desenvolvimento dispon\u00edvel: A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados com ele Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x Exemplos de temas/ coisas legais \u00b6 \u203c\ufe0f: demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c\ufe0f Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c\ufe0f Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux Rubrica \u00b6 O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Projeto Overview"},{"location":"Projeto-Overview/#tecnologias-ferramentas","text":"A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) \ud83d\udc4d OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL ....","title":"Tecnologias/ Ferramentas"},{"location":"Projeto-Overview/#hardwares","text":"Temos os seguintes kits de desenvolvimento dispon\u00edvel: A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados com ele Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x","title":"Hardwares"},{"location":"Projeto-Overview/#exemplos-de-temas-coisas-legais","text":"\u203c\ufe0f: demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c\ufe0f Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c\ufe0f Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux","title":"Exemplos de temas/ coisas legais"},{"location":"Projeto-Overview/#rubrica","text":"O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Rubrica"},{"location":"Sobre/","text":"Metodologia \u00b6 A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos. Objetivos de Aprendizagem \u00b6 Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Avalia\u00e7\u00e3o \u00b6 Entregas das APS Tutorial","title":"Sobre"},{"location":"Sobre/#metodologia","text":"A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos.","title":"Metodologia"},{"location":"Sobre/#objetivos-de-aprendizagem","text":"Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"Objetivos de Aprendizagem"},{"location":"Sobre/#avaliacao","text":"Entregas das APS Tutorial","title":"Avalia\u00e7\u00e3o"},{"location":"Tutorial-FPGA-NIOS-IP/","text":"Tutorial 3 - FPGA - IP \u00b6 Nesse tutorial deseja-se desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa, o perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\". Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Tutorial-FPGA-NIOS-IP IP Cores \u00b6 Intelectual Proprety Core (IP Core) s\u00e3o componentes descritos em HDL que possibilitam ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m da centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Altera IP cores Platform Desginer \u00b6 O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido a padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento. Barramentos \u00b6 A Altera define dois tipos de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no plataform designer. Avalon \u00b6 Documenta\u00e7\u00e3o completa dos tipos do barramento AVALON : https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o : Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity. Projeto \u00b6 Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto : Tutorial-FPGA-NIOS e renomeei para: Tutorial-FPGA-NIOS-IP . Iremos agora trabalhar nessa nova pasta. Criando um perif\u00e9rico \u00b6 Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver (.c e .h) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1rio uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 claramente um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio. Avalon Slave Memory Mapped \u00b6 Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset (`reset), lembre que projeto digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixado em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)? Especifica\u00e7\u00e3o \u00b6 Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....). Gerar HDL que representa o perif\u00e9rico com interface Avalon \u00b6 Partindo da entidade fornecida (peripheral_MM), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse generic poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Tutorial-FPGA-NIOS-IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto. Configurando path \u00b6 Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fontes que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente) Criando componente \u00b6 S\u00f3 adicionar o arquivo HDL ( .vhd ou .v verilog) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso : File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente. Files \u00b6 Na aba Files adicione o arquivo peripheral-LED.vhd : Files Syntesis Files add file peripheral-LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral-LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese. Signals & Interfaces \u00b6 Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir : Finalizando \u00b6 Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC : Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus : tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral-LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd E edite para: add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd Utilizando o componente no PD \u00b6 Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como : Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model Utilizando o componente no topLevel.vhd \u00b6 Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no topLevel.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o topLevel.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 . Firmware \u00b6 Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um novo BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral-LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m). Executando \u00b6 Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1. Simulando \u00b6 Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem : 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado. Configurando o bsp \u00b6 Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!! ModelSim \u00b6 No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Altera. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo. Entrega 3 \u00b6 Siga para a terceira entrega: Entega 3","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#tutorial-3-fpga-ip","text":"Nesse tutorial deseja-se desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa, o perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\".","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Tutorial-FPGA-NIOS-IP","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-NIOS-IP/#ip-cores","text":"Intelectual Proprety Core (IP Core) s\u00e3o componentes descritos em HDL que possibilitam ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m da centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Altera IP cores","title":"IP Cores"},{"location":"Tutorial-FPGA-NIOS-IP/#platform-desginer","text":"O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido a padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento.","title":"Platform Desginer"},{"location":"Tutorial-FPGA-NIOS-IP/#barramentos","text":"A Altera define dois tipos de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no plataform designer.","title":"Barramentos"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon","text":"Documenta\u00e7\u00e3o completa dos tipos do barramento AVALON : https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o : Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity.","title":"Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#projeto","text":"Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto : Tutorial-FPGA-NIOS e renomeei para: Tutorial-FPGA-NIOS-IP . Iremos agora trabalhar nessa nova pasta.","title":"Projeto"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-um-periferico","text":"Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver (.c e .h) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1rio uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 claramente um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio.","title":"Criando um perif\u00e9rico"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon-slave-memory-mapped","text":"Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset (`reset), lembre que projeto digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixado em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)?","title":"Avalon Slave Memory Mapped"},{"location":"Tutorial-FPGA-NIOS-IP/#especificacao","text":"Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....).","title":"Especifica\u00e7\u00e3o"},{"location":"Tutorial-FPGA-NIOS-IP/#gerar-hdl-que-representa-o-periferico-com-interface-avalon","text":"Partindo da entidade fornecida (peripheral_MM), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse generic poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Tutorial-FPGA-NIOS-IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto.","title":"Gerar HDL que representa o perif\u00e9rico com interface Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-path","text":"Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fontes que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente)","title":"Configurando path"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-componente","text":"S\u00f3 adicionar o arquivo HDL ( .vhd ou .v verilog) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso : File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente.","title":"Criando componente"},{"location":"Tutorial-FPGA-NIOS-IP/#files","text":"Na aba Files adicione o arquivo peripheral-LED.vhd : Files Syntesis Files add file peripheral-LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral-LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese.","title":"Files"},{"location":"Tutorial-FPGA-NIOS-IP/#signals-interfaces","text":"Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir :","title":"Signals &amp; Interfaces"},{"location":"Tutorial-FPGA-NIOS-IP/#finalizando","text":"Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC : Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus : tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral-LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd E edite para: add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-pd","text":"Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como : Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model","title":"Utilizando o componente no PD"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-toplevelvhd","text":"Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no topLevel.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o topLevel.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 .","title":"Utilizando o componente no topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS-IP/#firmware","text":"Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um novo BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral-LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m).","title":"Firmware"},{"location":"Tutorial-FPGA-NIOS-IP/#executando","text":"Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1.","title":"Executando"},{"location":"Tutorial-FPGA-NIOS-IP/#simulando","text":"Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem : 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado.","title":"Simulando"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-o-bsp","text":"Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!!","title":"Configurando o bsp"},{"location":"Tutorial-FPGA-NIOS-IP/#modelsim","text":"No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Altera. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo.","title":"ModelSim"},{"location":"Tutorial-FPGA-NIOS-IP/#entrega-3","text":"Siga para a terceira entrega: Entega 3","title":"Entrega 3"},{"location":"Tutorial-FPGA-NIOS/","text":"Tutorial 2 - FPGA - NIOS \u00b6 Nesse tutorial iremos criar e customizar um soft processor (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado. Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-NIOS Soft processor \u00b6 Projetos em HDL n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 algo imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um c\u00f3digo em HDL: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA,..) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente/ open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Existem SoCs que n\u00e3o s\u00e3o implementados em FPGAs, mas ainda assim concentram uma s\u00e9rie de outros componentes em um \u00fanico chip, \u00e9 o caso dos SoCs utilizados em celulares. Esses dispositivos, muitas vezes utilizam SoCs que possuem al\u00e9m da parte de processamento, sistemas respons\u00e1veis pela comunica\u00e7\u00e3o pela: interface gr\u00e1fica; gest\u00e3o des c\u00e2meras; comunica\u00e7\u00e3o 4g; .... A Qualcomm \u00e9 uma das empresas lideres do setor com o dispositivo SnapDragon . Plataform Designer \u00b6 O Platform Designer era chamado de QSYS, ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela INtel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar Intellectual property cores (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Quer se aprofundar? Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer NIOS \u00b6 NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits e controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas a seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: Combinacional; Multiciclo; Estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Para maiores detalhes consulte o documento : Nios II Custom Instruction User Guide Criando um simples SoC \u00b6 Nesse etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta do projeto da Entrega-1 renomeando para Tutorial-FPGA-NIOS Abra essa nova pasta Tutorial-FPGA-NIOS no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos: On-Chip Memmory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Type: NIOS II/e Voc\u00ea deve obter algo similar a: Conectando Clock e Reset \u00b6 Os perif\u00e9ricos do Qsys s\u00e3o como sistemas independentes (pensem em cada bloco \u00e9 como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel muito mais superior. O Qsys ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 , conforme figura a seguir: Conectando barramento \u00b6 A Altera define dois tipos de barramento de dados para o Qsys: Avalon e AXI. O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Interface Specifications O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transforma uma forma de comunica\u00e7\u00e3o na outra. Em um futuro breve n\u00f3s iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Melhorando o entendimento do sistema. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado no MIPS harvard ele possui dois barramentos, um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware, s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a principio compartilhada entre o dado e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Vamos portanto conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e vamos conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir: Mapa de mem\u00f3ria \u00b6 Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. S\u00e3o duas as maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map Configurando NIOS \u00b6 Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a aba: Parameters . Em Vector configure : Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos). Export \u00b6 A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados para fora do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal. Finalizando \u00b6 Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosHello.qsys na pasta do projeto e clique em Generate HDL , para o Qsys gerar o projeto. Utilizando o componente \u00b6 Ainda no Qsys, clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Anote isso, iremos utilizar na pr\u00f3xima etapa! component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; u0 : component niosHello port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no Qsys possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces: Finalizando \u00b6 Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foi configurado. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no Qsys: No Quartus: Project Add/remove files in project e adicione o arquivo: niosHello/synthesis/niosHello.qip Resultando em: Modificando o topLevel.vhd \u00b6 Agora \u00e9 necess\u00e1rio modificar o topLevel.vhd para incluir o componente niosHello rec\u00e9m criado. Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). library IEEE ; use IEEE.std_logic_1164. all ; entity topLevel is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity topLevel ; architecture rtl of topLevel is component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; begin u0 : component niosHello port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Compilando e gravando Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA. Programando o NIOS - Soft processor \u00b6 Agora que temos o projeto criado e a FPGA gravada com o novo hardware, que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H ardware A bstraction L ayer - HAL) ou como a Intel chama: B oard S uport P ackage (BSP), na qual extrai-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no NIOS II - Eclipse , dois projetos ser\u00e3o criados: Um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT Criando o projeto \u00b6 No Quartus Tools NIOS II - Eclipse No NIOS II - Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosHello.sopc Esse arquivo \u00e9 criado pelo Qsys quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name: niosHello Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosHello : firmware a ser embarcado niosHello_bsp : Board support package para o firmware Analisando e configurando o bsp \u00b6 No Project Explorer do Eclipse, clique com o bot\u00e3o direito no: Project Explorer niosHello_bsp NIOS II bsp Editor Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas : sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA). Jtag-UART small driver \u00b6 Note que no nosso projeto no QSYS o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver Gerando o bsp \u00b6 Toda vez que o bsp for editado ou o hardware alterado (qsys) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosHello_bsp NIOS II Generate BSP Embarcando! \u00b6 Com o bsp editado abra agora a pasta niosHello e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console : Blink LED \u00b6 Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS! Entrega 2 \u00b6 Siga para a Entrega 2","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#tutorial-2-fpga-nios","text":"Nesse tutorial iremos criar e customizar um soft processor (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado.","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-NIOS","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-NIOS/#soft-processor","text":"Projetos em HDL n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 algo imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um c\u00f3digo em HDL: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA,..) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente/ open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Existem SoCs que n\u00e3o s\u00e3o implementados em FPGAs, mas ainda assim concentram uma s\u00e9rie de outros componentes em um \u00fanico chip, \u00e9 o caso dos SoCs utilizados em celulares. Esses dispositivos, muitas vezes utilizam SoCs que possuem al\u00e9m da parte de processamento, sistemas respons\u00e1veis pela comunica\u00e7\u00e3o pela: interface gr\u00e1fica; gest\u00e3o des c\u00e2meras; comunica\u00e7\u00e3o 4g; .... A Qualcomm \u00e9 uma das empresas lideres do setor com o dispositivo SnapDragon .","title":"Soft processor"},{"location":"Tutorial-FPGA-NIOS/#plataform-designer","text":"O Platform Designer era chamado de QSYS, ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela INtel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar Intellectual property cores (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Quer se aprofundar? Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer","title":"Plataform Designer"},{"location":"Tutorial-FPGA-NIOS/#nios","text":"NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits e controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas a seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: Combinacional; Multiciclo; Estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Para maiores detalhes consulte o documento : Nios II Custom Instruction User Guide","title":"NIOS"},{"location":"Tutorial-FPGA-NIOS/#criando-um-simples-soc","text":"Nesse etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta do projeto da Entrega-1 renomeando para Tutorial-FPGA-NIOS Abra essa nova pasta Tutorial-FPGA-NIOS no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos: On-Chip Memmory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Type: NIOS II/e Voc\u00ea deve obter algo similar a:","title":"Criando um simples SoC"},{"location":"Tutorial-FPGA-NIOS/#conectando-clock-e-reset","text":"Os perif\u00e9ricos do Qsys s\u00e3o como sistemas independentes (pensem em cada bloco \u00e9 como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel muito mais superior. O Qsys ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 , conforme figura a seguir:","title":"Conectando Clock e Reset"},{"location":"Tutorial-FPGA-NIOS/#conectando-barramento","text":"A Altera define dois tipos de barramento de dados para o Qsys: Avalon e AXI. O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Interface Specifications O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transforma uma forma de comunica\u00e7\u00e3o na outra. Em um futuro breve n\u00f3s iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Melhorando o entendimento do sistema. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado no MIPS harvard ele possui dois barramentos, um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware, s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a principio compartilhada entre o dado e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Vamos portanto conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e vamos conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir:","title":"Conectando barramento"},{"location":"Tutorial-FPGA-NIOS/#mapa-de-memoria","text":"Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. S\u00e3o duas as maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map","title":"Mapa de mem\u00f3ria"},{"location":"Tutorial-FPGA-NIOS/#configurando-nios","text":"Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a aba: Parameters . Em Vector configure : Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos).","title":"Configurando NIOS"},{"location":"Tutorial-FPGA-NIOS/#export","text":"A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados para fora do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal.","title":"Export"},{"location":"Tutorial-FPGA-NIOS/#finalizando","text":"Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosHello.qsys na pasta do projeto e clique em Generate HDL , para o Qsys gerar o projeto.","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#utilizando-o-componente","text":"Ainda no Qsys, clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Anote isso, iremos utilizar na pr\u00f3xima etapa! component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; u0 : component niosHello port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no Qsys possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces:","title":"Utilizando o componente"},{"location":"Tutorial-FPGA-NIOS/#finalizando_1","text":"Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foi configurado. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no Qsys: No Quartus: Project Add/remove files in project e adicione o arquivo: niosHello/synthesis/niosHello.qip Resultando em:","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#modificando-o-toplevelvhd","text":"Agora \u00e9 necess\u00e1rio modificar o topLevel.vhd para incluir o componente niosHello rec\u00e9m criado. Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). library IEEE ; use IEEE.std_logic_1164. all ; entity topLevel is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity topLevel ; architecture rtl of topLevel is component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; begin u0 : component niosHello port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Compilando e gravando Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA.","title":"Modificando o topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS/#programando-o-nios-soft-processor","text":"Agora que temos o projeto criado e a FPGA gravada com o novo hardware, que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H ardware A bstraction L ayer - HAL) ou como a Intel chama: B oard S uport P ackage (BSP), na qual extrai-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no NIOS II - Eclipse , dois projetos ser\u00e3o criados: Um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT","title":"Programando o NIOS - Soft processor"},{"location":"Tutorial-FPGA-NIOS/#criando-o-projeto","text":"No Quartus Tools NIOS II - Eclipse No NIOS II - Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosHello.sopc Esse arquivo \u00e9 criado pelo Qsys quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name: niosHello Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosHello : firmware a ser embarcado niosHello_bsp : Board support package para o firmware","title":"Criando o projeto"},{"location":"Tutorial-FPGA-NIOS/#analisando-e-configurando-o-bsp","text":"No Project Explorer do Eclipse, clique com o bot\u00e3o direito no: Project Explorer niosHello_bsp NIOS II bsp Editor Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas : sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA).","title":"Analisando e configurando o bsp"},{"location":"Tutorial-FPGA-NIOS/#jtag-uart-small-driver","text":"Note que no nosso projeto no QSYS o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver","title":"Jtag-UART small driver"},{"location":"Tutorial-FPGA-NIOS/#gerando-o-bsp","text":"Toda vez que o bsp for editado ou o hardware alterado (qsys) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosHello_bsp NIOS II Generate BSP","title":"Gerando o bsp"},{"location":"Tutorial-FPGA-NIOS/#embarcando","text":"Com o bsp editado abra agora a pasta niosHello e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console :","title":"Embarcando!"},{"location":"Tutorial-FPGA-NIOS/#blink-led","text":"Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS!","title":"Blink LED"},{"location":"Tutorial-FPGA-NIOS/#entrega-2","text":"Siga para a Entrega 2","title":"Entrega 2"},{"location":"Tutorial-FPGA-RTL/","text":"Tutorial 1 - FPGA - RTL \u00b6 Nessa primeira etapa do projeto iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. Iremos passar por todo o processo de desenvolvimento de um projeto em FPGA, desde sua cria\u00e7\u00e3o at\u00e9 a valida\u00e7\u00e3o no HW. Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-RTL Quartus \u00b6 Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como RTL_Blink_LED Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA : Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Outra refer\u00eancia Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf Criando o topLevel \u00b6 TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: RTL_Blink_LED.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity RTL_Blink_LED is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity RTL_Blink_LED ; architecture rtl of RTL_Blink_LED is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim por ora. Configurando o topLevel \u00b6 No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar. Verificando \u00b6 Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo. I/Os \u00b6 Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes. Pin Assigment \u00b6 Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel. LEDs \u00b6 No manual da placa (p\u00e1gina 22( temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: Essa tabela define o sinal (que voc\u00ea pode dar qualquer nome), o pino na FPGA na qual est\u00e1 conectado, uma breve descri\u00e7\u00e3o e o n\u00edvel el\u00e9trico de sinal na qual o pino deve ser configurado. Note que a placa DE10-Standard possui 10 LEDs conectados a FPGA. Clocks \u00b6 Tamb\u00e9m temos a defini\u00e7\u00e3o do clock (sec. 3.5, manual da placa): Note que existem 5 diferentes clocks que podem ser utilizado, os FPGA_CLKx_50 s\u00e3o clocks de 50Mhz conectados a FPGA e os HPS_CLKx_25 s\u00e3o sinais de clocks conectados exclusivamente ao ARM (HPS). Como estamos desenvolvendo na FPGA e n\u00e3o temos ainda nenhum requisito de performance, podemos escolher qualquer pino de clock FPGA_CLKx_50 . Vamos usar (escolhido aleat\u00f3rio) o pino CLOCK3_50 . Dom\u00ednios de Clock Tenha em mente que a FPGA trabalha com diferentes dom\u00ednios de clock, quando o projeto possui temporaliza\u00e7\u00e3o cr\u00edtica, essa escolha n\u00e3o pode ser casual. Inserindo no Quartus \u00b6 Agora que temos os pinos referentes aos sinais da FPGA, devemos inserir essa informa\u00e7\u00e3o no Quartus. Existem duas maneiras de fazermos isso: Pin Planner Ferramenta gr\u00e1fica e interativa Assigments Pin Planer Assigments Editor Maneira mais completa e com maior flexibilidade Assigments Assigments Editor Iremos utilizar a princ\u00edpio o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do topLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Edite a coluna Location utilizando como refer\u00eancia a tabela anterior. Note que o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 \u00e9 o 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o Timing Requirements not met \u00b6 Note que ap\u00f3s compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes. Synopsys Design Constraints File \u00b6 Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : RTL_Blink_LED.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto. RTL Viewer \u00b6 RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em : Tools -> NetList Viewers -> RTL Viewer . Gravando \u00b6 Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra : Tools -> Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux . Exerc\u00edcios \u00b6 : F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade Entrega 1 \u00b6 Siga para a Entrega 1","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#tutorial-1-fpga-rtl","text":"Nessa primeira etapa do projeto iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. Iremos passar por todo o processo de desenvolvimento de um projeto em FPGA, desde sua cria\u00e7\u00e3o at\u00e9 a valida\u00e7\u00e3o no HW.","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-RTL","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-RTL/#quartus","text":"Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como RTL_Blink_LED Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA : Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Outra refer\u00eancia Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf","title":"Quartus"},{"location":"Tutorial-FPGA-RTL/#criando-o-toplevel","text":"TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: RTL_Blink_LED.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity RTL_Blink_LED is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity RTL_Blink_LED ; architecture rtl of RTL_Blink_LED is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim por ora.","title":"Criando o topLevel"},{"location":"Tutorial-FPGA-RTL/#configurando-o-toplevel","text":"No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar.","title":"Configurando o topLevel"},{"location":"Tutorial-FPGA-RTL/#verificando","text":"Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo.","title":"Verificando"},{"location":"Tutorial-FPGA-RTL/#ios","text":"Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes.","title":"I/Os"},{"location":"Tutorial-FPGA-RTL/#pin-assigment","text":"Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel.","title":"Pin Assigment"},{"location":"Tutorial-FPGA-RTL/#leds","text":"No manual da placa (p\u00e1gina 22( temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: Essa tabela define o sinal (que voc\u00ea pode dar qualquer nome), o pino na FPGA na qual est\u00e1 conectado, uma breve descri\u00e7\u00e3o e o n\u00edvel el\u00e9trico de sinal na qual o pino deve ser configurado. Note que a placa DE10-Standard possui 10 LEDs conectados a FPGA.","title":"LEDs"},{"location":"Tutorial-FPGA-RTL/#clocks","text":"Tamb\u00e9m temos a defini\u00e7\u00e3o do clock (sec. 3.5, manual da placa): Note que existem 5 diferentes clocks que podem ser utilizado, os FPGA_CLKx_50 s\u00e3o clocks de 50Mhz conectados a FPGA e os HPS_CLKx_25 s\u00e3o sinais de clocks conectados exclusivamente ao ARM (HPS). Como estamos desenvolvendo na FPGA e n\u00e3o temos ainda nenhum requisito de performance, podemos escolher qualquer pino de clock FPGA_CLKx_50 . Vamos usar (escolhido aleat\u00f3rio) o pino CLOCK3_50 . Dom\u00ednios de Clock Tenha em mente que a FPGA trabalha com diferentes dom\u00ednios de clock, quando o projeto possui temporaliza\u00e7\u00e3o cr\u00edtica, essa escolha n\u00e3o pode ser casual.","title":"Clocks"},{"location":"Tutorial-FPGA-RTL/#inserindo-no-quartus","text":"Agora que temos os pinos referentes aos sinais da FPGA, devemos inserir essa informa\u00e7\u00e3o no Quartus. Existem duas maneiras de fazermos isso: Pin Planner Ferramenta gr\u00e1fica e interativa Assigments Pin Planer Assigments Editor Maneira mais completa e com maior flexibilidade Assigments Assigments Editor Iremos utilizar a princ\u00edpio o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do topLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Edite a coluna Location utilizando como refer\u00eancia a tabela anterior. Note que o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 \u00e9 o 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o","title":"Inserindo no Quartus"},{"location":"Tutorial-FPGA-RTL/#timing-requirements-not-met","text":"Note que ap\u00f3s compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes.","title":"Timing Requirements not met"},{"location":"Tutorial-FPGA-RTL/#synopsys-design-constraints-file","text":"Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : RTL_Blink_LED.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto.","title":"Synopsys Design Constraints File"},{"location":"Tutorial-FPGA-RTL/#rtl-viewer","text":"RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em : Tools -> NetList Viewers -> RTL Viewer .","title":"RTL Viewer"},{"location":"Tutorial-FPGA-RTL/#gravando","text":"Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra : Tools -> Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux .","title":"Gravando"},{"location":"Tutorial-FPGA-RTL/#exercicios","text":": F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade","title":"Exerc\u00edcios"},{"location":"Tutorial-FPGA-RTL/#entrega-1","text":"Siga para a Entrega 1","title":"Entrega 1"},{"location":"VHDL/","text":"VHDL \u00b6 Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"},{"location":"VHDL/#vhdl","text":"Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"}]}