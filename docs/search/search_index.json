{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo a Eletiva - Embarcados Avan\u00e7ados (SoC e Linux Embarcado)! \u00b6 Disciplina: Eletiva da Engenharia da Computa\u00e7\u00e3o Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/insper/Embarcados-Avancados Local: Laborat\u00f3rio de Arquitetura de Computadores \u00a9 Todos os direitos reservados OBJETIVOS: \u00b6 Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Motiva\u00e7\u00e3o \u00b6 O que \u00e9 um System On Chip (SoC) ? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e um HardProcessor? x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / apple 2 / microsoft / amazon Como usar o hardware a servi\u00e7o do software? HLS / OpenCL Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na wiki do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final. Infraestrutura \u00b6 Vamos precisar dos softwares listados aqui . Iremos ao longo do curso trabalhar com uma FPGA Intel, o kit \u00e9 o DE10-Standard . Din\u00e2mica \u00b6 A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado. Bibliografia \u00b6 B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008. Para come\u00e7ar \u00b6 Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura recomendada: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html Dispon\u00edvel no lab: [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Home"},{"location":"#bem-vindo-a-eletiva-embarcados-avancados-soc-e-linux-embarcado","text":"Disciplina: Eletiva da Engenharia da Computa\u00e7\u00e3o Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/insper/Embarcados-Avancados Local: Laborat\u00f3rio de Arquitetura de Computadores \u00a9 Todos os direitos reservados","title":"Bem vindo a Eletiva - Embarcados Avan\u00e7ados (SoC e Linux Embarcado)!"},{"location":"#objetivos","text":"Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"OBJETIVOS:"},{"location":"#motivacao","text":"O que \u00e9 um System On Chip (SoC) ? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e um HardProcessor? x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / apple 2 / microsoft / amazon Como usar o hardware a servi\u00e7o do software? HLS / OpenCL","title":"Motiva\u00e7\u00e3o"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na wiki do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final.","title":"Avalia\u00e7\u00e3o"},{"location":"#infraestrutura","text":"Vamos precisar dos softwares listados aqui . Iremos ao longo do curso trabalhar com uma FPGA Intel, o kit \u00e9 o DE10-Standard .","title":"Infraestrutura"},{"location":"#dinamica","text":"A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado.","title":"Din\u00e2mica"},{"location":"#bibliografia","text":"B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008.","title":"Bibliografia"},{"location":"#para-comecar","text":"Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura recomendada: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html Dispon\u00edvel no lab: [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Para come\u00e7ar"},{"location":"Entrega-1/","text":"\ud83d\udc41 Entrega 1 \u00b6 Entrega: Pasta Entrega-1 no git Demonstra\u00e7\u00e3o em sala A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e com o Quartus e que tamb\u00e9m relembrem como desenvolver um projeto de forma hier\u00e1rquica. A partir do tutorial, voc\u00eas devem modificar o projeto para que o controle do LED seja feito por um componente (chamado de LED_peripheral ). Esse componente deve variar a frequ\u00eancia na qual os LEDs piscam com base um vetor de 4 bits, que ser\u00e1 ao final atribuido as chaves SW. E tamb\u00e9m deve possuir um sinal de enable (EN), que s\u00f3 deve funcionar caso positivo. Esse sinal de EN ser\u00e1 atribuido a bot\u00e3o KEY0. Depois de criarem esse novo componente, voc\u00eas devem o utilizar no topLevel para controlar efetivamente os pinos. Rubrica \u00b6 A Entregue um testbench capaz de testar o projeto. A Entregue um testbench capaz de testar o projeto. B O componente faz uso de generics para configura\u00e7\u00e3o interna. C Criou um componente em VHDL que \u00e9 respons\u00e1vel pelo controle do LED Esse componente possui um sinal de entrada de 4 bits que controla a frequ\u00eancia do LEDs, mapeado para as chaves SW. Esse componente possui um sinal de EN, mapeado para o bot\u00e3o KEY0 D Entregou o tutorial I N\u00e3o entregou nada Pr\u00f3ximo passo \u00b6 Siga para o tutorial Tutorial FPGA NIOS","title":"\ud83d\udc41 Entrega 1"},{"location":"Entrega-1/#entrega-1","text":"Entrega: Pasta Entrega-1 no git Demonstra\u00e7\u00e3o em sala A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e com o Quartus e que tamb\u00e9m relembrem como desenvolver um projeto de forma hier\u00e1rquica. A partir do tutorial, voc\u00eas devem modificar o projeto para que o controle do LED seja feito por um componente (chamado de LED_peripheral ). Esse componente deve variar a frequ\u00eancia na qual os LEDs piscam com base um vetor de 4 bits, que ser\u00e1 ao final atribuido as chaves SW. E tamb\u00e9m deve possuir um sinal de enable (EN), que s\u00f3 deve funcionar caso positivo. Esse sinal de EN ser\u00e1 atribuido a bot\u00e3o KEY0. Depois de criarem esse novo componente, voc\u00eas devem o utilizar no topLevel para controlar efetivamente os pinos.","title":"\ud83d\udc41 Entrega 1"},{"location":"Entrega-1/#rubrica","text":"A Entregue um testbench capaz de testar o projeto. A Entregue um testbench capaz de testar o projeto. B O componente faz uso de generics para configura\u00e7\u00e3o interna. C Criou um componente em VHDL que \u00e9 respons\u00e1vel pelo controle do LED Esse componente possui um sinal de entrada de 4 bits que controla a frequ\u00eancia do LEDs, mapeado para as chaves SW. Esse componente possui um sinal de EN, mapeado para o bot\u00e3o KEY0 D Entregou o tutorial I N\u00e3o entregou nada","title":"Rubrica"},{"location":"Entrega-1/#proximo-passo","text":"Siga para o tutorial Tutorial FPGA NIOS","title":"Pr\u00f3ximo passo"},{"location":"Entrega-2/","text":"\ud83d\udc41 Entrega 2 \u00b6 O que deve ser entregue? - Pasta Entrega-1 no git - Demonstra\u00e7\u00e3o em sala Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com os LEDs e bot\u00f5es sendo acionados e lidos pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf Rubrica: \u00b6 I N\u00e3o entregou nada D Entregou somente tutorial C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx e KEYx) Adicione um novo PIO para ler o valor dos bot\u00f5es Interrup\u00e7\u00e3o na leitura do bot\u00e3o B Crie um driver para controlar os LEDs e Ler as chaves (criar uma biblioteca com arquivos .c e .h separados e fun\u00e7\u00f5es), ou : Adicione e fa\u00e7a uso de um timer (Platform Design) A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o","title":"\ud83d\udc41 Entrega 2"},{"location":"Entrega-2/#entrega-2","text":"O que deve ser entregue? - Pasta Entrega-1 no git - Demonstra\u00e7\u00e3o em sala Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com os LEDs e bot\u00f5es sendo acionados e lidos pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf","title":"\ud83d\udc41 Entrega 2"},{"location":"Entrega-2/#rubrica","text":"I N\u00e3o entregou nada D Entregou somente tutorial C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx e KEYx) Adicione um novo PIO para ler o valor dos bot\u00f5es Interrup\u00e7\u00e3o na leitura do bot\u00e3o B Crie um driver para controlar os LEDs e Ler as chaves (criar uma biblioteca com arquivos .c e .h separados e fun\u00e7\u00f5es), ou : Adicione e fa\u00e7a uso de um timer (Platform Design) A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o","title":"Rubrica:"},{"location":"Entrega-3/","text":"\ud83d\udc41 Entrega 3 \u00b6 Nessa entrega iremos encapsular um perif\u00e9rico que \u00e9 respons\u00e1vel pela leitura de um mouse pela interface PS/2 no Plataform Designer (criando um perif\u00e9rico mapeado em mem\u00f3ria). Utilizaremos como c\u00f3digo padr\u00e3o o exemplo fornecido pela terasic para essa placa, dispon\u00edvel no CD do kit: Demonstration/FPGA/DE10_Standard_PS2/ . Rubrica: \u00b6 I N\u00e3o entregou nada D Entregou somente tutorial C PS2 mapeado em mem\u00f3ria lendo X,Y e click Left Fun\u00e7\u00f5es: PS2_init() / PS2_halt() / ps_read_clickLeft() B Aprimorado fun\u00e7\u00f5es do PS2 + ps2.c e ps2.h A PS2 gera interrup\u00e7\u00e3o Hardware \u00b6 O diagrama a seguir \u00e9 uma vis\u00e3o geral do que deve ser feito, nessa concep\u00e7\u00e3o iremos \"encapsular\" o IP da Terasic em um \"perif\u00e9rico mapeado em mem\u00f3ria\" ( PS2-MM ), para isso ser\u00e1 necess\u00e1rio adicionar uma l\u00f3gica extra, normalmente chamada de Glue Logic que realiza a interface entre o barramento e o IP. Perif\u00e9rico Terasic: PS2-Terasic \u00b6 O perif\u00e9rico da Terasic est\u00e1 pode ser encontrado no link a seguir: https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/blob/master/Demonstration/FPGA/DE10_Standard_PS2/v/ps2.v O exemplo que \u00e9 fornecido pela Terasic est\u00e1 em Verilog! mas n\u00e3o \u00e9 preciso desespero, podemos usar no nosso projeto em VHDL, basta declarar o componente e usar normalmente: component ps2 is port ( iSTART : in std_logic ; -- press the button for tranxrdb -merge .Xdefaultssmitting instrucions to device; iRST_n : in std_logic ; -- FSM reset signal; iCLK_50 : in std_logic ; -- clock source; PS2_CLK : inout std_logic ; -- ps2_clock signal inout; PS2_DAT : inout std_logic ; -- ps2_data signal inout; oLEFBUT : out std_logic ; -- left button press display; oRIGBUT : out std_logic ; -- right button press display; oMIDBUT : out std_logic ; -- middle button press display; oX : out std_logic_vector ( 7 downto 0 ); -- X axis. oY : out std_logic_vector ( 7 downto 0 ) -- Y axis. ); end component ps2 ; Esse exemplo est\u00e1 tamb\u00e9m documentando no manual do usu\u00e1rio: DE10-Standard_User_manual.pdf sec\u00e7\u00e3o: 3.6.12. Sec\u00e7\u00e3o: 3.6.12: Manual do usu\u00e1rio: Glue Logic \u00b6 A l\u00f3gica de controle deve interfacear com o perif\u00e9rico da Terasic em todos os sinais de controle (todos menos PS2_CLK / PS2_DATA / iCLK_50 / 'iRST_n') de maneira abstrair o acesso mapeado em mem\u00f3ria para o perif\u00e9rico. A maneira mais f\u00e1cil de fazer isso \u00e9 definindo funcionalidades a endere\u00e7os do perif\u00e9rico, por exemplo: Offset Funcionalidade Tipo 0 Controle R/W 1 ox R 2 oy R 3 oLEFTBUT R ... ... A tabela anterior mapeia para cada endere\u00e7o do perif\u00e9rico uma funcionalidade diferente, nesse exemplo, se o usu\u00e1rio deseja ler a informa\u00e7\u00e3o do deslocamento y: oy , deve fazer a leitura no endere\u00e7o 2 desse perif\u00e9rico. A implementa\u00e7\u00e3o disso pode ser feita por um simples mux . O endere\u00e7o de controle, pode ser usado por exemplo, para inicializar a leitura no perif\u00e9rico da terasic (via o sinal iSTART ). Note que alguns endere\u00e7os s\u00e3o Read Only e outros Read/Write (tipo), isso se d\u00e1 porque n\u00e3o tem sentido (nem \u00e9 poss\u00edvel fisicamente) escrever me alguns endere\u00e7os. (rubrica C) Software \u00b6 Al\u00e9m da parte de HW, iremos desenvolver uma biblioteca em C que ir\u00e1 abstrair a interface com esse perif\u00e9rico. O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: // Para rubrica C int PS2_init ( ..... ); // Inicializa o perif\u00e9rico int PS2_halt ( ..... ); // Desativa o perif\u00e9rico int PS2_read_clickLeft ( ..... ); // retorna se houve algum click (rubrica B) Software (melhorando) \u00b6 Adicionar as seguintes fun\u00e7\u00f5es: // Para rubrica B/A int PS2_read_x ( ..... ); // retorna o valor do movimento X int PS2_read_y ( ..... ); // retorna o valor do movimento y (rubrica A) IRQ \u00b6 Pode-se adicionar um sinal de interrup\u00e7\u00e3o ao perif\u00e9rico PS2-MM que servir\u00e1 para alertar o uC (NIOS) de um evento novo. Ser\u00e1 necess\u00e1rio adicionar as seguintes fun\u00e7\u00f5es: int PS2_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int PS2_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o Esse driver deve estar distribu\u00eddo em dois arquivos: PS2-MM.c e PS2-MM.h . Dicas \u00b6 \u00c9 sugerido os seguintes passos de execu\u00e7\u00e3o da entrega: Executar o exemplo PS2 da Terasic, e ver funcionar Entender os sinais do toplevel desse exemplo Desenhar um diagrama um pouco mais detalhado do PS2-MM, indicando quais sinais (nomes) ser\u00e3o conectados ao Glue Logic e quais dever\u00e3o ser conectados aos pinos da FPGA (conduit no PD) Implementar o 'PS2-MM', usando como base o perif\u00e9rico criado no tutorial. Crie uma nova pasta para o componente dentro da pasta atual IP (exe: PS2-MM) Copie o IP da terasic para essa pasta Crie seu componente dentro dessa pasta","title":"\ud83d\udc41 Entrega 3"},{"location":"Entrega-3/#entrega-3","text":"Nessa entrega iremos encapsular um perif\u00e9rico que \u00e9 respons\u00e1vel pela leitura de um mouse pela interface PS/2 no Plataform Designer (criando um perif\u00e9rico mapeado em mem\u00f3ria). Utilizaremos como c\u00f3digo padr\u00e3o o exemplo fornecido pela terasic para essa placa, dispon\u00edvel no CD do kit: Demonstration/FPGA/DE10_Standard_PS2/ .","title":"\ud83d\udc41 Entrega 3"},{"location":"Entrega-3/#rubrica","text":"I N\u00e3o entregou nada D Entregou somente tutorial C PS2 mapeado em mem\u00f3ria lendo X,Y e click Left Fun\u00e7\u00f5es: PS2_init() / PS2_halt() / ps_read_clickLeft() B Aprimorado fun\u00e7\u00f5es do PS2 + ps2.c e ps2.h A PS2 gera interrup\u00e7\u00e3o","title":"Rubrica:"},{"location":"Entrega-3/#hardware","text":"O diagrama a seguir \u00e9 uma vis\u00e3o geral do que deve ser feito, nessa concep\u00e7\u00e3o iremos \"encapsular\" o IP da Terasic em um \"perif\u00e9rico mapeado em mem\u00f3ria\" ( PS2-MM ), para isso ser\u00e1 necess\u00e1rio adicionar uma l\u00f3gica extra, normalmente chamada de Glue Logic que realiza a interface entre o barramento e o IP.","title":"Hardware"},{"location":"Entrega-3/#periferico-terasic-ps2-terasic","text":"O perif\u00e9rico da Terasic est\u00e1 pode ser encontrado no link a seguir: https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/blob/master/Demonstration/FPGA/DE10_Standard_PS2/v/ps2.v O exemplo que \u00e9 fornecido pela Terasic est\u00e1 em Verilog! mas n\u00e3o \u00e9 preciso desespero, podemos usar no nosso projeto em VHDL, basta declarar o componente e usar normalmente: component ps2 is port ( iSTART : in std_logic ; -- press the button for tranxrdb -merge .Xdefaultssmitting instrucions to device; iRST_n : in std_logic ; -- FSM reset signal; iCLK_50 : in std_logic ; -- clock source; PS2_CLK : inout std_logic ; -- ps2_clock signal inout; PS2_DAT : inout std_logic ; -- ps2_data signal inout; oLEFBUT : out std_logic ; -- left button press display; oRIGBUT : out std_logic ; -- right button press display; oMIDBUT : out std_logic ; -- middle button press display; oX : out std_logic_vector ( 7 downto 0 ); -- X axis. oY : out std_logic_vector ( 7 downto 0 ) -- Y axis. ); end component ps2 ; Esse exemplo est\u00e1 tamb\u00e9m documentando no manual do usu\u00e1rio: DE10-Standard_User_manual.pdf sec\u00e7\u00e3o: 3.6.12. Sec\u00e7\u00e3o: 3.6.12: Manual do usu\u00e1rio:","title":"Perif\u00e9rico Terasic: PS2-Terasic"},{"location":"Entrega-3/#glue-logic","text":"A l\u00f3gica de controle deve interfacear com o perif\u00e9rico da Terasic em todos os sinais de controle (todos menos PS2_CLK / PS2_DATA / iCLK_50 / 'iRST_n') de maneira abstrair o acesso mapeado em mem\u00f3ria para o perif\u00e9rico. A maneira mais f\u00e1cil de fazer isso \u00e9 definindo funcionalidades a endere\u00e7os do perif\u00e9rico, por exemplo: Offset Funcionalidade Tipo 0 Controle R/W 1 ox R 2 oy R 3 oLEFTBUT R ... ... A tabela anterior mapeia para cada endere\u00e7o do perif\u00e9rico uma funcionalidade diferente, nesse exemplo, se o usu\u00e1rio deseja ler a informa\u00e7\u00e3o do deslocamento y: oy , deve fazer a leitura no endere\u00e7o 2 desse perif\u00e9rico. A implementa\u00e7\u00e3o disso pode ser feita por um simples mux . O endere\u00e7o de controle, pode ser usado por exemplo, para inicializar a leitura no perif\u00e9rico da terasic (via o sinal iSTART ). Note que alguns endere\u00e7os s\u00e3o Read Only e outros Read/Write (tipo), isso se d\u00e1 porque n\u00e3o tem sentido (nem \u00e9 poss\u00edvel fisicamente) escrever me alguns endere\u00e7os.","title":"Glue Logic"},{"location":"Entrega-3/#rubrica-c-software","text":"Al\u00e9m da parte de HW, iremos desenvolver uma biblioteca em C que ir\u00e1 abstrair a interface com esse perif\u00e9rico. O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: // Para rubrica C int PS2_init ( ..... ); // Inicializa o perif\u00e9rico int PS2_halt ( ..... ); // Desativa o perif\u00e9rico int PS2_read_clickLeft ( ..... ); // retorna se houve algum click","title":"(rubrica C) Software"},{"location":"Entrega-3/#rubrica-b-software-melhorando","text":"Adicionar as seguintes fun\u00e7\u00f5es: // Para rubrica B/A int PS2_read_x ( ..... ); // retorna o valor do movimento X int PS2_read_y ( ..... ); // retorna o valor do movimento y","title":"(rubrica B) Software (melhorando)"},{"location":"Entrega-3/#rubrica-a-irq","text":"Pode-se adicionar um sinal de interrup\u00e7\u00e3o ao perif\u00e9rico PS2-MM que servir\u00e1 para alertar o uC (NIOS) de um evento novo. Ser\u00e1 necess\u00e1rio adicionar as seguintes fun\u00e7\u00f5es: int PS2_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int PS2_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o Esse driver deve estar distribu\u00eddo em dois arquivos: PS2-MM.c e PS2-MM.h .","title":"(rubrica A) IRQ"},{"location":"Entrega-3/#dicas","text":"\u00c9 sugerido os seguintes passos de execu\u00e7\u00e3o da entrega: Executar o exemplo PS2 da Terasic, e ver funcionar Entender os sinais do toplevel desse exemplo Desenhar um diagrama um pouco mais detalhado do PS2-MM, indicando quais sinais (nomes) ser\u00e3o conectados ao Glue Logic e quais dever\u00e3o ser conectados aos pinos da FPGA (conduit no PD) Implementar o 'PS2-MM', usando como base o perif\u00e9rico criado no tutorial. Crie uma nova pasta para o componente dentro da pasta atual IP (exe: PS2-MM) Copie o IP da terasic para essa pasta Crie seu componente dentro dessa pasta","title":"Dicas"},{"location":"Entrega-4/","text":"\ud83d\udc41 Entrega 4 \u00b6 O objetivo dessa entrega \u00e9 automatizarmos a compila\u00e7\u00e3o e deploy de novos programas para o target . Para isso, teremos que criar um Makefile que deve ser capaz de compilar e fazer o deploy do programa. Para isso temos diversas op\u00e7\u00f5es, sendo alguma delas: Transfer\u00eancia de arquivo via ssh: scp Montar do pasta do target no host remota via ssh: sshfs Via gdb server executa no target um gdb server que possibilita ao host transferir e debugar um bin\u00e1rio. Note que todas as solu\u00e7\u00f5es demandam de conex\u00e3o com a internet, para isso, siga o roteiro: Info HPS Ethernet . Rubrica: \u00b6 A Debuga um programar no target (via gdbserver) B Via Makefile consegue executar o bin\u00e1rio no target make run / make deploy C Criou um Makefile que compila o c\u00f3digo e faz o deploy para o target de um programa make deploy D Entregou somente tutorial I N\u00e3o entregou nada","title":"\ud83d\udc41 Entrega 4"},{"location":"Entrega-4/#entrega-4","text":"O objetivo dessa entrega \u00e9 automatizarmos a compila\u00e7\u00e3o e deploy de novos programas para o target . Para isso, teremos que criar um Makefile que deve ser capaz de compilar e fazer o deploy do programa. Para isso temos diversas op\u00e7\u00f5es, sendo alguma delas: Transfer\u00eancia de arquivo via ssh: scp Montar do pasta do target no host remota via ssh: sshfs Via gdb server executa no target um gdb server que possibilita ao host transferir e debugar um bin\u00e1rio. Note que todas as solu\u00e7\u00f5es demandam de conex\u00e3o com a internet, para isso, siga o roteiro: Info HPS Ethernet .","title":"\ud83d\udc41 Entrega 4"},{"location":"Entrega-4/#rubrica","text":"A Debuga um programar no target (via gdbserver) B Via Makefile consegue executar o bin\u00e1rio no target make run / make deploy C Criou um Makefile que compila o c\u00f3digo e faz o deploy para o target de um programa make deploy D Entregou somente tutorial I N\u00e3o entregou nada","title":"Rubrica:"},{"location":"Entrega-5/","text":"\ud83d\udc41 Entrega 5 \u00b6 Nessa entrega iremos criar um webserver no target que exibir\u00e1 uma imagem capturada por uma c\u00e2mera USB conectada ao SoC. Para isso ser\u00e1 necess\u00e1rio configurar o kernel para possuir o driver USB que lida com a c\u00e2mera USB, o buildroot para ter os programas que ser\u00e3o usados para criar o server e ler a imagem e um programa para orquestrar tudo isso. Dicas Driver webcam Plug no seu PC com linux e verifique qual driver ele utiliza. Acrescente o mesmo no target Aquisi\u00e7\u00e3o de imagens opencv v4l2grab Servidor web python flask apache node A entrega deve conter os arquivos de configura\u00e7\u00e3o (.config) do kernel e do buildroot assim como o programa do webserver. Rubrica: \u00b6 A+ Detecta movimento na imagem e acende o LED do SoC A Exibe a imagem em tempo real (v\u00eddeo) B Exibe a imagem est\u00e1tica (foto) C Captura uma imagem e a salva no embarcado (sem web server) D Entregou somente tutorial I N\u00e3o entregou nada","title":"\ud83d\udc41 Entrega 5"},{"location":"Entrega-5/#entrega-5","text":"Nessa entrega iremos criar um webserver no target que exibir\u00e1 uma imagem capturada por uma c\u00e2mera USB conectada ao SoC. Para isso ser\u00e1 necess\u00e1rio configurar o kernel para possuir o driver USB que lida com a c\u00e2mera USB, o buildroot para ter os programas que ser\u00e3o usados para criar o server e ler a imagem e um programa para orquestrar tudo isso. Dicas Driver webcam Plug no seu PC com linux e verifique qual driver ele utiliza. Acrescente o mesmo no target Aquisi\u00e7\u00e3o de imagens opencv v4l2grab Servidor web python flask apache node A entrega deve conter os arquivos de configura\u00e7\u00e3o (.config) do kernel e do buildroot assim como o programa do webserver.","title":"\ud83d\udc41 Entrega 5"},{"location":"Entrega-5/#rubrica","text":"A+ Detecta movimento na imagem e acende o LED do SoC A Exibe a imagem em tempo real (v\u00eddeo) B Exibe a imagem est\u00e1tica (foto) C Captura uma imagem e a salva no embarcado (sem web server) D Entregou somente tutorial I N\u00e3o entregou nada","title":"Rubrica:"},{"location":"Entrega-6/","text":"\ud83d\udc41 Entrega 6 \u00b6 Desenhe um diagrama de blocos que explica o tutorial anterior (HPS+FPGA)! Nele deve conter: SDCARD ARM DDR3 FPGA perif\u00e9rico PIO","title":"\ud83d\udc41 Entrega 6"},{"location":"Entrega-6/#entrega-6","text":"Desenhe um diagrama de blocos que explica o tutorial anterior (HPS+FPGA)! Nele deve conter: SDCARD ARM DDR3 FPGA perif\u00e9rico PIO","title":"\ud83d\udc41 Entrega 6"},{"location":"Entrega-Extra-1/","text":"\ud83d\udc41 Entrega Opcional 1 \u00b6 Agora que vimos como faz para interfacear ARM com FPGA, que tal voc\u00ea adicionar o perif\u00e9rico que criou na entrega 2 (o peripheral_led ) e controlar os LEDs da FPGA via Linux com o seu pr\u00f3prio perif\u00e9rico? Modifique o platform designer adicionando o seu IP Anote o endere\u00e7o Compile o projeto, gere o .rbf e .dtb (copie para o SDcard) Modifique o main.c para acessar o seu perif\u00e9rico Teste Nota: \u00b6 Essa entrega extra entra como uma nota a mais na m\u00e9dia de valor A (ou seja, quem fez \u00e9 beneficiado e quem n\u00e3o quer fazer, tudo bem!)","title":"\ud83d\udc41 Entrega Opcional 1"},{"location":"Entrega-Extra-1/#entrega-opcional-1","text":"Agora que vimos como faz para interfacear ARM com FPGA, que tal voc\u00ea adicionar o perif\u00e9rico que criou na entrega 2 (o peripheral_led ) e controlar os LEDs da FPGA via Linux com o seu pr\u00f3prio perif\u00e9rico? Modifique o platform designer adicionando o seu IP Anote o endere\u00e7o Compile o projeto, gere o .rbf e .dtb (copie para o SDcard) Modifique o main.c para acessar o seu perif\u00e9rico Teste","title":"\ud83d\udc41 Entrega Opcional 1"},{"location":"Entrega-Extra-1/#nota","text":"Essa entrega extra entra como uma nota a mais na m\u00e9dia de valor A (ou seja, quem fez \u00e9 beneficiado e quem n\u00e3o quer fazer, tudo bem!)","title":"Nota:"},{"location":"Projeto-Entrega-1/","text":"Nessa primeira entrega voc\u00ea deve ter uma sugest\u00e3o de t\u00f3picos que gostaria de atacar e ter em mente qual hardware seria necess\u00e1rio para a execu\u00e7\u00e3o do mesmo, de onde voc\u00ea quer sair e onde quer chegar... Tecnologia Hardware Ponto de partida / Ponto de chegada Exemplos/ sites/ manuais que leu e achou que pode servir como refer\u00eancia","title":"Projeto Entrega 1"},{"location":"Projeto-Overview/","text":"O projeto final da disciplina deve ser um tutorial com alguma rela\u00e7\u00e3o aos objetivos de aprendizagem da mat\u00e9ria: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Alguns exemplos de \u00e1reas que podem ser atacadas: Acelera\u00e7\u00e3o/ implementa\u00e7\u00e3o de algum algor\u00edtimo em hardware processamento de dados, FFT, compress\u00e3o, criptografia, ... HLD/ HLS/ OpenCL/ FPGA Amazon Compara\u00e7\u00e3o de performance entre diferentes tecnologias SoC vs GPU vs FPGA vs uC Sistema operacional Escalonador real time kernel linux, Android, RTOS embarcado Tecnologias/ Ferramentas \u00b6 A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) \ud83d\udc4d OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL .... Hardwares \u00b6 Temos os seguintes kits de desenvolvimento dispon\u00edvel: A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados com ele Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x Exemplos de temas/ coisas legais \u00b6 \u203c\ufe0f: demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c\ufe0f Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c\ufe0f Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux Rubrica \u00b6 O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Projeto Overview"},{"location":"Projeto-Overview/#tecnologias-ferramentas","text":"A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) \ud83d\udc4d OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL ....","title":"Tecnologias/ Ferramentas"},{"location":"Projeto-Overview/#hardwares","text":"Temos os seguintes kits de desenvolvimento dispon\u00edvel: A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados com ele Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x","title":"Hardwares"},{"location":"Projeto-Overview/#exemplos-de-temas-coisas-legais","text":"\u203c\ufe0f: demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c\ufe0f Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c\ufe0f Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux","title":"Exemplos de temas/ coisas legais"},{"location":"Projeto-Overview/#rubrica","text":"O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Rubrica"},{"location":"Sobre/","text":"Metodologia \u00b6 A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos. Objetivos de Aprendizagem \u00b6 Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Avalia\u00e7\u00e3o \u00b6 Entregas das APS Tutorial","title":"Sobre"},{"location":"Sobre/#metodologia","text":"A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos.","title":"Metodologia"},{"location":"Sobre/#objetivos-de-aprendizagem","text":"Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"Objetivos de Aprendizagem"},{"location":"Sobre/#avaliacao","text":"Entregas das APS Tutorial","title":"Avalia\u00e7\u00e3o"},{"location":"Tutorial-Acelerando-HLS/","text":"Tutorial - Acelerando - HLS \u00b6 HLS (High-Level Synthesis Compiler) \u00e9 uma ferramenta de compila\u00e7\u00e3o que permite criarmos um componente (hardware/ HDL) a partir de uma linguagem de programa\u00e7\u00e3o de alto n\u00edvel (no caso c++). Essa ferramenta facilita muito o desenvolvimento, e abstrai o hardware para software, por\u00e9m ainda \u00e9 preciso ter um conhecimento de hardware para utilizar-lha. Intel \u00b6 The Intel\u00ae HLS Compiler is a high-level synthesis (HLS) tool that takes in untimed C++ as input and generates production-quality register transfer level (RTL) code that is optimized for Intel\u00ae FPGAs. This tool accelerates verification time over RTL by raising the abstraction level for FPGA hardware design. Models developed in C++ are typically verified orders of magnitude faster than RTL. centos \u00b6 Warning Eu s\u00f3 consegui fazer funcionar no centos6, minha solu\u00e7\u00e3o foi a de executar um docker com centos, e instalar as depend\u00eancias nele. Eu executo o HLS via o docker CLI. Note Para facilitar a vida, vamos disponibilizar uma imagem do docker j\u00e1 configurada. Veja com o seu professor como conseguir. HLS \u00b6 Vamos gerar um componente que aplica um offset (proc) em uma imagem, para isso, esse componente ter\u00e1 duas interfaces avalon de acesso a mem\u00f3ria (AVALON-MM), na primeira interface, iremos acessar a imagem original e na outra iremos escrever a imagem processada. O nosso hardware ter\u00e1 o seguinte formato: |-----| AXI | ARM | =========================== |-----| | | | | |-------| |-------| | Min | | Mout | |-------| |-------| AVALON-MM | ^ V | |-------| | | Proc |---------- AVALON-MM | (HLS) | |-------| Min: Mem\u00f3ria da FPGA onde iremos salvar a imagem original Mout: Mem\u00f3ria na FPGA onde iremos salvar a imagem processada TH: Perif\u00e9rico criado pelo HLS Para isso, iremos utilizar um sintax pr\u00f3pria do HLS que define como em C qual tipo de interface ser\u00e1 utilizada no componente (lembre das interfaces AVALON, memmory maped e streaming). O HLS permite que validemos o c\u00f3digo em duas camadas distintas: a primeira \u00e9 compilando o mesmo c\u00f3digo que ser\u00e1 sintetizado para arquitetura x86, com isso conseguimos validar o algor\u00edtimo de forma mais r\u00e1pida, a segunda \u00e9 gerando o HDL do componente e simulando via modelsim, tudo isso \u00e9 feito de forma transparente e autom\u00e1tica pela ferramenta. Note A simula\u00e7\u00e3o do hardware \u00e9 custosa em termos de tempo de processamento e poder computacional, ela deve ser a ultima coisa a ser feita, antes de usar o componente no hardware. Valide antes compilando para x86 e ent\u00e3o simule. Offset \u00b6 A fun\u00e7\u00e3o a ser acelerada \u00e9 a seguinte ( imgOffSet ): #define OFFSET 50 typedef ihc :: mm_master < unsigned char , ihc :: aspace < 1 > , ihc :: awidth < 32 > , ihc :: dwidth < 8 > > Master1 ; typedef ihc :: mm_master < unsigned char , ihc :: aspace < 2 > , ihc :: awidth < 32 > , ihc :: dwidth < 8 > > Master2 ; // just for a NxN image inline uint pxToMem ( uint x , uint y , uint N ){ return ( x + y * N ); } // px + OFFSET hls_avalon_slave_component component void imgOffSet ( Master1 & imgIn , Master2 & imgOut , hls_avalon_slave_register_argument int offSet , hls_avalon_slave_register_argument int N ){ for ( int y = 0 ; y < N ; y ++ ){ #pragma unroll 8 for ( int x = 0 ; x < N ; x ++ ){ int px = pxToMem ( x , y , N ); unsigned int tpx = (( unsigned int ) imgIn [ px ]) + offSet ; if ( tpx > 255 ) imgOut [ px ] = 255 ; else imgOut [ px ] = tpx ; } } } Note que a fun\u00e7\u00e3o imgOffSet possui quatro argumentos: imgIn , imgOut , offSet e N . Os dois primeiros s\u00e3o ponteiros de mem\u00f3ria, que \u00e9 respectivamente onde o componente vai fazer a leitura da imagem e onde ele vai fazer a escrita da imagem. J\u00e1 os argumentos offSet e N s\u00e3o: valor a ser aplicado de offSet no px e o tamanho da imagem em pxs, esse argumentos s\u00e3o do tipo hls_avalon_slave_register_argument , que ser\u00e1 convertido para um banco de registradores. Al\u00e9m dessas entradas e sa\u00eddas, para cada interface do tipo mm_master o HLS vai criar mais um conduit , que ser\u00e1 o offset de endere\u00e7o na qual ele deve acessar o dado (para a fun\u00e7\u00e3o o endere\u00e7o 0 \u00e9 relativo). E mais dois conduits , um para controlar o inicio do processamento (chamada de fun\u00e7\u00e3o/ call ) e outro para informar sobre o status do processamento ( return ). imgIn , imgOut \u00b6 Os dois primeiros argumento s\u00e3o do tipo ihc::mm_master< unsigned char, que significa que ser\u00e3o traduzidos para um barramento do tipo Avalon e que devem ser tradados como unsigned char . ihc::aspace<n> : e um identificador \u00fanico do barramento (1,2,3,4,...) ihc::awidth<32> : Define o tamanho do barramento de endere\u00e7o, nesse caso 32 bits ihc::dwidth<8> : Define o tamanho do barramento de dados, nesse caso 8 (leitura de 8 bits) Existem outras configura\u00e7\u00f5es do barramento que podem ser feitas nessa declara\u00e7\u00e3o: lat\u00eancia/ waitrequest/ burst/ ( , ihc::latency<0>, ihc::maxburst<8>, ihc::waitrequest<true> )... pxToMem() \u00b6 Para facilitar o desenvolvimento, a fun\u00e7\u00e3o pxToMem(x,y,N) traduz um acesso a px por endere\u00e7o na matriz para o endere\u00e7o de mem\u00f3ria do px. printf() \u00b6 Essa fun\u00e7\u00e3o ser\u00e1 removida quando a fun\u00e7\u00e3o for compilada para hardware, ela s\u00f3 est\u00e1 dispon\u00edvel para simula\u00e7\u00e3o e testes. offSet , n \u00b6 Precisamos lembrar que estamos criando um componente que resolver\u00e1 um c\u00f3digo em C, e a maneira de conseguirmos passar argumentos para um componente \u00e9 criando uma mem\u00f3ria interna, que chamamos normalmente de banco de registrador e dando funcionalidade para eles. \u00c9 dessa maneira, que os par\u00e2metros offSet e n ser\u00e3o criados. Na gera\u00e7\u00e3o do componente, uma mem\u00f3ria ser\u00e1 inicializada e endere\u00e7os ser\u00e3o reservados para o offSet e n , como no exemplo a seguir: /******************************************************************************/ /* Memory Map Summary */ /******************************************************************************/ /* Register | Access | Register Contents | Description Address | | (64-bits) | ------------|---------|--------------------------|----------------------------- 0x0 | R | {reserved[62:0], | Read the busy status of | | busy[0:0]} | the component | | | 0 - the component is ready | | | to accept a new start | | | 1 - the component cannot | | | accept a new start ------------|---------|--------------------------|----------------------------- 0x8 | W | {reserved[62:0], | Write 1 to signal start to | | start[0:0]} | the component ------------|---------|--------------------------|----------------------------- 0x10 | R/W | {reserved[62:0], | 0 - Disable interrupt, | | interrupt_enable[0:0]} | 1 - Enable interrupt ------------|---------|--------------------------|----------------------------- 0x18 | R/Wclr | {reserved[61:0], | Signals component completion | | done[0:0], | done is read-only and | | interrupt_status[0:0]} | interrupt_status is write 1 | | | to clear ------------|---------|--------------------------|----------------------------- 0x20 | R/W | {reserved[31:0], | Argument offSet | | offSet[31:0]} | ------------|---------|--------------------------|----------------------------- 0x28 | R/W | {reserved[31:0], | Argument N | | N[31:0]} | `` ### main.c A fim de validarmos o projeto, devemos criar uma fun\u00e7\u00e3o main (que n\u00e3o ser\u00e1 compilada para o hardware). Nessa fun\u00e7\u00e3o, abrimos um arquivo de imagem no formato `.pgm` (\"in.pgm\") e geramos outro arquivo de imagem, com a imagem original processada (\"out.pgm\"). A fim de validarmos o componente a ser gerado ( `offSetImg()` ) devemos alocar duas regi\u00f5es de mem\u00f3rias cont\u00ednuas (`in[M_SIZE]` e `out[M_SIZE)` que ser\u00e3o utilizadas como input do componente (simulando o barramento AVALON). ```c int main(void) { int N = IMG_W; int M_SIZE = N*N; // create memorys unsigned char in[M_SIZE]; unsigned char out[M_SIZE]; memset(out,0,sizeof(out)); /* -------------------------- */ /* reading img to mem */ /* -------------------------- */ printf ( \"loading img \\n \" ); readImgPgm ( IMG_IN , in , M_SIZE ); /* -------------------------- */ /* create fake memorys components*/ /* -------------------------- */ Master1 mm_in ( in , M_SIZE ); Master2 mm_out ( out , M_SIZE ); /* -------------------------- */ /* process with kernel */ /* -------------------------- */ printf ( \"kernel \\n \" ); imgOffSet ( mm_in , mm_out , N ); /* -------------------------- */ /* img out */ /* -------------------------- */ printf ( \"outputing \\n \" ); writeImgPgm ( IMG_OUT , out ) return 0 ; } Note Quando formos executar a fun\u00e7\u00e3o imgOffSet no nosso hardware, n\u00e3o ser\u00e1 t\u00e3o simples quanto apenas uma chamada de fun\u00e7\u00e3o. Testando (x86) \u00b6 Note Deve ser feito no centos (docker) Para testar, vamos compilar o nosso projeto para x86 (n\u00e3o ser\u00e1 um hardware) e validar se nossa l\u00f3gica est\u00e1 correta. Se funcionar, compilamos para hardware. Para compilar basta usarmos o compilador i++ como no exemplo a seguir: $ i++ image.cpp -march = x86-64 -o image_x86 E testar o programa gerado: $ ./image_x86 O resultado deve ser a bel\u00edssima foto img.ppm do seu professor, processada com um offset ( out.ppm ): Tip Para gerar uma imagem do tipo ppm voc\u00ea pode usar o Gimp Note Essa execu\u00e7\u00e3o \u00e9 como se tiv\u00e9ssemos compilado com gcc, s\u00f3 serve para validar l\u00f3gica input output img.pgm image (bin\u00e1rio) image.cpp out.pgm Acelerando na FPGA \u00b6 Para acelerar na FPGA, vamos compilar novamente a aplica\u00e7\u00e3o, por\u00e9m agora com a flag -march=CycloneV que representa a nossa FPGA $ i++ image.cpp -march = CycloneV -o image-CycloneV Note Isso pode bastante tempo, o que ele vai fazer \u00e9: Gerar um HDL a partir da sua fun\u00e7\u00e3o Criar um componente para o Platform Designer input output img.pgm image-CycloneV.prj (pasta) image-CycloneV.prj (pasta) \u00b6 Se reparar na pasta do projeto, deve ter uma pasta nova: image-CycloneV.prj , com o seguinte conte\u00fado: components : Pasta com o componente criado (para ser usado no Platform designer) quartus : Pasta do projeto Quartus utilizado para compilar o componente, n\u00e3o vamos usar report : Pasta com reports gerado pela ferramenta (html) report : Pasta para simular o projeto testando \u00b6 Agora podemos testar nossa aplica\u00e7\u00e3o utilizando o hardware criado pelo HLS, para isso basta executar o novo bin\u00e1rio criado quando compilamos para a arquitetura CycloneV . $ ./image-CycloneV Warning Isso vai levar muito tempo! No monstrinho do lab de Arquitetura, levou mais de 1 hora! Essa simula\u00e7\u00e3o \u00e9 realizada no modelsim! A n\u00edvel de hardware. O resultado ser\u00e1 o esperado quando formos embarcar na FPGA. Com essa simula\u00e7\u00e3o conseguimos verificar erros de arredondamento, acesso a mem\u00f3ria, entre outros. Tipa A imagem out-CycloneV.pgm que est\u00e1 na pasta do projeto, \u00e9 o resultado dessa simula\u00e7\u00e3o. report \u00b6 O HLS gera um relat\u00f3rio da compila\u00e7\u00e3o do hardware, ele pode ser encontrado em: reports/report.html . Um report interessante de se analisar \u00e9 o Loops analysis , que demonstra os loops do programa: Otimizando \u00b6 Podemos aplicar diversas t\u00e9cnicas de paraleliza\u00e7\u00e3o no software que ir\u00e1 impactar no hardware criado (\u00e1rea e performance), no manual do HLS ( Intel High Level Synthesis Compiler: Reference Manual ) tem a documenta\u00e7\u00e3o que descreve cada uma das t\u00e9cnicas. Vamos utilizar a do Loop Unrolling , que permite executarmos um loop paralelo: #pragma unroll <N> for ( int i = 0 ; i < M ; ++ i ) { // Some useful work } Tip N \u00e9 a quantidade de loops a serem executado em //. Vamos paralelizar a varredura da linha em 8 execu\u00e7\u00f5es em paralelo, para isso adicione no for que varre a linha (x): for ( int y = 0 ; y < N ; y ++ ){ #pragma unroll 8 for ( int x = 0 ; x < N ; x ++ ){ Criando um hardware \u00b6 Agora com o componente criado \u00e9 necess\u00e1rio adicionarmos ele no hardware, isso ser\u00e1 feito via Plataform Design. Para facilitar o desenvolvimento, vamos usar o projeto de hw exemplo da Terasic : DE10_Standard_FB e modificar inserindo o componente e duas mem\u00f3rias, como indicado a seguir:","title":"Tutorial - Acelerando - HLS"},{"location":"Tutorial-Acelerando-HLS/#tutorial-acelerando-hls","text":"HLS (High-Level Synthesis Compiler) \u00e9 uma ferramenta de compila\u00e7\u00e3o que permite criarmos um componente (hardware/ HDL) a partir de uma linguagem de programa\u00e7\u00e3o de alto n\u00edvel (no caso c++). Essa ferramenta facilita muito o desenvolvimento, e abstrai o hardware para software, por\u00e9m ainda \u00e9 preciso ter um conhecimento de hardware para utilizar-lha.","title":"Tutorial - Acelerando - HLS"},{"location":"Tutorial-Acelerando-HLS/#intel","text":"The Intel\u00ae HLS Compiler is a high-level synthesis (HLS) tool that takes in untimed C++ as input and generates production-quality register transfer level (RTL) code that is optimized for Intel\u00ae FPGAs. This tool accelerates verification time over RTL by raising the abstraction level for FPGA hardware design. Models developed in C++ are typically verified orders of magnitude faster than RTL.","title":"Intel"},{"location":"Tutorial-Acelerando-HLS/#centos","text":"Warning Eu s\u00f3 consegui fazer funcionar no centos6, minha solu\u00e7\u00e3o foi a de executar um docker com centos, e instalar as depend\u00eancias nele. Eu executo o HLS via o docker CLI. Note Para facilitar a vida, vamos disponibilizar uma imagem do docker j\u00e1 configurada. Veja com o seu professor como conseguir.","title":"centos"},{"location":"Tutorial-Acelerando-HLS/#hls","text":"Vamos gerar um componente que aplica um offset (proc) em uma imagem, para isso, esse componente ter\u00e1 duas interfaces avalon de acesso a mem\u00f3ria (AVALON-MM), na primeira interface, iremos acessar a imagem original e na outra iremos escrever a imagem processada. O nosso hardware ter\u00e1 o seguinte formato: |-----| AXI | ARM | =========================== |-----| | | | | |-------| |-------| | Min | | Mout | |-------| |-------| AVALON-MM | ^ V | |-------| | | Proc |---------- AVALON-MM | (HLS) | |-------| Min: Mem\u00f3ria da FPGA onde iremos salvar a imagem original Mout: Mem\u00f3ria na FPGA onde iremos salvar a imagem processada TH: Perif\u00e9rico criado pelo HLS Para isso, iremos utilizar um sintax pr\u00f3pria do HLS que define como em C qual tipo de interface ser\u00e1 utilizada no componente (lembre das interfaces AVALON, memmory maped e streaming). O HLS permite que validemos o c\u00f3digo em duas camadas distintas: a primeira \u00e9 compilando o mesmo c\u00f3digo que ser\u00e1 sintetizado para arquitetura x86, com isso conseguimos validar o algor\u00edtimo de forma mais r\u00e1pida, a segunda \u00e9 gerando o HDL do componente e simulando via modelsim, tudo isso \u00e9 feito de forma transparente e autom\u00e1tica pela ferramenta. Note A simula\u00e7\u00e3o do hardware \u00e9 custosa em termos de tempo de processamento e poder computacional, ela deve ser a ultima coisa a ser feita, antes de usar o componente no hardware. Valide antes compilando para x86 e ent\u00e3o simule.","title":"HLS"},{"location":"Tutorial-Acelerando-HLS/#offset","text":"A fun\u00e7\u00e3o a ser acelerada \u00e9 a seguinte ( imgOffSet ): #define OFFSET 50 typedef ihc :: mm_master < unsigned char , ihc :: aspace < 1 > , ihc :: awidth < 32 > , ihc :: dwidth < 8 > > Master1 ; typedef ihc :: mm_master < unsigned char , ihc :: aspace < 2 > , ihc :: awidth < 32 > , ihc :: dwidth < 8 > > Master2 ; // just for a NxN image inline uint pxToMem ( uint x , uint y , uint N ){ return ( x + y * N ); } // px + OFFSET hls_avalon_slave_component component void imgOffSet ( Master1 & imgIn , Master2 & imgOut , hls_avalon_slave_register_argument int offSet , hls_avalon_slave_register_argument int N ){ for ( int y = 0 ; y < N ; y ++ ){ #pragma unroll 8 for ( int x = 0 ; x < N ; x ++ ){ int px = pxToMem ( x , y , N ); unsigned int tpx = (( unsigned int ) imgIn [ px ]) + offSet ; if ( tpx > 255 ) imgOut [ px ] = 255 ; else imgOut [ px ] = tpx ; } } } Note que a fun\u00e7\u00e3o imgOffSet possui quatro argumentos: imgIn , imgOut , offSet e N . Os dois primeiros s\u00e3o ponteiros de mem\u00f3ria, que \u00e9 respectivamente onde o componente vai fazer a leitura da imagem e onde ele vai fazer a escrita da imagem. J\u00e1 os argumentos offSet e N s\u00e3o: valor a ser aplicado de offSet no px e o tamanho da imagem em pxs, esse argumentos s\u00e3o do tipo hls_avalon_slave_register_argument , que ser\u00e1 convertido para um banco de registradores. Al\u00e9m dessas entradas e sa\u00eddas, para cada interface do tipo mm_master o HLS vai criar mais um conduit , que ser\u00e1 o offset de endere\u00e7o na qual ele deve acessar o dado (para a fun\u00e7\u00e3o o endere\u00e7o 0 \u00e9 relativo). E mais dois conduits , um para controlar o inicio do processamento (chamada de fun\u00e7\u00e3o/ call ) e outro para informar sobre o status do processamento ( return ).","title":"Offset"},{"location":"Tutorial-Acelerando-HLS/#imgin-imgout","text":"Os dois primeiros argumento s\u00e3o do tipo ihc::mm_master< unsigned char, que significa que ser\u00e3o traduzidos para um barramento do tipo Avalon e que devem ser tradados como unsigned char . ihc::aspace<n> : e um identificador \u00fanico do barramento (1,2,3,4,...) ihc::awidth<32> : Define o tamanho do barramento de endere\u00e7o, nesse caso 32 bits ihc::dwidth<8> : Define o tamanho do barramento de dados, nesse caso 8 (leitura de 8 bits) Existem outras configura\u00e7\u00f5es do barramento que podem ser feitas nessa declara\u00e7\u00e3o: lat\u00eancia/ waitrequest/ burst/ ( , ihc::latency<0>, ihc::maxburst<8>, ihc::waitrequest<true> )...","title":"imgIn , imgOut"},{"location":"Tutorial-Acelerando-HLS/#pxtomem","text":"Para facilitar o desenvolvimento, a fun\u00e7\u00e3o pxToMem(x,y,N) traduz um acesso a px por endere\u00e7o na matriz para o endere\u00e7o de mem\u00f3ria do px.","title":"pxToMem()"},{"location":"Tutorial-Acelerando-HLS/#printf","text":"Essa fun\u00e7\u00e3o ser\u00e1 removida quando a fun\u00e7\u00e3o for compilada para hardware, ela s\u00f3 est\u00e1 dispon\u00edvel para simula\u00e7\u00e3o e testes.","title":"printf()"},{"location":"Tutorial-Acelerando-HLS/#offset-n","text":"Precisamos lembrar que estamos criando um componente que resolver\u00e1 um c\u00f3digo em C, e a maneira de conseguirmos passar argumentos para um componente \u00e9 criando uma mem\u00f3ria interna, que chamamos normalmente de banco de registrador e dando funcionalidade para eles. \u00c9 dessa maneira, que os par\u00e2metros offSet e n ser\u00e3o criados. Na gera\u00e7\u00e3o do componente, uma mem\u00f3ria ser\u00e1 inicializada e endere\u00e7os ser\u00e3o reservados para o offSet e n , como no exemplo a seguir: /******************************************************************************/ /* Memory Map Summary */ /******************************************************************************/ /* Register | Access | Register Contents | Description Address | | (64-bits) | ------------|---------|--------------------------|----------------------------- 0x0 | R | {reserved[62:0], | Read the busy status of | | busy[0:0]} | the component | | | 0 - the component is ready | | | to accept a new start | | | 1 - the component cannot | | | accept a new start ------------|---------|--------------------------|----------------------------- 0x8 | W | {reserved[62:0], | Write 1 to signal start to | | start[0:0]} | the component ------------|---------|--------------------------|----------------------------- 0x10 | R/W | {reserved[62:0], | 0 - Disable interrupt, | | interrupt_enable[0:0]} | 1 - Enable interrupt ------------|---------|--------------------------|----------------------------- 0x18 | R/Wclr | {reserved[61:0], | Signals component completion | | done[0:0], | done is read-only and | | interrupt_status[0:0]} | interrupt_status is write 1 | | | to clear ------------|---------|--------------------------|----------------------------- 0x20 | R/W | {reserved[31:0], | Argument offSet | | offSet[31:0]} | ------------|---------|--------------------------|----------------------------- 0x28 | R/W | {reserved[31:0], | Argument N | | N[31:0]} | `` ### main.c A fim de validarmos o projeto, devemos criar uma fun\u00e7\u00e3o main (que n\u00e3o ser\u00e1 compilada para o hardware). Nessa fun\u00e7\u00e3o, abrimos um arquivo de imagem no formato `.pgm` (\"in.pgm\") e geramos outro arquivo de imagem, com a imagem original processada (\"out.pgm\"). A fim de validarmos o componente a ser gerado ( `offSetImg()` ) devemos alocar duas regi\u00f5es de mem\u00f3rias cont\u00ednuas (`in[M_SIZE]` e `out[M_SIZE)` que ser\u00e3o utilizadas como input do componente (simulando o barramento AVALON). ```c int main(void) { int N = IMG_W; int M_SIZE = N*N; // create memorys unsigned char in[M_SIZE]; unsigned char out[M_SIZE]; memset(out,0,sizeof(out)); /* -------------------------- */ /* reading img to mem */ /* -------------------------- */ printf ( \"loading img \\n \" ); readImgPgm ( IMG_IN , in , M_SIZE ); /* -------------------------- */ /* create fake memorys components*/ /* -------------------------- */ Master1 mm_in ( in , M_SIZE ); Master2 mm_out ( out , M_SIZE ); /* -------------------------- */ /* process with kernel */ /* -------------------------- */ printf ( \"kernel \\n \" ); imgOffSet ( mm_in , mm_out , N ); /* -------------------------- */ /* img out */ /* -------------------------- */ printf ( \"outputing \\n \" ); writeImgPgm ( IMG_OUT , out ) return 0 ; } Note Quando formos executar a fun\u00e7\u00e3o imgOffSet no nosso hardware, n\u00e3o ser\u00e1 t\u00e3o simples quanto apenas uma chamada de fun\u00e7\u00e3o.","title":"offSet, n"},{"location":"Tutorial-Acelerando-HLS/#testando-x86","text":"Note Deve ser feito no centos (docker) Para testar, vamos compilar o nosso projeto para x86 (n\u00e3o ser\u00e1 um hardware) e validar se nossa l\u00f3gica est\u00e1 correta. Se funcionar, compilamos para hardware. Para compilar basta usarmos o compilador i++ como no exemplo a seguir: $ i++ image.cpp -march = x86-64 -o image_x86 E testar o programa gerado: $ ./image_x86 O resultado deve ser a bel\u00edssima foto img.ppm do seu professor, processada com um offset ( out.ppm ): Tip Para gerar uma imagem do tipo ppm voc\u00ea pode usar o Gimp Note Essa execu\u00e7\u00e3o \u00e9 como se tiv\u00e9ssemos compilado com gcc, s\u00f3 serve para validar l\u00f3gica input output img.pgm image (bin\u00e1rio) image.cpp out.pgm","title":"Testando (x86)"},{"location":"Tutorial-Acelerando-HLS/#acelerando-na-fpga","text":"Para acelerar na FPGA, vamos compilar novamente a aplica\u00e7\u00e3o, por\u00e9m agora com a flag -march=CycloneV que representa a nossa FPGA $ i++ image.cpp -march = CycloneV -o image-CycloneV Note Isso pode bastante tempo, o que ele vai fazer \u00e9: Gerar um HDL a partir da sua fun\u00e7\u00e3o Criar um componente para o Platform Designer input output img.pgm image-CycloneV.prj (pasta)","title":"Acelerando na FPGA"},{"location":"Tutorial-Acelerando-HLS/#image-cyclonevprj-pasta","text":"Se reparar na pasta do projeto, deve ter uma pasta nova: image-CycloneV.prj , com o seguinte conte\u00fado: components : Pasta com o componente criado (para ser usado no Platform designer) quartus : Pasta do projeto Quartus utilizado para compilar o componente, n\u00e3o vamos usar report : Pasta com reports gerado pela ferramenta (html) report : Pasta para simular o projeto","title":"image-CycloneV.prj (pasta)"},{"location":"Tutorial-Acelerando-HLS/#testando","text":"Agora podemos testar nossa aplica\u00e7\u00e3o utilizando o hardware criado pelo HLS, para isso basta executar o novo bin\u00e1rio criado quando compilamos para a arquitetura CycloneV . $ ./image-CycloneV Warning Isso vai levar muito tempo! No monstrinho do lab de Arquitetura, levou mais de 1 hora! Essa simula\u00e7\u00e3o \u00e9 realizada no modelsim! A n\u00edvel de hardware. O resultado ser\u00e1 o esperado quando formos embarcar na FPGA. Com essa simula\u00e7\u00e3o conseguimos verificar erros de arredondamento, acesso a mem\u00f3ria, entre outros. Tipa A imagem out-CycloneV.pgm que est\u00e1 na pasta do projeto, \u00e9 o resultado dessa simula\u00e7\u00e3o.","title":"testando"},{"location":"Tutorial-Acelerando-HLS/#report","text":"O HLS gera um relat\u00f3rio da compila\u00e7\u00e3o do hardware, ele pode ser encontrado em: reports/report.html . Um report interessante de se analisar \u00e9 o Loops analysis , que demonstra os loops do programa:","title":"report"},{"location":"Tutorial-Acelerando-HLS/#otimizando","text":"Podemos aplicar diversas t\u00e9cnicas de paraleliza\u00e7\u00e3o no software que ir\u00e1 impactar no hardware criado (\u00e1rea e performance), no manual do HLS ( Intel High Level Synthesis Compiler: Reference Manual ) tem a documenta\u00e7\u00e3o que descreve cada uma das t\u00e9cnicas. Vamos utilizar a do Loop Unrolling , que permite executarmos um loop paralelo: #pragma unroll <N> for ( int i = 0 ; i < M ; ++ i ) { // Some useful work } Tip N \u00e9 a quantidade de loops a serem executado em //. Vamos paralelizar a varredura da linha em 8 execu\u00e7\u00f5es em paralelo, para isso adicione no for que varre a linha (x): for ( int y = 0 ; y < N ; y ++ ){ #pragma unroll 8 for ( int x = 0 ; x < N ; x ++ ){","title":"Otimizando"},{"location":"Tutorial-Acelerando-HLS/#criando-um-hardware","text":"Agora com o componente criado \u00e9 necess\u00e1rio adicionarmos ele no hardware, isso ser\u00e1 feito via Plataform Design. Para facilitar o desenvolvimento, vamos usar o projeto de hw exemplo da Terasic : DE10_Standard_FB e modificar inserindo o componente e duas mem\u00f3rias, como indicado a seguir:","title":"Criando um hardware"},{"location":"Tutorial-FPGA-NIOS-IP/","text":"Tutorial 3 - FPGA - IP \u00b6 Nesse tutorial deseja-se desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa, o perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\". Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Tutorial-FPGA-NIOS-IP IP Cores \u00b6 Intelectual Proprety Core (IP Core) s\u00e3o componentes descritos em HDL que possibilitam ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m da centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Altera IP cores Platform Desginer \u00b6 O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido a padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento. Barramentos \u00b6 A Altera define dois tipos de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no plataform designer. Avalon \u00b6 Documenta\u00e7\u00e3o completa dos tipos do barramento AVALON : https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o : Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity. Projeto \u00b6 Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto : Tutorial-FPGA-NIOS e renomeei para: Tutorial-FPGA-NIOS-IP . Iremos agora trabalhar nessa nova pasta. Criando um perif\u00e9rico \u00b6 Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver (.c e .h) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1rio uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 claramente um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio. Avalon Slave Memory Mapped \u00b6 Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset (`reset), lembre que projeto digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixado em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)? Especifica\u00e7\u00e3o \u00b6 Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....). Gerar HDL que representa o perif\u00e9rico com interface Avalon \u00b6 Partindo da entidade fornecida (peripheral_MM), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse generic poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Tutorial-FPGA-NIOS-IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto. Configurando path \u00b6 Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fontes que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente) Criando componente \u00b6 S\u00f3 adicionar o arquivo HDL ( .vhd ou .v verilog) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso : File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente. Files \u00b6 Na aba Files adicione o arquivo peripheral-LED.vhd : Files Syntesis Files add file peripheral-LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral-LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese. Signals & Interfaces \u00b6 Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir : Finalizando \u00b6 Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC : Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus : tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral-LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd E edite para: add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd Utilizando o componente no PD \u00b6 Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como : Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model Utilizando o componente no topLevel.vhd \u00b6 Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no topLevel.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o topLevel.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 . Firmware \u00b6 Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um novo BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral-LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m). Executando \u00b6 Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1. Simulando \u00b6 Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem : 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado. Configurando o bsp \u00b6 Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!! ModelSim \u00b6 No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Altera. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo. Entrega 3 \u00b6 Siga para a terceira entrega: Entega 3","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#tutorial-3-fpga-ip","text":"Nesse tutorial deseja-se desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa, o perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\".","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Tutorial-FPGA-NIOS-IP","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-NIOS-IP/#ip-cores","text":"Intelectual Proprety Core (IP Core) s\u00e3o componentes descritos em HDL que possibilitam ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m da centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Altera IP cores","title":"IP Cores"},{"location":"Tutorial-FPGA-NIOS-IP/#platform-desginer","text":"O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido a padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento.","title":"Platform Desginer"},{"location":"Tutorial-FPGA-NIOS-IP/#barramentos","text":"A Altera define dois tipos de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no plataform designer.","title":"Barramentos"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon","text":"Documenta\u00e7\u00e3o completa dos tipos do barramento AVALON : https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o : Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity.","title":"Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#projeto","text":"Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto : Tutorial-FPGA-NIOS e renomeei para: Tutorial-FPGA-NIOS-IP . Iremos agora trabalhar nessa nova pasta.","title":"Projeto"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-um-periferico","text":"Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver (.c e .h) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1rio uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 claramente um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio.","title":"Criando um perif\u00e9rico"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon-slave-memory-mapped","text":"Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset (`reset), lembre que projeto digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixado em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)?","title":"Avalon Slave Memory Mapped"},{"location":"Tutorial-FPGA-NIOS-IP/#especificacao","text":"Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....).","title":"Especifica\u00e7\u00e3o"},{"location":"Tutorial-FPGA-NIOS-IP/#gerar-hdl-que-representa-o-periferico-com-interface-avalon","text":"Partindo da entidade fornecida (peripheral_MM), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse generic poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Tutorial-FPGA-NIOS-IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto.","title":"Gerar HDL que representa o perif\u00e9rico com interface Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-path","text":"Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fontes que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente)","title":"Configurando path"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-componente","text":"S\u00f3 adicionar o arquivo HDL ( .vhd ou .v verilog) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso : File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente.","title":"Criando componente"},{"location":"Tutorial-FPGA-NIOS-IP/#files","text":"Na aba Files adicione o arquivo peripheral-LED.vhd : Files Syntesis Files add file peripheral-LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral-LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese.","title":"Files"},{"location":"Tutorial-FPGA-NIOS-IP/#signals-interfaces","text":"Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir :","title":"Signals &amp; Interfaces"},{"location":"Tutorial-FPGA-NIOS-IP/#finalizando","text":"Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC : Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus : tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral-LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd E edite para: add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-pd","text":"Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como : Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model","title":"Utilizando o componente no PD"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-toplevelvhd","text":"Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no topLevel.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o topLevel.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 .","title":"Utilizando o componente no topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS-IP/#firmware","text":"Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um novo BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral-LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m).","title":"Firmware"},{"location":"Tutorial-FPGA-NIOS-IP/#executando","text":"Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1.","title":"Executando"},{"location":"Tutorial-FPGA-NIOS-IP/#simulando","text":"Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem : 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado.","title":"Simulando"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-o-bsp","text":"Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!!","title":"Configurando o bsp"},{"location":"Tutorial-FPGA-NIOS-IP/#modelsim","text":"No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Altera. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo.","title":"ModelSim"},{"location":"Tutorial-FPGA-NIOS-IP/#entrega-3","text":"Siga para a terceira entrega: Entega 3","title":"Entrega 3"},{"location":"Tutorial-FPGA-NIOS/","text":"Tutorial 2 - FPGA - NIOS \u00b6 Nesse tutorial iremos criar e customizar um soft processor (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado. Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-NIOS Soft processor \u00b6 Projetos em HDL n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 algo imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um c\u00f3digo em HDL: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA,..) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente/ open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Existem SoCs que n\u00e3o s\u00e3o implementados em FPGAs, mas ainda assim concentram uma s\u00e9rie de outros componentes em um \u00fanico chip, \u00e9 o caso dos SoCs utilizados em celulares. Esses dispositivos, muitas vezes utilizam SoCs que possuem al\u00e9m da parte de processamento, sistemas respons\u00e1veis pela comunica\u00e7\u00e3o pela: interface gr\u00e1fica; gest\u00e3o des c\u00e2meras; comunica\u00e7\u00e3o 4g; .... A Qualcomm \u00e9 uma das empresas lideres do setor com o dispositivo SnapDragon . Plataform Designer \u00b6 O Platform Designer era chamado de QSYS, ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela INtel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar **Intellectual property cores ** (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Quer se aprofundar? Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer NIOS \u00b6 NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits e controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas a seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: Combinacional; Multiciclo; Estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Para maiores detalhes consulte o documento : Nios II Custom Instruction User Guide Criando um simples SoC \u00b6 Nesse etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta do projeto da Entrega-1 renomeando para Tutorial-FPGA-NIOS Abra essa nova pasta Tutorial-FPGA-NIOS no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos: On-Chip Memmory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Type: NIOS II/e Voc\u00ea deve obter algo similar a: Conectando Clock e Reset \u00b6 Os perif\u00e9ricos do Qsys s\u00e3o como sistemas independentes (pensem em cada bloco \u00e9 como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel muito mais superior. O Qsys ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 , conforme figura a seguir: Conectando barramento \u00b6 A Altera define dois tipos de barramento de dados para o Qsys: Avalon e AXI. O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Interface Specifications O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transforma uma forma de comunica\u00e7\u00e3o na outra. Em um futuro breve n\u00f3s iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Melhorando o entendimento do sistema. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado no MIPS harvard ele possui dois barramentos, um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware, s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a principio compartilhada entre o dado e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Vamos portanto conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e vamos conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir: Mapa de mem\u00f3ria \u00b6 Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. S\u00e3o duas as maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map Configurando NIOS \u00b6 Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a aba: Parameters . Em Vector configure : Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos). Export \u00b6 A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados para fora do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal. Finalizando \u00b6 Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosHello.qsys na pasta do projeto e clique em Generate HDL , para o Qsys gerar o projeto. Utilizando o componente \u00b6 Ainda no Qsys, clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Anote isso, iremos utilizar na pr\u00f3xima etapa! component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; u0 : component niosHello port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no Qsys possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces: Finalizando \u00b6 Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foi configurado. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no Qsys: No Quartus: Project Add/remove files in project e adicione o arquivo: niosHello/synthesis/niosHello.qip Resultando em: Modificando o topLevel.vhd \u00b6 Agora \u00e9 necess\u00e1rio modificar o topLevel.vhd para incluir o componente niosHello rec\u00e9m criado. Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). library IEEE ; use IEEE.std_logic_1164. all ; entity topLevel is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity topLevel ; architecture rtl of topLevel is component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; begin u0 : component niosHello port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Compilando e gravando Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA. Programando o NIOS - Soft processor \u00b6 Agora que temos o projeto criado e a FPGA gravada com o novo hardware, que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H**ardware **A**bstraction **L**ayer - HAL) ou como a Intel chama: **B**oard **S**uport **P**ackage (BSP), na qual extrai-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no **NIOS II - Eclipse , dois projetos ser\u00e3o criados: Um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT Criando o projeto \u00b6 No Quartus Tools NIOS II - Eclipse No NIOS II - Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosHello.sopc Esse arquivo \u00e9 criado pelo Qsys quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name: niosHello Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosHello : firmware a ser embarcado niosHello_bsp : Board support package para o firmware Analisando e configurando o bsp \u00b6 No Project Explorer do Eclipse, clique com o bot\u00e3o direito no: Project Explorer niosHello_bsp NIOS II bsp Editor Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas : sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA). Jtag-UART small driver \u00b6 Note que no nosso projeto no QSYS o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver Gerando o bsp \u00b6 Toda vez que o bsp for editado ou o hardware alterado (qsys) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosHello_bsp NIOS II Generate BSP Embarcando! \u00b6 Com o bsp editado abra agora a pasta niosHello e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console : Blink LED \u00b6 Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS! Entrega 2 \u00b6 Siga para a Entrega 2","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#tutorial-2-fpga-nios","text":"Nesse tutorial iremos criar e customizar um soft processor (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado.","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-NIOS","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-NIOS/#soft-processor","text":"Projetos em HDL n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 algo imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um c\u00f3digo em HDL: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA,..) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente/ open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Existem SoCs que n\u00e3o s\u00e3o implementados em FPGAs, mas ainda assim concentram uma s\u00e9rie de outros componentes em um \u00fanico chip, \u00e9 o caso dos SoCs utilizados em celulares. Esses dispositivos, muitas vezes utilizam SoCs que possuem al\u00e9m da parte de processamento, sistemas respons\u00e1veis pela comunica\u00e7\u00e3o pela: interface gr\u00e1fica; gest\u00e3o des c\u00e2meras; comunica\u00e7\u00e3o 4g; .... A Qualcomm \u00e9 uma das empresas lideres do setor com o dispositivo SnapDragon .","title":"Soft processor"},{"location":"Tutorial-FPGA-NIOS/#plataform-designer","text":"O Platform Designer era chamado de QSYS, ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela INtel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar **Intellectual property cores ** (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Quer se aprofundar? Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer","title":"Plataform Designer"},{"location":"Tutorial-FPGA-NIOS/#nios","text":"NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits e controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas a seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: Combinacional; Multiciclo; Estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Para maiores detalhes consulte o documento : Nios II Custom Instruction User Guide","title":"NIOS"},{"location":"Tutorial-FPGA-NIOS/#criando-um-simples-soc","text":"Nesse etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta do projeto da Entrega-1 renomeando para Tutorial-FPGA-NIOS Abra essa nova pasta Tutorial-FPGA-NIOS no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos: On-Chip Memmory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Type: NIOS II/e Voc\u00ea deve obter algo similar a:","title":"Criando um simples SoC"},{"location":"Tutorial-FPGA-NIOS/#conectando-clock-e-reset","text":"Os perif\u00e9ricos do Qsys s\u00e3o como sistemas independentes (pensem em cada bloco \u00e9 como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel muito mais superior. O Qsys ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 , conforme figura a seguir:","title":"Conectando Clock e Reset"},{"location":"Tutorial-FPGA-NIOS/#conectando-barramento","text":"A Altera define dois tipos de barramento de dados para o Qsys: Avalon e AXI. O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Interface Specifications O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transforma uma forma de comunica\u00e7\u00e3o na outra. Em um futuro breve n\u00f3s iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Melhorando o entendimento do sistema. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado no MIPS harvard ele possui dois barramentos, um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware, s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a principio compartilhada entre o dado e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Vamos portanto conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e vamos conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir:","title":"Conectando barramento"},{"location":"Tutorial-FPGA-NIOS/#mapa-de-memoria","text":"Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. S\u00e3o duas as maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map","title":"Mapa de mem\u00f3ria"},{"location":"Tutorial-FPGA-NIOS/#configurando-nios","text":"Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a aba: Parameters . Em Vector configure : Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos).","title":"Configurando NIOS"},{"location":"Tutorial-FPGA-NIOS/#export","text":"A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados para fora do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal.","title":"Export"},{"location":"Tutorial-FPGA-NIOS/#finalizando","text":"Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosHello.qsys na pasta do projeto e clique em Generate HDL , para o Qsys gerar o projeto.","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#utilizando-o-componente","text":"Ainda no Qsys, clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Anote isso, iremos utilizar na pr\u00f3xima etapa! component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; u0 : component niosHello port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no Qsys possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces:","title":"Utilizando o componente"},{"location":"Tutorial-FPGA-NIOS/#finalizando_1","text":"Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foi configurado. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no Qsys: No Quartus: Project Add/remove files in project e adicione o arquivo: niosHello/synthesis/niosHello.qip Resultando em:","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#modificando-o-toplevelvhd","text":"Agora \u00e9 necess\u00e1rio modificar o topLevel.vhd para incluir o componente niosHello rec\u00e9m criado. Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). library IEEE ; use IEEE.std_logic_1164. all ; entity topLevel is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity topLevel ; architecture rtl of topLevel is component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; begin u0 : component niosHello port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Compilando e gravando Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA.","title":"Modificando o topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS/#programando-o-nios-soft-processor","text":"Agora que temos o projeto criado e a FPGA gravada com o novo hardware, que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H**ardware **A**bstraction **L**ayer - HAL) ou como a Intel chama: **B**oard **S**uport **P**ackage (BSP), na qual extrai-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no **NIOS II - Eclipse , dois projetos ser\u00e3o criados: Um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT","title":"Programando o NIOS - Soft processor"},{"location":"Tutorial-FPGA-NIOS/#criando-o-projeto","text":"No Quartus Tools NIOS II - Eclipse No NIOS II - Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosHello.sopc Esse arquivo \u00e9 criado pelo Qsys quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name: niosHello Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosHello : firmware a ser embarcado niosHello_bsp : Board support package para o firmware","title":"Criando o projeto"},{"location":"Tutorial-FPGA-NIOS/#analisando-e-configurando-o-bsp","text":"No Project Explorer do Eclipse, clique com o bot\u00e3o direito no: Project Explorer niosHello_bsp NIOS II bsp Editor Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas : sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA).","title":"Analisando e configurando o bsp"},{"location":"Tutorial-FPGA-NIOS/#jtag-uart-small-driver","text":"Note que no nosso projeto no QSYS o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver","title":"Jtag-UART small driver"},{"location":"Tutorial-FPGA-NIOS/#gerando-o-bsp","text":"Toda vez que o bsp for editado ou o hardware alterado (qsys) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosHello_bsp NIOS II Generate BSP","title":"Gerando o bsp"},{"location":"Tutorial-FPGA-NIOS/#embarcando","text":"Com o bsp editado abra agora a pasta niosHello e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console :","title":"Embarcando!"},{"location":"Tutorial-FPGA-NIOS/#blink-led","text":"Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS!","title":"Blink LED"},{"location":"Tutorial-FPGA-NIOS/#entrega-2","text":"Siga para a Entrega 2","title":"Entrega 2"},{"location":"Tutorial-FPGA-RTL/","text":"Tutorial 1 - FPGA - RTL \u00b6 Nessa primeira etapa do projeto iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. Iremos passar por todo o processo de desenvolvimento de um projeto em FPGA, desde sua cria\u00e7\u00e3o at\u00e9 a valida\u00e7\u00e3o no HW. Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-RTL Quartus \u00b6 Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como RTL_Blink_LED Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA : Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Outra refer\u00eancia Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf Criando o topLevel \u00b6 TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: RTL_Blink_LED.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity RTL_Blink_LED is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity RTL_Blink_LED ; architecture rtl of RTL_Blink_LED is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim por ora. Configurando o topLevel \u00b6 No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar. Verificando \u00b6 Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo. I/Os \u00b6 Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes. Pin Assigment \u00b6 Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel. LEDs \u00b6 No manual da placa (p\u00e1gina 22( temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: Essa tabela define o sinal (que voc\u00ea pode dar qualquer nome), o pino na FPGA na qual est\u00e1 conectado, uma breve descri\u00e7\u00e3o e o n\u00edvel el\u00e9trico de sinal na qual o pino deve ser configurado. Note que a placa DE10-Standard possui 10 LEDs conectados a FPGA. Clocks \u00b6 Tamb\u00e9m temos a defini\u00e7\u00e3o do clock (sec. 3.5, manual da placa): Note que existem 5 diferentes clocks que podem ser utilizado, os FPGA_CLKx_50 s\u00e3o clocks de 50Mhz conectados a FPGA e os HPS_CLKx_25 s\u00e3o sinais de clocks conectados exclusivamente ao ARM (HPS). Como estamos desenvolvendo na FPGA e n\u00e3o temos ainda nenhum requisito de performance, podemos escolher qualquer pino de clock FPGA_CLKx_50 . Vamos usar (escolhido aleat\u00f3rio) o pino CLOCK3_50 . Dom\u00ednios de Clock Tenha em mente que a FPGA trabalha com diferentes dom\u00ednios de clock, quando o projeto possui temporaliza\u00e7\u00e3o cr\u00edtica, essa escolha n\u00e3o pode ser casual. Inserindo no Quartus \u00b6 Agora que temos os pinos referentes aos sinais da FPGA, devemos inserir essa informa\u00e7\u00e3o no Quartus. Existem duas maneiras de fazermos isso: Pin Planner Ferramenta gr\u00e1fica e interativa Assigments Pin Planer Assigments Editor Maneira mais completa e com maior flexibilidade Assigments Assigments Editor Iremos utilizar a princ\u00edpio o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do topLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Edite a coluna Location utilizando como refer\u00eancia a tabela anterior. Note que o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 \u00e9 o 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o Timing Requirements not met \u00b6 Note que ap\u00f3s compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes. Synopsys Design Constraints File \u00b6 Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : RTL_Blink_LED.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto. RTL Viewer \u00b6 RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em : Tools -> NetList Viewers -> RTL Viewer . Gravando \u00b6 Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra : Tools -> Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux . Exerc\u00edcios \u00b6 : F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade Entrega 1 \u00b6 Siga para a Entrega 1","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#tutorial-1-fpga-rtl","text":"Nessa primeira etapa do projeto iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. Iremos passar por todo o processo de desenvolvimento de um projeto em FPGA, desde sua cria\u00e7\u00e3o at\u00e9 a valida\u00e7\u00e3o no HW.","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-RTL","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-RTL/#quartus","text":"Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como RTL_Blink_LED Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA : Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Outra refer\u00eancia Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf","title":"Quartus"},{"location":"Tutorial-FPGA-RTL/#criando-o-toplevel","text":"TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: RTL_Blink_LED.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity RTL_Blink_LED is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity RTL_Blink_LED ; architecture rtl of RTL_Blink_LED is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim por ora.","title":"Criando o topLevel"},{"location":"Tutorial-FPGA-RTL/#configurando-o-toplevel","text":"No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar.","title":"Configurando o topLevel"},{"location":"Tutorial-FPGA-RTL/#verificando","text":"Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo.","title":"Verificando"},{"location":"Tutorial-FPGA-RTL/#ios","text":"Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes.","title":"I/Os"},{"location":"Tutorial-FPGA-RTL/#pin-assigment","text":"Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel.","title":"Pin Assigment"},{"location":"Tutorial-FPGA-RTL/#leds","text":"No manual da placa (p\u00e1gina 22( temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: Essa tabela define o sinal (que voc\u00ea pode dar qualquer nome), o pino na FPGA na qual est\u00e1 conectado, uma breve descri\u00e7\u00e3o e o n\u00edvel el\u00e9trico de sinal na qual o pino deve ser configurado. Note que a placa DE10-Standard possui 10 LEDs conectados a FPGA.","title":"LEDs"},{"location":"Tutorial-FPGA-RTL/#clocks","text":"Tamb\u00e9m temos a defini\u00e7\u00e3o do clock (sec. 3.5, manual da placa): Note que existem 5 diferentes clocks que podem ser utilizado, os FPGA_CLKx_50 s\u00e3o clocks de 50Mhz conectados a FPGA e os HPS_CLKx_25 s\u00e3o sinais de clocks conectados exclusivamente ao ARM (HPS). Como estamos desenvolvendo na FPGA e n\u00e3o temos ainda nenhum requisito de performance, podemos escolher qualquer pino de clock FPGA_CLKx_50 . Vamos usar (escolhido aleat\u00f3rio) o pino CLOCK3_50 . Dom\u00ednios de Clock Tenha em mente que a FPGA trabalha com diferentes dom\u00ednios de clock, quando o projeto possui temporaliza\u00e7\u00e3o cr\u00edtica, essa escolha n\u00e3o pode ser casual.","title":"Clocks"},{"location":"Tutorial-FPGA-RTL/#inserindo-no-quartus","text":"Agora que temos os pinos referentes aos sinais da FPGA, devemos inserir essa informa\u00e7\u00e3o no Quartus. Existem duas maneiras de fazermos isso: Pin Planner Ferramenta gr\u00e1fica e interativa Assigments Pin Planer Assigments Editor Maneira mais completa e com maior flexibilidade Assigments Assigments Editor Iremos utilizar a princ\u00edpio o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do topLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Edite a coluna Location utilizando como refer\u00eancia a tabela anterior. Note que o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 \u00e9 o 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o","title":"Inserindo no Quartus"},{"location":"Tutorial-FPGA-RTL/#timing-requirements-not-met","text":"Note que ap\u00f3s compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes.","title":"Timing Requirements not met"},{"location":"Tutorial-FPGA-RTL/#synopsys-design-constraints-file","text":"Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : RTL_Blink_LED.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto.","title":"Synopsys Design Constraints File"},{"location":"Tutorial-FPGA-RTL/#rtl-viewer","text":"RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em : Tools -> NetList Viewers -> RTL Viewer .","title":"RTL Viewer"},{"location":"Tutorial-FPGA-RTL/#gravando","text":"Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra : Tools -> Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux .","title":"Gravando"},{"location":"Tutorial-FPGA-RTL/#exercicios","text":": F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade","title":"Exerc\u00edcios"},{"location":"Tutorial-FPGA-RTL/#entrega-1","text":"Siga para a Entrega 1","title":"Entrega 1"},{"location":"Tutorial-HPS-BlinkLED/","text":"Tutorial 6 - HPS - BlinkLED \u00b6 Nesse tutorial iremos compilar um programa para o HPS (Arm Cortex A) que ser\u00e1 capaz de controlar os LEDs e ler os bot\u00f5es da placa que est\u00e3o conectados ao HPS. Note pelo diagrama anterior extra\u00eddo do manual do usu\u00e1rio, existem LEDs e bot\u00f5es conectados diretamente ao HPS, e outros conectados a FPGA. Duas s\u00e3o as poss\u00edveis abordagens para programarmos o HPS: baremetal \u00b6 Far\u00edamos um programa que seria executado no ARM HPS sem nenhum sistema operacional. Como detalhado no diagrama : Altera Bare Metal User Guide Nessa maneira, a aplica\u00e7\u00e3o deve ser capaz de realizar toda a inicializa\u00e7\u00e3o de HW necess\u00e1ria para que o processador rode corretamente. Se a aplica\u00e7\u00e3o for executada sobre um sistema operacional, toda essa etapa \u00e9 de compila\u00e7\u00e3o \u00e9 responsabilidade do SO. Para isso \u00e9 aconselh\u00e1vel utilizar a IDE da ARM chamada de DS-5 Sistema operacional \u00b6 Diversas s\u00e3o as alternativas de sistema operacional para embarcado, tudo ir\u00e1 depender da especifica\u00e7\u00e3o da aplica\u00e7\u00e3o. \u00c9 necess\u00e1rio saber se existem requisitos de tempo real, se sim, deve-se considerar utilizar um RTOS ou algum sistema operacional com essa funcionalidade (existe um patch no kernel do linux que o torna mais ou menos real time). Se \u00e9 uma aplica\u00e7\u00e3o que demanda rede, v\u00eddeo, processamento de dados, \u00e9 de se considerar utilizar um Linux da vida (ou BSD, Androuid), j\u00e1 que a facilidade de desenvolvimento de aplica\u00e7\u00f5es nessa plataforma \u00e9 mais f\u00e1cil (j\u00e1 tem muita coisa pronta e uma comunidade gigantesca). Com o uso de um sistema operacional a parte referente ao HW \u00e9 responsabilidade do kernel (ou dos desenvolvedores que est\u00e3o adequando o kernel ao HW, que \u00e9 o caso de voc\u00eas). Diversos s\u00e3o os ganhos de utilizar um sistema operacional do tipo Linux (as perdas tamb\u00e9m s\u00e3o grandes: maior ocupa\u00e7\u00e3o de mem\u00f3ria, maior lat\u00eancias, boot lento ...) tais como: Device drivers Portabilidade Seguran\u00e7a Rede Linux \u00b6 Nesse tutorial iremos compilar um programa e executar no Linux Embarcado. esse programa ser\u00e1 executado no user space . Para isso iremos utilizar a toolchain definida no tutorial anterior . Iremos utilizar como base o c\u00f3digo exemplo da Terasic que est\u00e1 localizado no CD do kit: DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC/my_first_hps E crosscopilar esse c\u00f3digo para o nosso HPS utilizando o Makefile da pasta. Note Esse Makefile s\u00f3 funciona porque configuramos o nosso bashrc com as vari\u00e1veis de sistemas que ele utiliza. Por exemplo, a linha SOCEDS_ROOT ?= $(SOCEDS_DEST_ROOT) usa a vari\u00e1vel SOCEDS_DEST_ROOT que foi configurara no tutorial anterior, assim como o arm-linux-gnueabihf- ... Executando no target \u00b6 Agora basta copiar o bin\u00e1rio criado pela compila\u00e7\u00e3o para o cart\u00e3o de mem\u00f3ria e testar o nosso programa no target (HPS). Note Com o cart\u00e3o de mem\u00f3ria no host copie o arquivo bin\u00e1rio: hps_gpio para a pasta: /root/ do cart\u00e3o de mem\u00f3ria. Sempre que manipular um dispositivo de mem\u00f3ria externo, ser\u00e1 necess\u00e1rio fazer um flush do cache para for\u00e7ar o linux alterar o dispositivo externo, caso contr\u00e1rio a altera\u00e7\u00e3o poder\u00e1 ficar s\u00f3 local ao PC. $ sync A fun\u00e7\u00e3o sync \u00e9 blocante, ficar\u00e1 travada enquanto o linux faz o flush dos dados. Modificando o c\u00f3digo Fa\u00e7a o programa ler apenas duas vezes o bot\u00e3o, e depois disso termina a aplica\u00e7\u00e3o ! Fluxo de desenvolvimento \u00b6 Esse fluxo de desenvolvimento n\u00e3o \u00e9 dos melhores n\u00e9? \u00c9 bom programar no host , mas esse esquema de ter que ficar tirando e colocando cart\u00e3o de mem\u00f3ria, esperar o linux do target subir, logar e testar n\u00e3o faz bem para ningu\u00e9m. Existem v\u00e1rias solu\u00e7\u00f5es para melhorar isso, cada qual com sua vantagem/desvantagem: build no pr\u00f3prio target (ruim para o programador, \u00f3timo para depend\u00eancias, f\u00e1cil de debugar, lento) criar uma vmw arm e compilar nela (bom para o programador, \u00f3timo para depend\u00eancias, +- f\u00e1cil de debugar, r\u00e1pido) crosscompilar (bom para o programador, ruim para depend\u00eancias, dif\u00edcil de debugar, r\u00e1pido) Na entrega 4 vamos aprimorar nosso sistema de compila\u00e7\u00e3o e testes.","title":"Tutorial 6 - HPS - BlinkLED"},{"location":"Tutorial-HPS-BlinkLED/#tutorial-6-hps-blinkled","text":"Nesse tutorial iremos compilar um programa para o HPS (Arm Cortex A) que ser\u00e1 capaz de controlar os LEDs e ler os bot\u00f5es da placa que est\u00e3o conectados ao HPS. Note pelo diagrama anterior extra\u00eddo do manual do usu\u00e1rio, existem LEDs e bot\u00f5es conectados diretamente ao HPS, e outros conectados a FPGA. Duas s\u00e3o as poss\u00edveis abordagens para programarmos o HPS:","title":"Tutorial 6 - HPS - BlinkLED"},{"location":"Tutorial-HPS-BlinkLED/#baremetal","text":"Far\u00edamos um programa que seria executado no ARM HPS sem nenhum sistema operacional. Como detalhado no diagrama : Altera Bare Metal User Guide Nessa maneira, a aplica\u00e7\u00e3o deve ser capaz de realizar toda a inicializa\u00e7\u00e3o de HW necess\u00e1ria para que o processador rode corretamente. Se a aplica\u00e7\u00e3o for executada sobre um sistema operacional, toda essa etapa \u00e9 de compila\u00e7\u00e3o \u00e9 responsabilidade do SO. Para isso \u00e9 aconselh\u00e1vel utilizar a IDE da ARM chamada de DS-5","title":"baremetal"},{"location":"Tutorial-HPS-BlinkLED/#sistema-operacional","text":"Diversas s\u00e3o as alternativas de sistema operacional para embarcado, tudo ir\u00e1 depender da especifica\u00e7\u00e3o da aplica\u00e7\u00e3o. \u00c9 necess\u00e1rio saber se existem requisitos de tempo real, se sim, deve-se considerar utilizar um RTOS ou algum sistema operacional com essa funcionalidade (existe um patch no kernel do linux que o torna mais ou menos real time). Se \u00e9 uma aplica\u00e7\u00e3o que demanda rede, v\u00eddeo, processamento de dados, \u00e9 de se considerar utilizar um Linux da vida (ou BSD, Androuid), j\u00e1 que a facilidade de desenvolvimento de aplica\u00e7\u00f5es nessa plataforma \u00e9 mais f\u00e1cil (j\u00e1 tem muita coisa pronta e uma comunidade gigantesca). Com o uso de um sistema operacional a parte referente ao HW \u00e9 responsabilidade do kernel (ou dos desenvolvedores que est\u00e3o adequando o kernel ao HW, que \u00e9 o caso de voc\u00eas). Diversos s\u00e3o os ganhos de utilizar um sistema operacional do tipo Linux (as perdas tamb\u00e9m s\u00e3o grandes: maior ocupa\u00e7\u00e3o de mem\u00f3ria, maior lat\u00eancias, boot lento ...) tais como: Device drivers Portabilidade Seguran\u00e7a Rede","title":"Sistema operacional"},{"location":"Tutorial-HPS-BlinkLED/#linux","text":"Nesse tutorial iremos compilar um programa e executar no Linux Embarcado. esse programa ser\u00e1 executado no user space . Para isso iremos utilizar a toolchain definida no tutorial anterior . Iremos utilizar como base o c\u00f3digo exemplo da Terasic que est\u00e1 localizado no CD do kit: DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC/my_first_hps E crosscopilar esse c\u00f3digo para o nosso HPS utilizando o Makefile da pasta. Note Esse Makefile s\u00f3 funciona porque configuramos o nosso bashrc com as vari\u00e1veis de sistemas que ele utiliza. Por exemplo, a linha SOCEDS_ROOT ?= $(SOCEDS_DEST_ROOT) usa a vari\u00e1vel SOCEDS_DEST_ROOT que foi configurara no tutorial anterior, assim como o arm-linux-gnueabihf- ...","title":"Linux"},{"location":"Tutorial-HPS-BlinkLED/#executando-no-target","text":"Agora basta copiar o bin\u00e1rio criado pela compila\u00e7\u00e3o para o cart\u00e3o de mem\u00f3ria e testar o nosso programa no target (HPS). Note Com o cart\u00e3o de mem\u00f3ria no host copie o arquivo bin\u00e1rio: hps_gpio para a pasta: /root/ do cart\u00e3o de mem\u00f3ria. Sempre que manipular um dispositivo de mem\u00f3ria externo, ser\u00e1 necess\u00e1rio fazer um flush do cache para for\u00e7ar o linux alterar o dispositivo externo, caso contr\u00e1rio a altera\u00e7\u00e3o poder\u00e1 ficar s\u00f3 local ao PC. $ sync A fun\u00e7\u00e3o sync \u00e9 blocante, ficar\u00e1 travada enquanto o linux faz o flush dos dados. Modificando o c\u00f3digo Fa\u00e7a o programa ler apenas duas vezes o bot\u00e3o, e depois disso termina a aplica\u00e7\u00e3o !","title":"Executando no target"},{"location":"Tutorial-HPS-BlinkLED/#fluxo-de-desenvolvimento","text":"Esse fluxo de desenvolvimento n\u00e3o \u00e9 dos melhores n\u00e9? \u00c9 bom programar no host , mas esse esquema de ter que ficar tirando e colocando cart\u00e3o de mem\u00f3ria, esperar o linux do target subir, logar e testar n\u00e3o faz bem para ningu\u00e9m. Existem v\u00e1rias solu\u00e7\u00f5es para melhorar isso, cada qual com sua vantagem/desvantagem: build no pr\u00f3prio target (ruim para o programador, \u00f3timo para depend\u00eancias, f\u00e1cil de debugar, lento) criar uma vmw arm e compilar nela (bom para o programador, \u00f3timo para depend\u00eancias, +- f\u00e1cil de debugar, r\u00e1pido) crosscompilar (bom para o programador, ruim para depend\u00eancias, dif\u00edcil de debugar, r\u00e1pido) Na entrega 4 vamos aprimorar nosso sistema de compila\u00e7\u00e3o e testes.","title":"Fluxo de desenvolvimento"},{"location":"Tutorial-HPS-BuildSystem/","text":"Tutorial 5 - HPS - Infra \u00b6 Vamos instalar o ferramental (compiladores) que ser\u00e1 utilizado para compilar o kernel e o filesystem. Deveremos instalar o socdes e o linaro-gcc . Intel SOCDES \u00b6 Voc\u00ea ir\u00e1 precisar ter o software SOCEDS instalado, e ele precisa ser a mesma vers\u00e3o do Quartus. Link para download: Intel SoC FPGA Embedded Development Suite Vamos precisar inserir no path do bash refer\u00eancia para uma s\u00e9rie de softwares a serem usados, modifique seu .bashrc inserindo: Ao fazer o download do soced deve-se verificar para ser a mesma vers\u00e3o do Quartus. export ALTERAPATH = ~/intelFPGA/18.1/ export ALTERAPATH = /home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR = $ALTERAPATH /quartus/ export PATH = $PATH : ${ ALTERAPATH } /quartus/bin export PATH = $PATH : ${ ALTERAPATH } /modelsim_ase/linuxaloem/ export PATH = $PATH : ${ ALTERAPATH } /quartus/sopc_builder/bin/ export PATH = $PATH : ${ ALTERAPATH } /embedded/ export PATH = $PATH : ${ ALTERAPATH } /embedded/host_tools/altera/preloadergen/ export PATH = $PATH : ${ ALTERAPATH } /hls/bin/ export LD_LIBRARY_PATH = ${ ALTERAPATH } /hls/host/linux64/lib/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT = ${ ALTERAPATH } /embedded export SOCEDS_HWLIB = ${ ALTERAPATH } /embedded/ip/altera/hps/altera_hps/hwlib/ Note Lembre de verificar se o ALTERAPATH desse exemplo \u00e9 o caminho correto da instala\u00e7\u00e3o do Quartus outros bashs Se estiver usando outro bash (zsh/ fish) ser\u00e1 necess\u00e1rio editar o arquivo de configura\u00e7\u00e3o referente. Testando \u00b6 Para testar, digite no terminal (ap\u00f3s abrir uma nova aba, ou executar source ~/.bashrc ): $ nios2_command_shell.sh ------------------------------------------------ Altera Nios2 Command Shell [ GCC 4 ] Version 16 .1, Build 196 ------------------------------------------------ $ exit Note Isso s\u00f3 testa uma parte da instala\u00e7\u00e3o (soceds) GCC toolchain \u00b6 Iremos utilizar o GCC cross compile fornecido pelo Linaro, esse mesmo GCC ser\u00e1 utilizado para compilar o Kernel, gerar o file system e compilar os programas que executar\u00e3o no Linux. Para facilitar a organiza\u00e7\u00e3o, iremos manter o toolchain na pasta ~/work/ . Wikipidia Linaro Linaro is an engineering organization that works on free and open-source software such as the Linux kernel, the GNU Compiler Collection, power management, graphics and multimedia interfaces for the ARM family of instruction sets and implementations thereof as well as for the Heterogeneous System Architecture. https://en.wikipedia.org/wiki/Linaro Do site de bin\u00e1rios do Linaro abaixe a vers\u00e3o gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz e extra\u00eda para alguma pasta no seu Linux. Quer baixar via terminal? Meus projetos ficam todos dentro da pasta: /home/corsi/work , por isso eu extra\u00ed para l\u00e1. Voc\u00ea pode escolher outro local. $ cd ~/work $ wget https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz $ tar xvf gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz De uma olhada na pasta rec\u00e9m extra\u00edda: $ cd gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf $ tree -L 1 ... + arm-linux-gnueabihf + bin + arm-linux-gnueabihf-addr2line + arm-linux-gnueabihf-ar + ... + arm-linux-gnueabihf-c++ + arm-linux-gnueabihf-g++ + arm-linux-gnueabihf-gcc + include + lib + libexec + share Temos todas as ferramentas necess\u00e1rias para compilar e linkar c\u00f3digos em C e C++ para o ARM. Note que no path do gcc temos o prefixo : gnueabihf . Pesquisa Qual a diferen\u00e7a entre eabi e hf Criando um atalho no bash \u00b6 Vamos criar um atalho para essa pasta no bash. Edite o arquivo ~/.bashrc para incluir a pasta ~/work/gcc-linaro.../bin/ na vari\u00e1vel do sistema: GCC_Linaro . # GCC Linaro on path export GCC_Linaro = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH = $PATH : ${ GCC_Linaro } Note Edite o comando para a pasta correta de onde Linaro foi extra\u00eddo: /home/... Agora temos um atalho para o gcc-arm, vamos testar : $ $GCC_Linaro /arm-linux-gnueabihf-gcc -v ... Using built-in specs. COLLECT_GCC = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/../libexec/gcc/arm-linux-gnueabihf/7.4.1/lto-wrapper E ele tamb\u00e9m deve estar no path, como arm-linux-* : Note \u00c9 poss\u00edvel instalar o arm-linux via apt install , mas n\u00e3o vamos fazer isso pois queremos ter controle da vers\u00e3o do compilador que estamos utilizando. bashrc ao final Eu n\u00e3o modifico meu bashrc , o que eu fa\u00e7o \u00e9 criar um arquivo com o nome: Quartus18.sh e coloco toda essa configura\u00e7\u00e3o nele, e quando eu quero trabalhar em embarcados avan\u00e7ados eu s\u00f3 preciso dar source Quartus18.sh e tenho meu ambiente configurado. Com isso, eu tenho a vantagem de ter 'v\u00e1rias' vers\u00f5es instaladas e selecionar a que eu quero trabalhar. Isso tamb\u00e9m funciona pois eu tenho ambientes diferentes, com base nas disciplinas: Elementos tem um e Avan\u00e7ados outro. Meu Quartus18.sh \u00e9 o seguinte: echo \"INTEL FPGA QUARTUS 18.1\" export MGLS_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat export LM_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat #export MGLS_LICENSE_FILE=27001@35.172.191.36 #export LM_LICENSE_FILE=27001@35.172.191.3 export ALTERAPATH=/home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR=$ALTERAPATH/quartus/ export PATH=$PATH:${ALTERAPATH}/quartus/bin export PATH=$PATH:${ALTERAPATH}/modelsim_ase/linuxaloem/ export PATH=$PATH:${ALTERAPATH}/quartus/sopc_builder/bin/ export PATH=$PATH:${ALTERAPATH}/embedded/ export PATH=$PATH:${ALTERAPATH}/embedded/host_tools/altera/preloadergen/ export PATH=$PATH:${ALTERAPATH}/hls/bin/ export LD_LIBRARY_PATH=${ALTERAPATH}/hls/host/linux64/lib/ export PATH=$PATH:${ALTERAPATH}/nios2eds/ export PATH=$PATH:${ALTERAPATH}/nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT=${ALTERAPATH}/embedded export SOCEDS_HWLIB=${ALTERAPATH}/embedded/ip/altera/hps/altera_hps/hwlib/ export GCC_Linaro=/home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH=$PATH:${GCC_Linaro}","title":"Tutorial 5 - HPS - Infra"},{"location":"Tutorial-HPS-BuildSystem/#tutorial-5-hps-infra","text":"Vamos instalar o ferramental (compiladores) que ser\u00e1 utilizado para compilar o kernel e o filesystem. Deveremos instalar o socdes e o linaro-gcc .","title":"Tutorial 5 - HPS - Infra"},{"location":"Tutorial-HPS-BuildSystem/#intel-socdes","text":"Voc\u00ea ir\u00e1 precisar ter o software SOCEDS instalado, e ele precisa ser a mesma vers\u00e3o do Quartus. Link para download: Intel SoC FPGA Embedded Development Suite Vamos precisar inserir no path do bash refer\u00eancia para uma s\u00e9rie de softwares a serem usados, modifique seu .bashrc inserindo: Ao fazer o download do soced deve-se verificar para ser a mesma vers\u00e3o do Quartus. export ALTERAPATH = ~/intelFPGA/18.1/ export ALTERAPATH = /home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR = $ALTERAPATH /quartus/ export PATH = $PATH : ${ ALTERAPATH } /quartus/bin export PATH = $PATH : ${ ALTERAPATH } /modelsim_ase/linuxaloem/ export PATH = $PATH : ${ ALTERAPATH } /quartus/sopc_builder/bin/ export PATH = $PATH : ${ ALTERAPATH } /embedded/ export PATH = $PATH : ${ ALTERAPATH } /embedded/host_tools/altera/preloadergen/ export PATH = $PATH : ${ ALTERAPATH } /hls/bin/ export LD_LIBRARY_PATH = ${ ALTERAPATH } /hls/host/linux64/lib/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT = ${ ALTERAPATH } /embedded export SOCEDS_HWLIB = ${ ALTERAPATH } /embedded/ip/altera/hps/altera_hps/hwlib/ Note Lembre de verificar se o ALTERAPATH desse exemplo \u00e9 o caminho correto da instala\u00e7\u00e3o do Quartus outros bashs Se estiver usando outro bash (zsh/ fish) ser\u00e1 necess\u00e1rio editar o arquivo de configura\u00e7\u00e3o referente.","title":"Intel SOCDES"},{"location":"Tutorial-HPS-BuildSystem/#testando","text":"Para testar, digite no terminal (ap\u00f3s abrir uma nova aba, ou executar source ~/.bashrc ): $ nios2_command_shell.sh ------------------------------------------------ Altera Nios2 Command Shell [ GCC 4 ] Version 16 .1, Build 196 ------------------------------------------------ $ exit Note Isso s\u00f3 testa uma parte da instala\u00e7\u00e3o (soceds)","title":"Testando"},{"location":"Tutorial-HPS-BuildSystem/#gcc-toolchain","text":"Iremos utilizar o GCC cross compile fornecido pelo Linaro, esse mesmo GCC ser\u00e1 utilizado para compilar o Kernel, gerar o file system e compilar os programas que executar\u00e3o no Linux. Para facilitar a organiza\u00e7\u00e3o, iremos manter o toolchain na pasta ~/work/ . Wikipidia Linaro Linaro is an engineering organization that works on free and open-source software such as the Linux kernel, the GNU Compiler Collection, power management, graphics and multimedia interfaces for the ARM family of instruction sets and implementations thereof as well as for the Heterogeneous System Architecture. https://en.wikipedia.org/wiki/Linaro Do site de bin\u00e1rios do Linaro abaixe a vers\u00e3o gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz e extra\u00eda para alguma pasta no seu Linux. Quer baixar via terminal? Meus projetos ficam todos dentro da pasta: /home/corsi/work , por isso eu extra\u00ed para l\u00e1. Voc\u00ea pode escolher outro local. $ cd ~/work $ wget https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz $ tar xvf gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz De uma olhada na pasta rec\u00e9m extra\u00edda: $ cd gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf $ tree -L 1 ... + arm-linux-gnueabihf + bin + arm-linux-gnueabihf-addr2line + arm-linux-gnueabihf-ar + ... + arm-linux-gnueabihf-c++ + arm-linux-gnueabihf-g++ + arm-linux-gnueabihf-gcc + include + lib + libexec + share Temos todas as ferramentas necess\u00e1rias para compilar e linkar c\u00f3digos em C e C++ para o ARM. Note que no path do gcc temos o prefixo : gnueabihf . Pesquisa Qual a diferen\u00e7a entre eabi e hf","title":"GCC toolchain"},{"location":"Tutorial-HPS-BuildSystem/#criando-um-atalho-no-bash","text":"Vamos criar um atalho para essa pasta no bash. Edite o arquivo ~/.bashrc para incluir a pasta ~/work/gcc-linaro.../bin/ na vari\u00e1vel do sistema: GCC_Linaro . # GCC Linaro on path export GCC_Linaro = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH = $PATH : ${ GCC_Linaro } Note Edite o comando para a pasta correta de onde Linaro foi extra\u00eddo: /home/... Agora temos um atalho para o gcc-arm, vamos testar : $ $GCC_Linaro /arm-linux-gnueabihf-gcc -v ... Using built-in specs. COLLECT_GCC = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/../libexec/gcc/arm-linux-gnueabihf/7.4.1/lto-wrapper E ele tamb\u00e9m deve estar no path, como arm-linux-* : Note \u00c9 poss\u00edvel instalar o arm-linux via apt install , mas n\u00e3o vamos fazer isso pois queremos ter controle da vers\u00e3o do compilador que estamos utilizando. bashrc ao final Eu n\u00e3o modifico meu bashrc , o que eu fa\u00e7o \u00e9 criar um arquivo com o nome: Quartus18.sh e coloco toda essa configura\u00e7\u00e3o nele, e quando eu quero trabalhar em embarcados avan\u00e7ados eu s\u00f3 preciso dar source Quartus18.sh e tenho meu ambiente configurado. Com isso, eu tenho a vantagem de ter 'v\u00e1rias' vers\u00f5es instaladas e selecionar a que eu quero trabalhar. Isso tamb\u00e9m funciona pois eu tenho ambientes diferentes, com base nas disciplinas: Elementos tem um e Avan\u00e7ados outro. Meu Quartus18.sh \u00e9 o seguinte: echo \"INTEL FPGA QUARTUS 18.1\" export MGLS_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat export LM_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat #export MGLS_LICENSE_FILE=27001@35.172.191.36 #export LM_LICENSE_FILE=27001@35.172.191.3 export ALTERAPATH=/home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR=$ALTERAPATH/quartus/ export PATH=$PATH:${ALTERAPATH}/quartus/bin export PATH=$PATH:${ALTERAPATH}/modelsim_ase/linuxaloem/ export PATH=$PATH:${ALTERAPATH}/quartus/sopc_builder/bin/ export PATH=$PATH:${ALTERAPATH}/embedded/ export PATH=$PATH:${ALTERAPATH}/embedded/host_tools/altera/preloadergen/ export PATH=$PATH:${ALTERAPATH}/hls/bin/ export LD_LIBRARY_PATH=${ALTERAPATH}/hls/host/linux64/lib/ export PATH=$PATH:${ALTERAPATH}/nios2eds/ export PATH=$PATH:${ALTERAPATH}/nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT=${ALTERAPATH}/embedded export SOCEDS_HWLIB=${ALTERAPATH}/embedded/ip/altera/hps/altera_hps/hwlib/ export GCC_Linaro=/home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH=$PATH:${GCC_Linaro}","title":"Criando um atalho no bash"},{"location":"Tutorial-HPS-Buildroot/","text":"Tutorial 8 - HPS -Buildroot \u00b6 Buildroot wikipidia Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system ref: https://en.wikipedia.org/wiki/Buildroot Iremos utilizar o buildroot para gerar o filesystem ( /bin , /etc , ...) do nosso sistema embarcado. No buildroot teremos a op\u00e7\u00e3o de configurar quais softwares queremos no dispositivo. Por exemplo, se desejarmos acessar o HPS via ssh, teremos que no buildroot adicionar um ssh server para ser compilado e adicionado ao filesystem e executado no boot. O buildroot \u00e9 uma alternativa a outro projeto bem conhecido: Yocto. O v\u00eddeo a seguir s\u00e3o dois desenvolvedores, um de cada projeto, fazendo a compara\u00e7\u00e3o entre as duas ferramentas: Note O Yocto est\u00e1 se consolidando como ferramenta padr\u00e3o da industria, tomando o lugar do buildroot. A escolha pelo buildroot na eletiva \u00e9 pela facilidade de criar um sistema, o yocto \u00e9 mais complexo e cheio de terminologias. Nessa eletiva iremos trabalhar com o buildroot, mas para quem quer se aprofundar/especializar no tema, tem que aprender o yocto. buildroot \u00b6 Leitura recomendada https://buildroot.org/downloads/manual/manual.html#_getting_started Download \u00b6 Primeiramente devemos fazer o download do buildroot : $ git clone https://github.com/buildroot/buildroot $ cd buildroot/ O buildroot possui uma ferramenta de configura\u00e7\u00e3o similar ao do kernel do linux ( menuconfig / nconfig ) iremos utilizar-la para configurar o filesystem assim como quais programas ser\u00e3o compilados e inseridos no /root/ . Lembre que j\u00e1 possu\u00edmos um toolchain (o que compilamos o kernel) configurado no .bashrc , iremos o utilizar para a compila\u00e7\u00e3o de todos os programas que iremos carregar no embarcado. O buildroot tem a op\u00e7\u00e3o de fazer o download do toolchain (ele tamb\u00e9m pode compilar o kernel e gerar o uboot, \u00e9 uma ferramenta bem completa), mas dessa vez iremos utilizar o que j\u00e1 temos (para manter a compatibilidade). Configurando \u00b6 Na pasta do buildroot rec\u00e9m clonada, execute o seguinte comando: $ make ARCH = arm menuconfig Ele ir\u00e1 abrir uma tela de configura\u00e7\u00e3o a seguir: para voltar para essa tela, basta aperta duas vezes a tecla <ESC> 1. Target Options \u00b6 A primeira parte que iremos configurar \u00e9 o alvo da gera\u00e7\u00e3o do filesystem ( Target options ), devemos informar para o buildroot que ele est\u00e1 gerando arquivos para um ARM e indicar algumas op\u00e7\u00f5es do nosso compilador. Para isso: Config. final Menu principal Target Options Target Architecture: ARM (little endian) Essa op\u00e7\u00e3o j\u00e1 deve estar certa pois passamos via a chamada do make (make ARCH=ARM ...) Target Architecture Variant: cortex-A9 Enable NEON SIMD extension support Enable VFP extension support Floating point strategy: NEON https://developer.arm.com/technologies/neon Target ABI: EABIhf Indicamos ao buildroot que nossa arquitetura possui ponto flutuante em HW. 2. Build options \u00b6 Config. Final Deixe padr\u00e3o como o padr\u00e3o. 3. Toolchain \u00b6 config. Final Vamos indicar agora para o buildroot qual toolchain que ele deve utilizar e suas configura\u00e7\u00f5es: Menu principal Toolchain Toolchain type: External toolchain o buildroot ir\u00e1 usar o toolchain que especificarmos. Note que dentro dessa op\u00e7\u00e3o existe a : Buildroot toolchain , que se ativada faria com que o buildroot baixasse de forma autom\u00e1tica todo o toolchain. Toolchain: Custom toolchain Toolchain path: $(ARM_GCC) o buildroot ir\u00e1 usar essa vari\u00e1vel do sistema como path do toolchain. Temos duas op\u00e7\u00f5es aqui : Podemos declarar essa vari\u00e1vel no bash Podemos editar essa op\u00e7\u00e3o j\u00e1 com o path do nosso toolchain Vamos escolher por hora a op\u00e7\u00e3o 1. Toolchain prefix: $(ARCH)-linux-gnueabihf o prefix \u00e9 como o toolchain ir\u00e1 ser chamado, por exemplo para acessar o gcc: $(ARM_GCC)/bin/$(ARCH)-linux-gnueabihf-gcc Sendo : ARM_GCC = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf ARCH = arm (passado no call do make) Resulta em: /home/corsi/work/gcc-linaro-7.1-2017.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc Toolchain gcc version: 7.x Toolchain kernel headers series: 4.10.x External toolchain C library: glibc/eglibc Ativar : Toolchain has SSP support Ativar : Toolchain has SSP support Ativar : Toolchain has RCP support Ativar : Toolchain has C++ support 4. System Configuration \u00b6 config. Final Nessa etapa vamos configurar informa\u00e7\u00f5es como: hostname, user, password gerenciador de inicializa\u00e7\u00e3o (init)... Menu principal System Configuration System hostname: SoC-Corsi (escolha o que preferir) System banner: Embarcados Avancados!! SoC Cyclone V Init system: BusyBox systemd \u00e9 uma alternativa, s\u00f3 que mais complexa! Root password: 1234 (escolha o que preferir) /bin/sh: busybox O shell a ser inserido no sistema, temos v\u00e1rias outras op\u00e7\u00f5es: bash, zsh. Todas elas ir\u00e3o aumentar o tamanho e a complexidade da imagem. 5. Kernel / bootloader \u00b6 O busybox pode baixar e compilar o kernel e o uboot para n\u00f3s. Nonte N\u00e3o vamos usar essa configura\u00e7\u00e3o. Deixe n\u00e3o checado! Menu principal Kernel 6. Target packages \u00b6 Nesse menu temos a op\u00e7\u00e3o de quais programas e sistemas ser\u00e3o inseridos na imagem para o target. Se quisermos por exemplo inserir um webserver (apache ?) no nosso linux embarcado, devemos selecionar aqui. Vamos deixar como padr\u00e3o por hora. Mais tarde iremos voltar a essa etapa mais tarde. 7. Filesystem images \u00b6 Menu principal Filesystem images Selecionar: tar the root filesystem Esse menu descreve para o busybox como deve ser a sa\u00edda final da imagem do filesystem gerada. O busybox necessita gerar filesystem que \u00e9 capaz de configurar as permiss\u00f5es dos arquivos corretamente (ele n\u00e3o pode simplesmente gerar uma pasta com todos os arquivos e programas). 8. Finalizando \u00b6 Salve a sua configura\u00e7\u00e3o (ESC ESC save) e volte ao terminal. Vamos agora gerar a imagem do nosso filesystem. Compilando \u00b6 Para compilar e gerar o filesystem : $ make ARCH = arm all -j 4 Nessa etapa o buildroot ir\u00e1 baixar da web todos os pacotes e programas que foram selecionados no menu de configura\u00e7\u00e3o, e ir\u00e1 compilar o source code com o toolchain que passamos para ele. Isso pode levar um tempinho . Gr\u00e1ficos ! \u00b6 Uma vez acabado o processo de gera\u00e7\u00e3o do FS, podemos gerar alguns gr\u00e1ficos muito importantes: https://buildroot.org/downloads/manual/manual.html#_graphing_the_filesystem_size_contribution_of_packages Depend\u00eancia dos pacotes: make graph-depends Tempo de compila\u00e7\u00e3o: make graph-build Contribui\u00e7\u00e3o do tamanho do FS de cada pacote: make graph-size Os gr\u00e1ficos s\u00e3o salvos na pasta: output/graphs/ Gere os tr\u00eas gr\u00e1ficos e analise os resultados Exemplo do gr\u00e1fico do tamanho dos pacotes no fs: Outputs \u00b6 Existem duas sa\u00eddas do buildroot na pasta: buildroot/output/** O arquivo ./images/rootfs.tar : que cont\u00e9m o fileSystem do target (com as permiss\u00f5es corretas) A pasta ./images/target/ : com os arquivos contidos no .tar mas sem as permiss\u00f5es corretas para executar no target. Inclusive essa pasta possui um arquivo: Warning THIS_IS_NOT_YOUR_ROOT_FILESYSTEM Warning! This directory does not contain the root filesystem that you can use on your embedded system. Since Buildroot does not run as root, it cannot create device files and set the permissions and ownership of files correctly in this directory to make it usable as a root filesystem. .... Para testarmos no nosso sistema embarcados, temos que extrair o arquivo rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. Testando \u00b6 Siga o tutorial em SDCard - FileSystem . L\u00e1 est\u00e1 comentando como extrair o rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. o boot ficou mais r\u00e1pido? Tente plugar um pendrive, funciona? Estudando \u00b6 Responda: descreva o que \u00e9 o root file system initd process para que serve e como funciona o /linuxrc para que serve o /proc Refer\u00eancias \u00b6 dtb : https://rocketboards.org/foswiki/Documentation/HOWTOCreateADeviceTree Generating and Compiling the Preloader : https://rocketboards.org/foswiki/Documentation/GSRD141Preloader Compilando o kernel : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8","title":"Tutorial 8 - HPS -Buildroot"},{"location":"Tutorial-HPS-Buildroot/#tutorial-8-hps-buildroot","text":"Buildroot wikipidia Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system ref: https://en.wikipedia.org/wiki/Buildroot Iremos utilizar o buildroot para gerar o filesystem ( /bin , /etc , ...) do nosso sistema embarcado. No buildroot teremos a op\u00e7\u00e3o de configurar quais softwares queremos no dispositivo. Por exemplo, se desejarmos acessar o HPS via ssh, teremos que no buildroot adicionar um ssh server para ser compilado e adicionado ao filesystem e executado no boot. O buildroot \u00e9 uma alternativa a outro projeto bem conhecido: Yocto. O v\u00eddeo a seguir s\u00e3o dois desenvolvedores, um de cada projeto, fazendo a compara\u00e7\u00e3o entre as duas ferramentas: Note O Yocto est\u00e1 se consolidando como ferramenta padr\u00e3o da industria, tomando o lugar do buildroot. A escolha pelo buildroot na eletiva \u00e9 pela facilidade de criar um sistema, o yocto \u00e9 mais complexo e cheio de terminologias. Nessa eletiva iremos trabalhar com o buildroot, mas para quem quer se aprofundar/especializar no tema, tem que aprender o yocto.","title":"Tutorial 8 - HPS -Buildroot"},{"location":"Tutorial-HPS-Buildroot/#buildroot","text":"Leitura recomendada https://buildroot.org/downloads/manual/manual.html#_getting_started","title":"buildroot"},{"location":"Tutorial-HPS-Buildroot/#download","text":"Primeiramente devemos fazer o download do buildroot : $ git clone https://github.com/buildroot/buildroot $ cd buildroot/ O buildroot possui uma ferramenta de configura\u00e7\u00e3o similar ao do kernel do linux ( menuconfig / nconfig ) iremos utilizar-la para configurar o filesystem assim como quais programas ser\u00e3o compilados e inseridos no /root/ . Lembre que j\u00e1 possu\u00edmos um toolchain (o que compilamos o kernel) configurado no .bashrc , iremos o utilizar para a compila\u00e7\u00e3o de todos os programas que iremos carregar no embarcado. O buildroot tem a op\u00e7\u00e3o de fazer o download do toolchain (ele tamb\u00e9m pode compilar o kernel e gerar o uboot, \u00e9 uma ferramenta bem completa), mas dessa vez iremos utilizar o que j\u00e1 temos (para manter a compatibilidade).","title":"Download"},{"location":"Tutorial-HPS-Buildroot/#configurando","text":"Na pasta do buildroot rec\u00e9m clonada, execute o seguinte comando: $ make ARCH = arm menuconfig Ele ir\u00e1 abrir uma tela de configura\u00e7\u00e3o a seguir: para voltar para essa tela, basta aperta duas vezes a tecla <ESC>","title":"Configurando"},{"location":"Tutorial-HPS-Buildroot/#1-target-options","text":"A primeira parte que iremos configurar \u00e9 o alvo da gera\u00e7\u00e3o do filesystem ( Target options ), devemos informar para o buildroot que ele est\u00e1 gerando arquivos para um ARM e indicar algumas op\u00e7\u00f5es do nosso compilador. Para isso: Config. final Menu principal Target Options Target Architecture: ARM (little endian) Essa op\u00e7\u00e3o j\u00e1 deve estar certa pois passamos via a chamada do make (make ARCH=ARM ...) Target Architecture Variant: cortex-A9 Enable NEON SIMD extension support Enable VFP extension support Floating point strategy: NEON https://developer.arm.com/technologies/neon Target ABI: EABIhf Indicamos ao buildroot que nossa arquitetura possui ponto flutuante em HW.","title":"1. Target Options"},{"location":"Tutorial-HPS-Buildroot/#2-build-options","text":"Config. Final Deixe padr\u00e3o como o padr\u00e3o.","title":"2. Build options"},{"location":"Tutorial-HPS-Buildroot/#3-toolchain","text":"config. Final Vamos indicar agora para o buildroot qual toolchain que ele deve utilizar e suas configura\u00e7\u00f5es: Menu principal Toolchain Toolchain type: External toolchain o buildroot ir\u00e1 usar o toolchain que especificarmos. Note que dentro dessa op\u00e7\u00e3o existe a : Buildroot toolchain , que se ativada faria com que o buildroot baixasse de forma autom\u00e1tica todo o toolchain. Toolchain: Custom toolchain Toolchain path: $(ARM_GCC) o buildroot ir\u00e1 usar essa vari\u00e1vel do sistema como path do toolchain. Temos duas op\u00e7\u00f5es aqui : Podemos declarar essa vari\u00e1vel no bash Podemos editar essa op\u00e7\u00e3o j\u00e1 com o path do nosso toolchain Vamos escolher por hora a op\u00e7\u00e3o 1. Toolchain prefix: $(ARCH)-linux-gnueabihf o prefix \u00e9 como o toolchain ir\u00e1 ser chamado, por exemplo para acessar o gcc: $(ARM_GCC)/bin/$(ARCH)-linux-gnueabihf-gcc Sendo : ARM_GCC = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf ARCH = arm (passado no call do make) Resulta em: /home/corsi/work/gcc-linaro-7.1-2017.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc Toolchain gcc version: 7.x Toolchain kernel headers series: 4.10.x External toolchain C library: glibc/eglibc Ativar : Toolchain has SSP support Ativar : Toolchain has SSP support Ativar : Toolchain has RCP support Ativar : Toolchain has C++ support","title":"3. Toolchain"},{"location":"Tutorial-HPS-Buildroot/#4-system-configuration","text":"config. Final Nessa etapa vamos configurar informa\u00e7\u00f5es como: hostname, user, password gerenciador de inicializa\u00e7\u00e3o (init)... Menu principal System Configuration System hostname: SoC-Corsi (escolha o que preferir) System banner: Embarcados Avancados!! SoC Cyclone V Init system: BusyBox systemd \u00e9 uma alternativa, s\u00f3 que mais complexa! Root password: 1234 (escolha o que preferir) /bin/sh: busybox O shell a ser inserido no sistema, temos v\u00e1rias outras op\u00e7\u00f5es: bash, zsh. Todas elas ir\u00e3o aumentar o tamanho e a complexidade da imagem.","title":"4. System Configuration"},{"location":"Tutorial-HPS-Buildroot/#5-kernel-bootloader","text":"O busybox pode baixar e compilar o kernel e o uboot para n\u00f3s. Nonte N\u00e3o vamos usar essa configura\u00e7\u00e3o. Deixe n\u00e3o checado! Menu principal Kernel","title":"5. Kernel / bootloader"},{"location":"Tutorial-HPS-Buildroot/#6-target-packages","text":"Nesse menu temos a op\u00e7\u00e3o de quais programas e sistemas ser\u00e3o inseridos na imagem para o target. Se quisermos por exemplo inserir um webserver (apache ?) no nosso linux embarcado, devemos selecionar aqui. Vamos deixar como padr\u00e3o por hora. Mais tarde iremos voltar a essa etapa mais tarde.","title":"6. Target packages"},{"location":"Tutorial-HPS-Buildroot/#7-filesystem-images","text":"Menu principal Filesystem images Selecionar: tar the root filesystem Esse menu descreve para o busybox como deve ser a sa\u00edda final da imagem do filesystem gerada. O busybox necessita gerar filesystem que \u00e9 capaz de configurar as permiss\u00f5es dos arquivos corretamente (ele n\u00e3o pode simplesmente gerar uma pasta com todos os arquivos e programas).","title":"7. Filesystem images"},{"location":"Tutorial-HPS-Buildroot/#8-finalizando","text":"Salve a sua configura\u00e7\u00e3o (ESC ESC save) e volte ao terminal. Vamos agora gerar a imagem do nosso filesystem.","title":"8. Finalizando"},{"location":"Tutorial-HPS-Buildroot/#compilando","text":"Para compilar e gerar o filesystem : $ make ARCH = arm all -j 4 Nessa etapa o buildroot ir\u00e1 baixar da web todos os pacotes e programas que foram selecionados no menu de configura\u00e7\u00e3o, e ir\u00e1 compilar o source code com o toolchain que passamos para ele. Isso pode levar um tempinho .","title":"Compilando"},{"location":"Tutorial-HPS-Buildroot/#graficos","text":"Uma vez acabado o processo de gera\u00e7\u00e3o do FS, podemos gerar alguns gr\u00e1ficos muito importantes: https://buildroot.org/downloads/manual/manual.html#_graphing_the_filesystem_size_contribution_of_packages Depend\u00eancia dos pacotes: make graph-depends Tempo de compila\u00e7\u00e3o: make graph-build Contribui\u00e7\u00e3o do tamanho do FS de cada pacote: make graph-size Os gr\u00e1ficos s\u00e3o salvos na pasta: output/graphs/ Gere os tr\u00eas gr\u00e1ficos e analise os resultados Exemplo do gr\u00e1fico do tamanho dos pacotes no fs:","title":"Gr\u00e1ficos !"},{"location":"Tutorial-HPS-Buildroot/#outputs","text":"Existem duas sa\u00eddas do buildroot na pasta: buildroot/output/** O arquivo ./images/rootfs.tar : que cont\u00e9m o fileSystem do target (com as permiss\u00f5es corretas) A pasta ./images/target/ : com os arquivos contidos no .tar mas sem as permiss\u00f5es corretas para executar no target. Inclusive essa pasta possui um arquivo: Warning THIS_IS_NOT_YOUR_ROOT_FILESYSTEM Warning! This directory does not contain the root filesystem that you can use on your embedded system. Since Buildroot does not run as root, it cannot create device files and set the permissions and ownership of files correctly in this directory to make it usable as a root filesystem. .... Para testarmos no nosso sistema embarcados, temos que extrair o arquivo rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria.","title":"Outputs"},{"location":"Tutorial-HPS-Buildroot/#testando","text":"Siga o tutorial em SDCard - FileSystem . L\u00e1 est\u00e1 comentando como extrair o rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. o boot ficou mais r\u00e1pido? Tente plugar um pendrive, funciona?","title":"Testando"},{"location":"Tutorial-HPS-Buildroot/#estudando","text":"Responda: descreva o que \u00e9 o root file system initd process para que serve e como funciona o /linuxrc para que serve o /proc","title":"Estudando"},{"location":"Tutorial-HPS-Buildroot/#referencias","text":"dtb : https://rocketboards.org/foswiki/Documentation/HOWTOCreateADeviceTree Generating and Compiling the Preloader : https://rocketboards.org/foswiki/Documentation/GSRD141Preloader Compilando o kernel : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8","title":"Refer\u00eancias"},{"location":"Tutorial-HPS-FPGA-BlinkLED/","text":"Tutorial - HPS + FPGA - Blink LED \u00b6 Nesse tutorial vamos ver como interfacear o ARM com a FPGA (fabric). Nesse tutorial, optei por deixar voc\u00eas seguirem o tutorial oficial da Terasic: Examples for using both HPS SoC and FGPA [cap\u00edtulo 7], que se encontra no manual do usu\u00e1rio, no CD do kit. Note Retomar a essa p\u00e1gina quando acabar o tutorial da Terasic, ele n\u00e3o cobre tudo. https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/tree/master/Manual Execute Copie o bin\u00e1rio compilado no tutorial HPS_FPGA_LED para o SDCard Entendendo o HW \u00b6 Muito importante voc\u00ea parar e refletir o que aconteceu, para isso segue algumas perguntas: Quais s\u00e3o as interfaces ente o ARM e a FPGA? (s\u00e3o 4 no total) Qual a diferen\u00e7a entre elas? Como o HPS aparece no Platform Designer (PD)? Voc\u00ea abriu as configura\u00e7\u00f5es do HPS no PD? O que pode ser configurado? Como essa interface \u00e9 utilizada no Platform Designer? Porque no projeto ele utilizou um clock bridge? Parte 2 \u00b6 Esse tutorial n\u00e3o \u00e9 completo, ele pula uma coisa muito importante: Como programar a FPGA automaticamente para quando o Linux inicializar, o hardware j\u00e1 estar programando para poder executar o programa HPS_FPGA_LED . Como o Kernel do linux sabe em qual hardware ele est\u00e1 sendo executado? (Possui v\u00eddeo? Ethernet? ...) A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons Gerando o .rbf (imagem da FPGA) \u00b6 O rbf \u00e9 o arquivo .sof gerado pelo Quartus na compila\u00e7\u00e3o s\u00f3 que comprimido e com algumas modifica\u00e7\u00f5es. Para gerar o arquivo .rbf a partir do .sof basta executarmos na pasta output_files : Note Voc\u00ea deve executar esse comando na pasta output_files do seu projeto Quartus! $ cd output_files $ quartus_cpf -c DE10_Standard_FB.sof -o bitstream_compression = on soc_system.rbf Note note que o arquivo gerado pelo Quartus chama DE10_Standard_FB.sof , voc\u00ea deve editar para o seu caso. Com o arquivo soc_system.rbf criado, \u00e9 s\u00f3 copiarmos ele para o SDCARD, substituindo o anterior. Execute Gere o soc_system.rbf do projeto (COMPILAR O QUARTUS!) Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel) dtb (informa\u00e7\u00f5es de hardware para o Kernel) \u00b6 O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico mudar, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! Ser\u00e1 necess\u00e1rio seguir os passos a seguir: Gere o .sopcinfo (platform designer) ( j\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer ) Gere o dts Compile o dts para dtb Gerando o dts \u00b6 Eu consegui esse comando via trocado com engenheiros da Terasic, os exemplos que encontrava nos tutorias da internet n\u00e3o funcionavam. Note Para funcionar \u00e9 necess\u00e1rio realizar o comando via o shell do embedded Execute os seguintes comandos: $ # Devemos executar os comandos dentro do shell do embedded (quartus) $ embedded_command_shell.sh $ sopc2dts --input soc_system.sopcinfo --output soc_system.dts --type dts --board soc_system_board_info.xml --board hps_common_board_info.xml --bridge-removal all --clocks Note Voc\u00ea deve executar esse comando na pasta raiz do seu projeto Quartus! Agora com o .dts gerado, vamos dar uma olhada em seu conte\u00fado e como o interpretar. O dts possui a anatomia a seguir: ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = <1>; #size-cells = <0>; enable-method = \"altr,socfpga-smp\"; /* appended from boardinfo */ hps_0_arm_a9_0: cpu@0x0 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000000>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1: cpu@0x1 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000001>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\", \"snps,dw-apb-uart\"; reg = <0xffc02000 0x00000100>; interrupt-parent = <&hps_0_arm_gic_0>; interrupts = <0 162 4>; clocks = <&l4_sp_clk>; reg-io-width = <4>; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg-shift = <2>; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\"; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 Para mais informa\u00e7\u00f5es sobre o dts : https://elinux.org/Device_Tree_Usage https://elinux.org/Device_Tree_Reference https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf Gerando o dtb \u00b6 Execute os seguintes comandos (ainda dentro do embedded shell) $ dtc -I dts -O dtb -o soc_system.dtb soc_system.dts $ #Agora voc\u00ea pode sair do embedded shell: $ exit Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel) Testando \u00b6 Agora plugue o SDcard no kit de desenvolvimento, e ap\u00f3s inicializa\u00e7\u00e3o do kernel execute o programa blink led e veja os LEDs da FPGA piscarem! Interessante n\u00e9? Agora vamos fazer algo mais \u00fatil com isso..","title":"Tutorial - HPS + FPGA - Blink LED"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#tutorial-hps-fpga-blink-led","text":"Nesse tutorial vamos ver como interfacear o ARM com a FPGA (fabric). Nesse tutorial, optei por deixar voc\u00eas seguirem o tutorial oficial da Terasic: Examples for using both HPS SoC and FGPA [cap\u00edtulo 7], que se encontra no manual do usu\u00e1rio, no CD do kit. Note Retomar a essa p\u00e1gina quando acabar o tutorial da Terasic, ele n\u00e3o cobre tudo. https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/tree/master/Manual Execute Copie o bin\u00e1rio compilado no tutorial HPS_FPGA_LED para o SDCard","title":"Tutorial - HPS + FPGA - Blink LED"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#entendendo-o-hw","text":"Muito importante voc\u00ea parar e refletir o que aconteceu, para isso segue algumas perguntas: Quais s\u00e3o as interfaces ente o ARM e a FPGA? (s\u00e3o 4 no total) Qual a diferen\u00e7a entre elas? Como o HPS aparece no Platform Designer (PD)? Voc\u00ea abriu as configura\u00e7\u00f5es do HPS no PD? O que pode ser configurado? Como essa interface \u00e9 utilizada no Platform Designer? Porque no projeto ele utilizou um clock bridge?","title":"Entendendo o HW"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#parte-2","text":"Esse tutorial n\u00e3o \u00e9 completo, ele pula uma coisa muito importante: Como programar a FPGA automaticamente para quando o Linux inicializar, o hardware j\u00e1 estar programando para poder executar o programa HPS_FPGA_LED . Como o Kernel do linux sabe em qual hardware ele est\u00e1 sendo executado? (Possui v\u00eddeo? Ethernet? ...) A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons","title":"Parte 2"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#gerando-o-rbf-imagem-da-fpga","text":"O rbf \u00e9 o arquivo .sof gerado pelo Quartus na compila\u00e7\u00e3o s\u00f3 que comprimido e com algumas modifica\u00e7\u00f5es. Para gerar o arquivo .rbf a partir do .sof basta executarmos na pasta output_files : Note Voc\u00ea deve executar esse comando na pasta output_files do seu projeto Quartus! $ cd output_files $ quartus_cpf -c DE10_Standard_FB.sof -o bitstream_compression = on soc_system.rbf Note note que o arquivo gerado pelo Quartus chama DE10_Standard_FB.sof , voc\u00ea deve editar para o seu caso. Com o arquivo soc_system.rbf criado, \u00e9 s\u00f3 copiarmos ele para o SDCARD, substituindo o anterior. Execute Gere o soc_system.rbf do projeto (COMPILAR O QUARTUS!) Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Gerando o .rbf (imagem da FPGA)"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#dtb-informacoes-de-hardware-para-o-kernel","text":"O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico mudar, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! Ser\u00e1 necess\u00e1rio seguir os passos a seguir: Gere o .sopcinfo (platform designer) ( j\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer ) Gere o dts Compile o dts para dtb","title":"dtb (informa\u00e7\u00f5es de hardware para o Kernel)"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#gerando-o-dts","text":"Eu consegui esse comando via trocado com engenheiros da Terasic, os exemplos que encontrava nos tutorias da internet n\u00e3o funcionavam. Note Para funcionar \u00e9 necess\u00e1rio realizar o comando via o shell do embedded Execute os seguintes comandos: $ # Devemos executar os comandos dentro do shell do embedded (quartus) $ embedded_command_shell.sh $ sopc2dts --input soc_system.sopcinfo --output soc_system.dts --type dts --board soc_system_board_info.xml --board hps_common_board_info.xml --bridge-removal all --clocks Note Voc\u00ea deve executar esse comando na pasta raiz do seu projeto Quartus! Agora com o .dts gerado, vamos dar uma olhada em seu conte\u00fado e como o interpretar. O dts possui a anatomia a seguir: ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = <1>; #size-cells = <0>; enable-method = \"altr,socfpga-smp\"; /* appended from boardinfo */ hps_0_arm_a9_0: cpu@0x0 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000000>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1: cpu@0x1 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000001>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\", \"snps,dw-apb-uart\"; reg = <0xffc02000 0x00000100>; interrupt-parent = <&hps_0_arm_gic_0>; interrupts = <0 162 4>; clocks = <&l4_sp_clk>; reg-io-width = <4>; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg-shift = <2>; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\"; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 Para mais informa\u00e7\u00f5es sobre o dts : https://elinux.org/Device_Tree_Usage https://elinux.org/Device_Tree_Reference https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf","title":"Gerando o dts"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#gerando-o-dtb","text":"Execute os seguintes comandos (ainda dentro do embedded shell) $ dtc -I dts -O dtb -o soc_system.dtb soc_system.dts $ #Agora voc\u00ea pode sair do embedded shell: $ exit Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Gerando o dtb"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#testando","text":"Agora plugue o SDcard no kit de desenvolvimento, e ap\u00f3s inicializa\u00e7\u00e3o do kernel execute o programa blink led e veja os LEDs da FPGA piscarem! Interessante n\u00e9? Agora vamos fazer algo mais \u00fatil com isso..","title":"Testando"},{"location":"Tutorial-HPS-FPGA-VGA/","text":"Tutorial - HPS + FPGA - VGA \u00b6 Se repararem em nosso hardware verificamos que o mesmo possui uma sa\u00edda de v\u00eddeo VGA, por\u00e9m os sinais do VGA foram conectados nos pinos da FPGA! Tornando necess\u00e1rio a cria\u00e7\u00e3o de um hardware e sua conex\u00e3o com o HPS para que possamos fazer com que nosso Linux tenha uma sa\u00edda de v\u00eddeo. Diagrama Para conseguirmos ter uma sa\u00edda de v\u00eddeo no nosso sistema embarcado, teremos que realizar os seguintes passos: Configurar um hw que gerencie VGA alt_vip_* pense que vamos adicionar na FPGA uma 'placa de v\u00eddeo' muito simples Adicionar ao kernel um device driver para gerenciar esse hardware Configurar o kernel adicionando a parte de FB compilar o kernel Configurar no buildroot um programa capaz de manipular o FB e exibir uma imagem Frame Buffer \u00b6 Antes de mexermos com o hardware, vamos ver como o Linux trata uma sa\u00edda de v\u00eddeo! Voc\u00ea j\u00e1 ouviu falar de frame buffer (FB)? Verifique que o seu PC possui um: $ ls /dev | grep fb O FB \u00e9 uma regi\u00e3o da mem\u00f3ria RAM reservada e que cont\u00e9m um bitmap (se tiver uma placa de v\u00eddeo, essa mem\u00f3ria pode estar localizada nela), esse bitmap \u00e9 convertido (por hardware ou software) para a sa\u00edda de v\u00eddeo em quest\u00e3o. Essa convers\u00e3o de bitmap para sa\u00edda de v\u00eddeo depende do driver de v\u00eddeo que foi carregado para gerenciar (e criar) o FB, no caso de placas de v\u00eddeo intel, \u00e9 utilizado o driver vesa . Por\u00e9m nem tudo que \u00e9 exibido passa diretamente pelo FB, alguns programas podem querer maior performance e podem acessar o display direto ( Direct Graphics Access ), como demonstrado no diagrama a seguir: Framebuffer Console O Linux possui um driver (fbcon) que exibe um console em um framebuffer, para usar, basta ativar na configura\u00e7\u00e3o do kernel: Device Drivers Graphics Support->Frame buffer Devices->Console display driver support Framebuffer Console Support Para mais detalhes: https://www.kernel.org/doc/html/latest/fb/fbcon.html Hardware \u00b6 Como no exemplo anterior (para ganhar tempo), vamos utilizar um hardware da Terasic que j\u00e1 possui a parte da FPGA configurada para trabalharmos com o VGA. Copie a pasta DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC_FPGA/DE10_Standard_FB/ para o seu reposit\u00f3rio. Com o projeto DE10_Standard_FB copiado, abra o projeto no quartus e analise o soc_system.qsys no Platform Designer, voc\u00ea deve ver algo como: Eu deixei a mostra somente as partes referentes ao v\u00eddeo! Entendo o HW \u00b6 O projeto de HW possui dois componentes para tratar o VGA: alt_vip_vfr_vga e alt_vip_itc_0 , ambos fazem parte do pacote de IPs: 'Video and Image Processing Suite Intel FPGA' espec\u00edfico para processamento de v\u00eddeo (j\u00e1 suporta 8K e +60Hz) Video and Image Process ( VIP ) Suite Intel FPGA Retirado do site da Intel: The Intel\u00ae FPGA Video and Image Processing Suite is a collection of Intel FPGA IP functions that you can use to facilitate the development of custom video and image processing (VIP) designs. These Intel FPGA IP functions are suitable for use in a wide variety of image processing and display applications, such as video surveillance, broadcast, video conferencing, and medical and military imaging. The Video and Image Processing Suite features cores that range from simple building block functions, such as color space conversion to sophisticated video scaling functions that can implement programmable polyphase scaling. All the VIP cores use an open, low-overhead Avalon\u00ae Streaming (Avalon-ST) interface standard so that they can be easily connected You can use VIP cores to quickly build a custom video processing signal chain using the Intel Quartus\u00ae Prime Lite or Standard Edition software and the associated Platform Designer You can mix and match VIP cores with your own proprietary intellectual property (IP) You can use the Platform Designer to automatically integrate embedded processors and peripherals and generate arbitration logic Capable of supporting 8K video at 60fps and above https://www.intel.com.br/content/www/br/pt/programmable/products/intellectual-property/ip/dsp/m-alt-vipsuite.html alt_vip_vfr_vga \u00b6 \u00c9 um perif\u00e9rico do tipo Frame Reader e \u00e9 respons\u00e1vel por fazer a leitura de um Frame Buffer alocado em mem\u00f3ria ( avalon_master ) e o transformar em um Streaming ( avalon_streaming ). A maioria dos IP do VIP operam no barramento de dados do tipo: avalon_streaming , por isso \u00e9 necess\u00e1rio fazer a leitura do FB (que est\u00e1 alocado na mem\u00f3ria DDR3, conectada ao ARM). Os dados da DDR3 s\u00e3o transferidos para o alt_vip_vfr_vga via DMA pelo ARM/Linux, inicializado pelo device driver carregado no Linux! alt_vip_itc \u00b6 \u00c9 um perif\u00e9rico de v\u00eddeo que faz a convers\u00e3o do streaming de pixels para a sa\u00edda de v\u00eddeo em quest\u00e3o (VGA). O VGA \u00e9 um formato de sa\u00edda de v\u00eddeo DIGITA que possui 5 sinais: HSYNC/ VSYNC/ R/G/B. HSYNC: indica o fim da linha VSYNC: indica o fim da tela R/G/B: s\u00e3o os valores dos pixels. Note O sinal VGA \u00e9 simples. que at\u00e9 da para gerar via arduino: - http://labdegaragem.com/profiles/blogs/gerando-sinal-vga-colorido-com-arduino-completo Compilando \u00b6 Agora que analisamos o HW, podemos compilar e utilizar no nosso SoC! Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel) Gere o soc_system.rbf do projeto (COMPILAR O QUARTUS!) Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel) Driver \u00b6 Ser\u00e1 necess\u00e1rio carregarmos um device driver no kernel do linux para que possamos utilizar essa sa\u00edda de v\u00eddeo rec\u00e9m criada. Por\u00e9m o driver do IP alt_vip_vfr_vga n\u00e3o \u00e9 oficial do kernel, vamos ter que adicionar manualmente! dts \u00b6 Mas como o linux sabe que existe uma sa\u00edda de v\u00eddeo? No nosso caso ser\u00e1 via o device tree (.dtb) que \u00e9 passado pelo u-boot na inicializa\u00e7\u00e3o do kernel, se repararmos no novo .dts gerado com o hardware, existe um novo componente chamado de alt_vip_vfr_vga , que \u00e9 compat\u00edvel com o driver vip-frame-reader-9.1 : alt_vip_vfr_vga: vip@0x100031000 { compatible = \"ALTR,vip-frame-reader-14.0\", \"ALTR,vip-frame-reader-9.1\"; reg = <0x00000001 0x00031000 0x00000080>; clocks = <&clk_0>; max-width = <1024>; /* MAX_IMAGE_WIDTH type NUMBER */ max-height = <768>; /* MAX_IMAGE_HEIGHT type NUMBER */ bits-per-color = <8>; /* BITS_PER_PIXEL_PER_COLOR_PLANE type NUMBER */ colors-per-beat = <4>; /* NUMBER_OF_CHANNELS_IN_PARALLEL type NUMBER */ beats-per-pixel = <1>; /* NUMBER_OF_CHANNELS_IN_SEQUENCE type NUMBER */ mem-word-width = <128>; /* MEM_PORT_WIDTH type NUMBER */ }; //end vip@0x100031000 (alt_vip_vfr_vga) driver \u00b6 O driver vip-frame-reader-9.1 n\u00e3o \u00e9 oficial do linux, vamos ter que pegar uma implementa\u00e7\u00e3o realizada pelo o pessoal da Altera e utilizar. Os drivers no reposit\u00f3rio do Linux ficam na pasta: linux/drivers . No caso do v\u00eddeo/ framebuffer, em: linux/drivers/video/fbdev . Adicionando o driver altvipfb Siga o roteiro em: https://github.com/Insper/Embarcados-Avancados/blob/master/driver/altvipfb/README.md e depois volte para essa p\u00e1gina! Note Esse tutorial incluiu o driver do fb no kernel, outra op\u00e7\u00e3o seria criar um m\u00f3dulo (module) que poderia ser carregado conforme a necessidade. Testando Compile o kernel Copie o zImage novo para o SDCARD Liga um monitor a VGA Inicialize o linux embarcado Se tudo der certo, voc\u00ea deve ver dois pinguins no canto esquerdo do monitor. Cada pinguim representa um core do sistema, como nosso ARM \u00e9 um dual core, temos dois. Esse pinguins aparecem porque ativamos essa op\u00e7\u00e3o no kernel: CONFIG_LOGO=y CONFIG_LOGO_LINUX_MONO=y CONFIG_LOGO_LINUX_VGA16=y CONFIG_LOGO_LINUX_CLUT224=y Note \u00c9 poss\u00edvel editar o pinguim e fazer por exemplo, aparecer a carinha de voc\u00eas! Os arquivos ppm ficam na pasta /drivers/video/logo/ , esses s\u00e3o ent\u00e3o compilados na compila\u00e7\u00e3o do kernel. Quer fazer umas coisas legais com o FB? Tenta o seguinte: Exibir imagem rand\u00f4mica no FB: sudo cat /dev/urandom > /dev/fb0 ref: http://seenaburns.com/2018/04/04/writing-to-the-framebuffer/ Buildroot \u00b6 S\u00e3o diversas as solu\u00e7\u00f5es de desenvolvimento de interface gr\u00e1fica para Linux embarcado, e nem todas envolvem um gerenciador de janelas. A seguir uma lista de ferramentas que podem ser utilizadas: GUI: LittlevGL: https://littlevgl.com/ QT: https://www.qt.io/ emWin (comercial): https://www.segger.com/products/user-interface/emwin/ ... Existem outras solu\u00e7\u00f5es, vamos usar uma delas para exibir uma imagem na nossa tela! Quando eu estava fazendo esse roteiro, queria algo mais simples, em uma busca (n\u00e3o muito r\u00e1pida) na internet (keyword: linux frame buffer show image ) eu encontrei esse programa: fbv , que por sorte est\u00e1 no buildroot . fbv OVERVIEW fbv (FrameBuffer Viewer) is a simple program to view pictures on a linux framebuffer device. In 2000, when fbv was created, there were no other situable programs performing the same task, so the authors decided to follow the rule: 'If you need a tool - write it yourself!' :-) https://github.com/smokku/fbv Fa\u00e7a Adicione o programa fbv ao buildroot Compile o novo fs Grave no SDCard Grave uma imagem no SDCard No target, exiba a imagem usando o fbv","title":"Tutorial - HPS + FPGA - VGA"},{"location":"Tutorial-HPS-FPGA-VGA/#tutorial-hps-fpga-vga","text":"Se repararem em nosso hardware verificamos que o mesmo possui uma sa\u00edda de v\u00eddeo VGA, por\u00e9m os sinais do VGA foram conectados nos pinos da FPGA! Tornando necess\u00e1rio a cria\u00e7\u00e3o de um hardware e sua conex\u00e3o com o HPS para que possamos fazer com que nosso Linux tenha uma sa\u00edda de v\u00eddeo. Diagrama Para conseguirmos ter uma sa\u00edda de v\u00eddeo no nosso sistema embarcado, teremos que realizar os seguintes passos: Configurar um hw que gerencie VGA alt_vip_* pense que vamos adicionar na FPGA uma 'placa de v\u00eddeo' muito simples Adicionar ao kernel um device driver para gerenciar esse hardware Configurar o kernel adicionando a parte de FB compilar o kernel Configurar no buildroot um programa capaz de manipular o FB e exibir uma imagem","title":"Tutorial - HPS + FPGA - VGA"},{"location":"Tutorial-HPS-FPGA-VGA/#frame-buffer","text":"Antes de mexermos com o hardware, vamos ver como o Linux trata uma sa\u00edda de v\u00eddeo! Voc\u00ea j\u00e1 ouviu falar de frame buffer (FB)? Verifique que o seu PC possui um: $ ls /dev | grep fb O FB \u00e9 uma regi\u00e3o da mem\u00f3ria RAM reservada e que cont\u00e9m um bitmap (se tiver uma placa de v\u00eddeo, essa mem\u00f3ria pode estar localizada nela), esse bitmap \u00e9 convertido (por hardware ou software) para a sa\u00edda de v\u00eddeo em quest\u00e3o. Essa convers\u00e3o de bitmap para sa\u00edda de v\u00eddeo depende do driver de v\u00eddeo que foi carregado para gerenciar (e criar) o FB, no caso de placas de v\u00eddeo intel, \u00e9 utilizado o driver vesa . Por\u00e9m nem tudo que \u00e9 exibido passa diretamente pelo FB, alguns programas podem querer maior performance e podem acessar o display direto ( Direct Graphics Access ), como demonstrado no diagrama a seguir: Framebuffer Console O Linux possui um driver (fbcon) que exibe um console em um framebuffer, para usar, basta ativar na configura\u00e7\u00e3o do kernel: Device Drivers Graphics Support->Frame buffer Devices->Console display driver support Framebuffer Console Support Para mais detalhes: https://www.kernel.org/doc/html/latest/fb/fbcon.html","title":"Frame Buffer"},{"location":"Tutorial-HPS-FPGA-VGA/#hardware","text":"Como no exemplo anterior (para ganhar tempo), vamos utilizar um hardware da Terasic que j\u00e1 possui a parte da FPGA configurada para trabalharmos com o VGA. Copie a pasta DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC_FPGA/DE10_Standard_FB/ para o seu reposit\u00f3rio. Com o projeto DE10_Standard_FB copiado, abra o projeto no quartus e analise o soc_system.qsys no Platform Designer, voc\u00ea deve ver algo como: Eu deixei a mostra somente as partes referentes ao v\u00eddeo!","title":"Hardware"},{"location":"Tutorial-HPS-FPGA-VGA/#entendo-o-hw","text":"O projeto de HW possui dois componentes para tratar o VGA: alt_vip_vfr_vga e alt_vip_itc_0 , ambos fazem parte do pacote de IPs: 'Video and Image Processing Suite Intel FPGA' espec\u00edfico para processamento de v\u00eddeo (j\u00e1 suporta 8K e +60Hz) Video and Image Process ( VIP ) Suite Intel FPGA Retirado do site da Intel: The Intel\u00ae FPGA Video and Image Processing Suite is a collection of Intel FPGA IP functions that you can use to facilitate the development of custom video and image processing (VIP) designs. These Intel FPGA IP functions are suitable for use in a wide variety of image processing and display applications, such as video surveillance, broadcast, video conferencing, and medical and military imaging. The Video and Image Processing Suite features cores that range from simple building block functions, such as color space conversion to sophisticated video scaling functions that can implement programmable polyphase scaling. All the VIP cores use an open, low-overhead Avalon\u00ae Streaming (Avalon-ST) interface standard so that they can be easily connected You can use VIP cores to quickly build a custom video processing signal chain using the Intel Quartus\u00ae Prime Lite or Standard Edition software and the associated Platform Designer You can mix and match VIP cores with your own proprietary intellectual property (IP) You can use the Platform Designer to automatically integrate embedded processors and peripherals and generate arbitration logic Capable of supporting 8K video at 60fps and above https://www.intel.com.br/content/www/br/pt/programmable/products/intellectual-property/ip/dsp/m-alt-vipsuite.html","title":"Entendo o HW"},{"location":"Tutorial-HPS-FPGA-VGA/#alt_vip_vfr_vga","text":"\u00c9 um perif\u00e9rico do tipo Frame Reader e \u00e9 respons\u00e1vel por fazer a leitura de um Frame Buffer alocado em mem\u00f3ria ( avalon_master ) e o transformar em um Streaming ( avalon_streaming ). A maioria dos IP do VIP operam no barramento de dados do tipo: avalon_streaming , por isso \u00e9 necess\u00e1rio fazer a leitura do FB (que est\u00e1 alocado na mem\u00f3ria DDR3, conectada ao ARM). Os dados da DDR3 s\u00e3o transferidos para o alt_vip_vfr_vga via DMA pelo ARM/Linux, inicializado pelo device driver carregado no Linux!","title":"alt_vip_vfr_vga"},{"location":"Tutorial-HPS-FPGA-VGA/#alt_vip_itc","text":"\u00c9 um perif\u00e9rico de v\u00eddeo que faz a convers\u00e3o do streaming de pixels para a sa\u00edda de v\u00eddeo em quest\u00e3o (VGA). O VGA \u00e9 um formato de sa\u00edda de v\u00eddeo DIGITA que possui 5 sinais: HSYNC/ VSYNC/ R/G/B. HSYNC: indica o fim da linha VSYNC: indica o fim da tela R/G/B: s\u00e3o os valores dos pixels. Note O sinal VGA \u00e9 simples. que at\u00e9 da para gerar via arduino: - http://labdegaragem.com/profiles/blogs/gerando-sinal-vga-colorido-com-arduino-completo","title":"alt_vip_itc"},{"location":"Tutorial-HPS-FPGA-VGA/#compilando","text":"Agora que analisamos o HW, podemos compilar e utilizar no nosso SoC! Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel) Gere o soc_system.rbf do projeto (COMPILAR O QUARTUS!) Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Compilando"},{"location":"Tutorial-HPS-FPGA-VGA/#driver","text":"Ser\u00e1 necess\u00e1rio carregarmos um device driver no kernel do linux para que possamos utilizar essa sa\u00edda de v\u00eddeo rec\u00e9m criada. Por\u00e9m o driver do IP alt_vip_vfr_vga n\u00e3o \u00e9 oficial do kernel, vamos ter que adicionar manualmente!","title":"Driver"},{"location":"Tutorial-HPS-FPGA-VGA/#dts","text":"Mas como o linux sabe que existe uma sa\u00edda de v\u00eddeo? No nosso caso ser\u00e1 via o device tree (.dtb) que \u00e9 passado pelo u-boot na inicializa\u00e7\u00e3o do kernel, se repararmos no novo .dts gerado com o hardware, existe um novo componente chamado de alt_vip_vfr_vga , que \u00e9 compat\u00edvel com o driver vip-frame-reader-9.1 : alt_vip_vfr_vga: vip@0x100031000 { compatible = \"ALTR,vip-frame-reader-14.0\", \"ALTR,vip-frame-reader-9.1\"; reg = <0x00000001 0x00031000 0x00000080>; clocks = <&clk_0>; max-width = <1024>; /* MAX_IMAGE_WIDTH type NUMBER */ max-height = <768>; /* MAX_IMAGE_HEIGHT type NUMBER */ bits-per-color = <8>; /* BITS_PER_PIXEL_PER_COLOR_PLANE type NUMBER */ colors-per-beat = <4>; /* NUMBER_OF_CHANNELS_IN_PARALLEL type NUMBER */ beats-per-pixel = <1>; /* NUMBER_OF_CHANNELS_IN_SEQUENCE type NUMBER */ mem-word-width = <128>; /* MEM_PORT_WIDTH type NUMBER */ }; //end vip@0x100031000 (alt_vip_vfr_vga)","title":"dts"},{"location":"Tutorial-HPS-FPGA-VGA/#driver_1","text":"O driver vip-frame-reader-9.1 n\u00e3o \u00e9 oficial do linux, vamos ter que pegar uma implementa\u00e7\u00e3o realizada pelo o pessoal da Altera e utilizar. Os drivers no reposit\u00f3rio do Linux ficam na pasta: linux/drivers . No caso do v\u00eddeo/ framebuffer, em: linux/drivers/video/fbdev . Adicionando o driver altvipfb Siga o roteiro em: https://github.com/Insper/Embarcados-Avancados/blob/master/driver/altvipfb/README.md e depois volte para essa p\u00e1gina! Note Esse tutorial incluiu o driver do fb no kernel, outra op\u00e7\u00e3o seria criar um m\u00f3dulo (module) que poderia ser carregado conforme a necessidade. Testando Compile o kernel Copie o zImage novo para o SDCARD Liga um monitor a VGA Inicialize o linux embarcado Se tudo der certo, voc\u00ea deve ver dois pinguins no canto esquerdo do monitor. Cada pinguim representa um core do sistema, como nosso ARM \u00e9 um dual core, temos dois. Esse pinguins aparecem porque ativamos essa op\u00e7\u00e3o no kernel: CONFIG_LOGO=y CONFIG_LOGO_LINUX_MONO=y CONFIG_LOGO_LINUX_VGA16=y CONFIG_LOGO_LINUX_CLUT224=y Note \u00c9 poss\u00edvel editar o pinguim e fazer por exemplo, aparecer a carinha de voc\u00eas! Os arquivos ppm ficam na pasta /drivers/video/logo/ , esses s\u00e3o ent\u00e3o compilados na compila\u00e7\u00e3o do kernel. Quer fazer umas coisas legais com o FB? Tenta o seguinte: Exibir imagem rand\u00f4mica no FB: sudo cat /dev/urandom > /dev/fb0 ref: http://seenaburns.com/2018/04/04/writing-to-the-framebuffer/","title":"driver"},{"location":"Tutorial-HPS-FPGA-VGA/#buildroot","text":"S\u00e3o diversas as solu\u00e7\u00f5es de desenvolvimento de interface gr\u00e1fica para Linux embarcado, e nem todas envolvem um gerenciador de janelas. A seguir uma lista de ferramentas que podem ser utilizadas: GUI: LittlevGL: https://littlevgl.com/ QT: https://www.qt.io/ emWin (comercial): https://www.segger.com/products/user-interface/emwin/ ... Existem outras solu\u00e7\u00f5es, vamos usar uma delas para exibir uma imagem na nossa tela! Quando eu estava fazendo esse roteiro, queria algo mais simples, em uma busca (n\u00e3o muito r\u00e1pida) na internet (keyword: linux frame buffer show image ) eu encontrei esse programa: fbv , que por sorte est\u00e1 no buildroot . fbv OVERVIEW fbv (FrameBuffer Viewer) is a simple program to view pictures on a linux framebuffer device. In 2000, when fbv was created, there were no other situable programs performing the same task, so the authors decided to follow the rule: 'If you need a tool - write it yourself!' :-) https://github.com/smokku/fbv Fa\u00e7a Adicione o programa fbv ao buildroot Compile o novo fs Grave no SDCard Grave uma imagem no SDCard No target, exiba a imagem usando o fbv","title":"Buildroot"},{"location":"Tutorial-HPS-Kernel/","text":"Tutorial 7 - HPS - Compilando o kernel \u00b6 Nesse tutorial iremos compilar o kernel do Linux para o ARM do nosso SoC usando o toolchain que j\u00e1 temos configurado. Kernel 4.4 \u00b6 Clone o kernel do linux : $ git clone https://git.kernel.org $ cd linux Vamos trabalhar com a vers\u00e3o 4.4 do kernel que \u00e9 uma vers\u00e3o com: Long Time Suport (LTS), ou seja, ser\u00e1 mantida por muito mais tempo que as outras vers\u00f5es. A vers\u00e3o 4.4 foi lan\u00e7ada em 10 de Janeiro e ser\u00e1 mantida oficialmente at\u00e9 2021, ela \u00e9 tamb\u00e9m a vers\u00e3o Super LTS, com suporte estendido at\u00e9 2036. Linux Pense que um desenvolvedor de um sistema embarcado, que vai criar toda uma infra dedicada n\u00e3o quer ficar ter que ajustando e validando tudo novamente s\u00f3 para ter a vers\u00e3o mais nova do kenrel. A ideia de usar uma com maior suporte \u00e9 minimizar esfor\u00e7os. O kernel utiliza o sistema de tag do git: $ git tag ... v2.6.11 v2.6.11-tree v2.6.12 v2.6.12-rc2 v2.6.12-rc3 v2.6.12-rc4 v2.6.12-rc5 v2.6.12-rc6 v2.6.13-rc2 v2.6.14-rc2 v2.6.14-rc3 ... Note que revis\u00f5es \u00edmpares s\u00e3o para Karnel em est\u00e1gio de desenvolvimento, e n\u00fameros pares para vers\u00e3o de produ\u00e7\u00e3o, exemplo : Linux 2.4.x - Produ\u00e7\u00e3o Linux 2.5.x - Desenvolvimento Linux 2.6.x - Produ\u00e7\u00e3o .... Vamos criar um branch da vers\u00e3o v4.4, para isso execute o comando a seguir: $ git checkout v4.4 $ git checkout -b 4 .4-SoC Configurando o kernel \u00b6 Uma vez no branch 4.4-SoC precisamos configurar o kernel para nosso processador (ARM) e fazer as configura\u00e7\u00f5es necess\u00e1rias no kernel. Primeiramente iremos gerar um arquivo de configura\u00e7\u00e3o .config padr\u00e3o para SoCs ARM Altera: $ export ARCH = arm # indica a arquitetura do Kernel $ make socfpga_defconfig # gera o arquivo padr\u00e3o de configura\u00e7\u00e3o para SoC Note As configura\u00e7\u00e3o do kernel ficam salvos no arquivo: .config na raiz do reposit\u00f3rio. Quando executamos o comando make socfpga_defconfig , o mesmo \u00e9 inicializado com algumas configura\u00e7\u00f5es padr\u00f5es. Voc\u00ea pode dar uma olhada na pasta: linux/arch/arm/configs/socfpga_defconfig . Agora vamos configurar alguns par\u00e2metros espec\u00edficos do Kernel para a nossa aplica\u00e7\u00e3o: $ make ARCH = arm menuconfig Note Talvez seja necess\u00e1rio instalar o pacote libncurses5-dev Esse comando ir\u00e1 abrir a interface de configura\u00e7\u00e3o do Kernel do Linux (existem outras op\u00e7\u00f5es: make xconfig ; make config ; make gconfig , ...). Essa interface permite selecionarmos v\u00e1rias configura\u00e7\u00f5es do Kernel. Agora iremos seguir o roteiro proposto no tutorial a seguir, traduzido de maneira reduzida nesse tutorial. https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide Configurando \u00b6 Automatically append version information to the version string General Setup Desabilite : Automatically append version information to the version string Exclude/ Include Para Desativar utilize a letra N do teclado, para incluir a letra Y D\u00favidas? A maioria dos par\u00e2metros possui uma explica\u00e7\u00e3o, basta apertar ? para ler a respeito. Note ref : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Go into the \u201cGeneral Setup\u201d menu. Uncheck \u201cAutomatically append version information to the version string\u201d. This will prevent the kernel from adding extra \u201cversion\u201d information to the kernel. Whenever we try to dynamically load a driver (also called kernel modules, as discussed in a later section) the kernel will check to see if the driver was built with the same version of the source code as itself. If it isn\u2019t, it will reject to load that driver. For development, it\u2019s useful to disable these options to make it easier to test out different versions of drivers. In a production system however, it\u2019s recommend to keep this option enabled and only use drivers that were compiled with the correct version of the kernel. I encourage you to peruse the options in the General Setup menu and see what\u2019s available to you (hitting \u201c?\u201d to view the help info for the highlighted option). Of particular importance to us is the \u201cEmbedded System\u201d option (turns on advanced features) and the type of SLAB allocator used (determines how memory will be dynamically allocated in the kernel). If you want to use an initial ram disk or ram filesystem that would be enabled here as well (these will be explained in the next section). (texto extra\u00eddo da refer\u00eancia) Enable loadable module support \u00b6 Volte para o menu principal ( <ESC> <ESC> ) Note que o Enable loadable module support est\u00e1 ativado. Isso permite que o kernel seja modificado (pelo carregamento de drivers) ap\u00f3s a sua execu\u00e7\u00e3o. Isso ser\u00e1 \u00fatil quando formos desenvolver nosso pr\u00f3prio device driver, sem a necessidade de recompilarmos o kernel toda vez que desejamos testar uma modifica\u00e7\u00e3o no c\u00f3digo. \u00c9 essa configura\u00e7\u00e3o que permite utilizarmos USBs, SSDs, placas de rede via a possibilidade do carregamento de drivers de forma din\u00e2mica pelo sistema operacional. Support for large (2TB+) block devices and files \u00b6 No menu principal Enable the block layer Ative : Support for large (2TB+) block devices and files Essa op\u00e7\u00e3o ir\u00e1 permitir a utiliza\u00e7\u00e3o de parti\u00e7\u00f5es do tipo EXT4. Se esquecer essa op\u00e7\u00e3o e o kernel tiver em uma parti\u00e7\u00e3o EXT4 a mesma ser\u00e1 montada como READ-ONLY. The Extended 4 (ext4) filesystem \u00b6 Menu principal File systems Ative : The Extended 4 (ext4) filesystem Essa op\u00e7\u00e3o ir\u00e1 possibilitar que o kernel monte dispositivos formatados em EXT4. Pretendemos usar isso no SDCARD. Altera SOCFPGA family \u00b6 Menu principal System Type Ative : Altera SOCFGPA family Isso indica para o kernel qual ser\u00e1 o dispositivo que o mesmo ser\u00e1 executado, note que esssa op\u00e7\u00e3o possui um novo menu onde podemos ativar ou n\u00e3o a suspens\u00e3o para RAM. Symmetric Multi-Processing \u00b6 Menu principal Kernel Features Ative : Symmmetric Multi-Processing Essa op\u00e7\u00e3o indica para o kernel que ele deve utilizar os dois cores presente no ARM HPS da FPGA. Device Drivers \u00b6 Menu principal Device Drivers Indica quais drivers ser\u00e3o compilados junto com o kernel, note que j\u00e1 temos configurado drivers de rede (Network device support); GPIO (GPIO Support); RTC; DMA; ... . Lembre que j\u00e1 inicializamos o .config com uma configura\u00e7\u00e3o padr\u00e3o para SoCs Altera. Salvando \u00b6 Aperte ESC duas vezes ( <ESC> <ESC> ) e salve as configura\u00e7\u00f5es no arquivo .config .config \u00b6 Note De uma olhada no arquivo .config gerado! As vezes \u00e9 mais f\u00e1cil editar direto nele, do que ter que abrir o menu de configura\u00e7\u00e3o e encontrar o local de ativar um m\u00f3dulo. Compilando \u00b6 O makefile utiliza a vari\u00e1vel CROSS_COMPILE para definir o toolchain que ir\u00e1 fazer a compila\u00e7\u00e3o do kernel, vamos definir como sendo o GCC do Linaro baixado recentemente: $ export CROSS_COMPILE = $GCC_Linaro /arm-linux-gnueabihf- Para compilarmos o kernel : make ARCH = arm LOCALVERSION = zImage -j 4 Note -j4 executa a compila\u00e7\u00e3o em 4 threads, voc\u00ea pode ajustar esse valor para adequar ao seu processador. Dica Adicione o export CROSS_COMPILE=.... ao seu .bashrc para n\u00e3o ter que ficar digitando isso sempre que tiver que compilar o kernel. Fail Caso aconte\u00e7a algum erro de build, deve-se verificar o path do CROSS_COMPILE ou se existe alguma depend\u00eancia que n\u00e3o foi satisfeita. Esse comando faz com que o kernel do linux seja compilado em uma vers\u00e3o compactada que \u00e9 auto-extra\u00edda. Outras op\u00e7\u00f5es seriam : Image : Bin\u00e1rio do kernel zImage: vers\u00e3o compactada que possui self-extracting uImage: uma vers\u00e3o que j\u00e1 possui o bootloader uboot 1^: https://stackoverflow.com/questions/22322304/image-vs-zimage-vs-uimage o zImage \u00e9 salvo em: arch/arm/boot/zImage zImage Esse arquivo \u00e9 o bin\u00e1rio que cont\u00e9m o kernel do linux e ser\u00e1 executado no sistema embarcado. Agora devemos atualizar o kernel que est\u00e1 no SDCard, para isso segue o tutorial no /info-SDcard.md/ : Atualizando o kernel Executando \u00b6 Para verificar se tudo est\u00e1 certo, basta colocar o cart\u00e3o de mem\u00f3ria no kit e verificar a vers\u00e3o do kernel em execu\u00e7\u00e3o: $ uname -a Linux buildroot 4 .14.0 #1 SMP Mon Jul 16 21:22:58 -03 2018 armv7l GNU/Linux Mouse/ Teclado \u00b6 Example Plugue um mouse USB na placa e verifique se a mesma funciona!","title":"Tutorial 7 - HPS - Compilando o kernel"},{"location":"Tutorial-HPS-Kernel/#tutorial-7-hps-compilando-o-kernel","text":"Nesse tutorial iremos compilar o kernel do Linux para o ARM do nosso SoC usando o toolchain que j\u00e1 temos configurado.","title":"Tutorial 7 - HPS - Compilando o kernel"},{"location":"Tutorial-HPS-Kernel/#kernel-44","text":"Clone o kernel do linux : $ git clone https://git.kernel.org $ cd linux Vamos trabalhar com a vers\u00e3o 4.4 do kernel que \u00e9 uma vers\u00e3o com: Long Time Suport (LTS), ou seja, ser\u00e1 mantida por muito mais tempo que as outras vers\u00f5es. A vers\u00e3o 4.4 foi lan\u00e7ada em 10 de Janeiro e ser\u00e1 mantida oficialmente at\u00e9 2021, ela \u00e9 tamb\u00e9m a vers\u00e3o Super LTS, com suporte estendido at\u00e9 2036. Linux Pense que um desenvolvedor de um sistema embarcado, que vai criar toda uma infra dedicada n\u00e3o quer ficar ter que ajustando e validando tudo novamente s\u00f3 para ter a vers\u00e3o mais nova do kenrel. A ideia de usar uma com maior suporte \u00e9 minimizar esfor\u00e7os. O kernel utiliza o sistema de tag do git: $ git tag ... v2.6.11 v2.6.11-tree v2.6.12 v2.6.12-rc2 v2.6.12-rc3 v2.6.12-rc4 v2.6.12-rc5 v2.6.12-rc6 v2.6.13-rc2 v2.6.14-rc2 v2.6.14-rc3 ... Note que revis\u00f5es \u00edmpares s\u00e3o para Karnel em est\u00e1gio de desenvolvimento, e n\u00fameros pares para vers\u00e3o de produ\u00e7\u00e3o, exemplo : Linux 2.4.x - Produ\u00e7\u00e3o Linux 2.5.x - Desenvolvimento Linux 2.6.x - Produ\u00e7\u00e3o .... Vamos criar um branch da vers\u00e3o v4.4, para isso execute o comando a seguir: $ git checkout v4.4 $ git checkout -b 4 .4-SoC","title":"Kernel 4.4"},{"location":"Tutorial-HPS-Kernel/#configurando-o-kernel","text":"Uma vez no branch 4.4-SoC precisamos configurar o kernel para nosso processador (ARM) e fazer as configura\u00e7\u00f5es necess\u00e1rias no kernel. Primeiramente iremos gerar um arquivo de configura\u00e7\u00e3o .config padr\u00e3o para SoCs ARM Altera: $ export ARCH = arm # indica a arquitetura do Kernel $ make socfpga_defconfig # gera o arquivo padr\u00e3o de configura\u00e7\u00e3o para SoC Note As configura\u00e7\u00e3o do kernel ficam salvos no arquivo: .config na raiz do reposit\u00f3rio. Quando executamos o comando make socfpga_defconfig , o mesmo \u00e9 inicializado com algumas configura\u00e7\u00f5es padr\u00f5es. Voc\u00ea pode dar uma olhada na pasta: linux/arch/arm/configs/socfpga_defconfig . Agora vamos configurar alguns par\u00e2metros espec\u00edficos do Kernel para a nossa aplica\u00e7\u00e3o: $ make ARCH = arm menuconfig Note Talvez seja necess\u00e1rio instalar o pacote libncurses5-dev Esse comando ir\u00e1 abrir a interface de configura\u00e7\u00e3o do Kernel do Linux (existem outras op\u00e7\u00f5es: make xconfig ; make config ; make gconfig , ...). Essa interface permite selecionarmos v\u00e1rias configura\u00e7\u00f5es do Kernel. Agora iremos seguir o roteiro proposto no tutorial a seguir, traduzido de maneira reduzida nesse tutorial. https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide","title":"Configurando o kernel"},{"location":"Tutorial-HPS-Kernel/#configurando","text":"Automatically append version information to the version string General Setup Desabilite : Automatically append version information to the version string Exclude/ Include Para Desativar utilize a letra N do teclado, para incluir a letra Y D\u00favidas? A maioria dos par\u00e2metros possui uma explica\u00e7\u00e3o, basta apertar ? para ler a respeito. Note ref : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Go into the \u201cGeneral Setup\u201d menu. Uncheck \u201cAutomatically append version information to the version string\u201d. This will prevent the kernel from adding extra \u201cversion\u201d information to the kernel. Whenever we try to dynamically load a driver (also called kernel modules, as discussed in a later section) the kernel will check to see if the driver was built with the same version of the source code as itself. If it isn\u2019t, it will reject to load that driver. For development, it\u2019s useful to disable these options to make it easier to test out different versions of drivers. In a production system however, it\u2019s recommend to keep this option enabled and only use drivers that were compiled with the correct version of the kernel. I encourage you to peruse the options in the General Setup menu and see what\u2019s available to you (hitting \u201c?\u201d to view the help info for the highlighted option). Of particular importance to us is the \u201cEmbedded System\u201d option (turns on advanced features) and the type of SLAB allocator used (determines how memory will be dynamically allocated in the kernel). If you want to use an initial ram disk or ram filesystem that would be enabled here as well (these will be explained in the next section). (texto extra\u00eddo da refer\u00eancia)","title":"Configurando"},{"location":"Tutorial-HPS-Kernel/#enable-loadable-module-support","text":"Volte para o menu principal ( <ESC> <ESC> ) Note que o Enable loadable module support est\u00e1 ativado. Isso permite que o kernel seja modificado (pelo carregamento de drivers) ap\u00f3s a sua execu\u00e7\u00e3o. Isso ser\u00e1 \u00fatil quando formos desenvolver nosso pr\u00f3prio device driver, sem a necessidade de recompilarmos o kernel toda vez que desejamos testar uma modifica\u00e7\u00e3o no c\u00f3digo. \u00c9 essa configura\u00e7\u00e3o que permite utilizarmos USBs, SSDs, placas de rede via a possibilidade do carregamento de drivers de forma din\u00e2mica pelo sistema operacional.","title":"Enable loadable module support"},{"location":"Tutorial-HPS-Kernel/#support-for-large-2tb-block-devices-and-files","text":"No menu principal Enable the block layer Ative : Support for large (2TB+) block devices and files Essa op\u00e7\u00e3o ir\u00e1 permitir a utiliza\u00e7\u00e3o de parti\u00e7\u00f5es do tipo EXT4. Se esquecer essa op\u00e7\u00e3o e o kernel tiver em uma parti\u00e7\u00e3o EXT4 a mesma ser\u00e1 montada como READ-ONLY.","title":"Support for large (2TB+) block devices and files"},{"location":"Tutorial-HPS-Kernel/#the-extended-4-ext4-filesystem","text":"Menu principal File systems Ative : The Extended 4 (ext4) filesystem Essa op\u00e7\u00e3o ir\u00e1 possibilitar que o kernel monte dispositivos formatados em EXT4. Pretendemos usar isso no SDCARD.","title":"The Extended 4 (ext4) filesystem"},{"location":"Tutorial-HPS-Kernel/#altera-socfpga-family","text":"Menu principal System Type Ative : Altera SOCFGPA family Isso indica para o kernel qual ser\u00e1 o dispositivo que o mesmo ser\u00e1 executado, note que esssa op\u00e7\u00e3o possui um novo menu onde podemos ativar ou n\u00e3o a suspens\u00e3o para RAM.","title":"Altera SOCFPGA family"},{"location":"Tutorial-HPS-Kernel/#symmetric-multi-processing","text":"Menu principal Kernel Features Ative : Symmmetric Multi-Processing Essa op\u00e7\u00e3o indica para o kernel que ele deve utilizar os dois cores presente no ARM HPS da FPGA.","title":"Symmetric Multi-Processing"},{"location":"Tutorial-HPS-Kernel/#device-drivers","text":"Menu principal Device Drivers Indica quais drivers ser\u00e3o compilados junto com o kernel, note que j\u00e1 temos configurado drivers de rede (Network device support); GPIO (GPIO Support); RTC; DMA; ... . Lembre que j\u00e1 inicializamos o .config com uma configura\u00e7\u00e3o padr\u00e3o para SoCs Altera.","title":"Device Drivers"},{"location":"Tutorial-HPS-Kernel/#salvando","text":"Aperte ESC duas vezes ( <ESC> <ESC> ) e salve as configura\u00e7\u00f5es no arquivo .config","title":"Salvando"},{"location":"Tutorial-HPS-Kernel/#config","text":"Note De uma olhada no arquivo .config gerado! As vezes \u00e9 mais f\u00e1cil editar direto nele, do que ter que abrir o menu de configura\u00e7\u00e3o e encontrar o local de ativar um m\u00f3dulo.","title":".config"},{"location":"Tutorial-HPS-Kernel/#compilando","text":"O makefile utiliza a vari\u00e1vel CROSS_COMPILE para definir o toolchain que ir\u00e1 fazer a compila\u00e7\u00e3o do kernel, vamos definir como sendo o GCC do Linaro baixado recentemente: $ export CROSS_COMPILE = $GCC_Linaro /arm-linux-gnueabihf- Para compilarmos o kernel : make ARCH = arm LOCALVERSION = zImage -j 4 Note -j4 executa a compila\u00e7\u00e3o em 4 threads, voc\u00ea pode ajustar esse valor para adequar ao seu processador. Dica Adicione o export CROSS_COMPILE=.... ao seu .bashrc para n\u00e3o ter que ficar digitando isso sempre que tiver que compilar o kernel. Fail Caso aconte\u00e7a algum erro de build, deve-se verificar o path do CROSS_COMPILE ou se existe alguma depend\u00eancia que n\u00e3o foi satisfeita. Esse comando faz com que o kernel do linux seja compilado em uma vers\u00e3o compactada que \u00e9 auto-extra\u00edda. Outras op\u00e7\u00f5es seriam : Image : Bin\u00e1rio do kernel zImage: vers\u00e3o compactada que possui self-extracting uImage: uma vers\u00e3o que j\u00e1 possui o bootloader uboot 1^: https://stackoverflow.com/questions/22322304/image-vs-zimage-vs-uimage o zImage \u00e9 salvo em: arch/arm/boot/zImage zImage Esse arquivo \u00e9 o bin\u00e1rio que cont\u00e9m o kernel do linux e ser\u00e1 executado no sistema embarcado. Agora devemos atualizar o kernel que est\u00e1 no SDCard, para isso segue o tutorial no /info-SDcard.md/ : Atualizando o kernel","title":"Compilando"},{"location":"Tutorial-HPS-Kernel/#executando","text":"Para verificar se tudo est\u00e1 certo, basta colocar o cart\u00e3o de mem\u00f3ria no kit e verificar a vers\u00e3o do kernel em execu\u00e7\u00e3o: $ uname -a Linux buildroot 4 .14.0 #1 SMP Mon Jul 16 21:22:58 -03 2018 armv7l GNU/Linux","title":"Executando"},{"location":"Tutorial-HPS-Kernel/#mouse-teclado","text":"Example Plugue um mouse USB na placa e verifique se a mesma funciona!","title":"Mouse/ Teclado"},{"location":"Tutorial-HPS-Linux/","text":"Tutorial-HPS-Embarcando \u00b6 O HPS espera um SDCARD formatado com o esquema a seguir para que o possa carregar o boot loader e depois o kernel : Esse roteiro n\u00e3o trata a fundo a cria\u00e7\u00e3o das parti\u00e7\u00f5es no SDCARD, que podem ser facilmente geradas com o fsdisk do Linux. Aqui iremos usar uma imagem padr\u00e3o que j\u00e1 possui a formata\u00e7\u00e3o e atualizar o SDCARD com o nosso uboot / kernel e filesystem. Imagem padr\u00e3o \u00b6 Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem): O conte\u00fado da imagem e como a mesma foi criada \u00e9 detalhado no p\u00e1gina (acesse para fazer o download da iso): SDcard img base . Para usar, basta fazer o download e salvar no SDCard. Note que no comando DD deve-se substituir o SeuDevice pelo caminho que o seu Linux atribuiu ao dispositivo. Para saber basta verificar o dmesg: $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 Estamos interessados no: mmcblk0 . Agora vamos salvar a .iso no SDcard. Cuidado, se errar o dispositivo (of=/dev/mmcblk0) pode acontecer muitas coisas ruins $ sudo dd bs = 4M if = SDCardEmptyCycloneV of = /dev/mmcblk0 conv = fsync status = progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 819,2 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1,0 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 2121728 3799448 1677721 819 ,2M b W95 FAT32 /dev/mmcblk0p2 14336 2111488 2097153 1G 83 Linux /dev/mmcblk0p3 2048 4096 2049 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Pr\u00f3ximos passo \u00b6 Se \u00e9 a primeira vez nesse tutorial siga direto para o Tutorial HPS BlinkLED . Atualizando os arquivos \u00b6 Para atualizar o SDCARD com a vers\u00e3o rec\u00e9m gerada siga os passo a seguir. Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9 : /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildrrot. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6 $ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"Tutorial-HPS-Embarcando"},{"location":"Tutorial-HPS-Linux/#tutorial-hps-embarcando","text":"O HPS espera um SDCARD formatado com o esquema a seguir para que o possa carregar o boot loader e depois o kernel : Esse roteiro n\u00e3o trata a fundo a cria\u00e7\u00e3o das parti\u00e7\u00f5es no SDCARD, que podem ser facilmente geradas com o fsdisk do Linux. Aqui iremos usar uma imagem padr\u00e3o que j\u00e1 possui a formata\u00e7\u00e3o e atualizar o SDCARD com o nosso uboot / kernel e filesystem.","title":"Tutorial-HPS-Embarcando"},{"location":"Tutorial-HPS-Linux/#imagem-padrao","text":"Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem): O conte\u00fado da imagem e como a mesma foi criada \u00e9 detalhado no p\u00e1gina (acesse para fazer o download da iso): SDcard img base . Para usar, basta fazer o download e salvar no SDCard. Note que no comando DD deve-se substituir o SeuDevice pelo caminho que o seu Linux atribuiu ao dispositivo. Para saber basta verificar o dmesg: $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 Estamos interessados no: mmcblk0 . Agora vamos salvar a .iso no SDcard. Cuidado, se errar o dispositivo (of=/dev/mmcblk0) pode acontecer muitas coisas ruins $ sudo dd bs = 4M if = SDCardEmptyCycloneV of = /dev/mmcblk0 conv = fsync status = progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 819,2 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1,0 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 2121728 3799448 1677721 819 ,2M b W95 FAT32 /dev/mmcblk0p2 14336 2111488 2097153 1G 83 Linux /dev/mmcblk0p3 2048 4096 2049 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot .","title":"Imagem padr\u00e3o"},{"location":"Tutorial-HPS-Linux/#proximos-passo","text":"Se \u00e9 a primeira vez nesse tutorial siga direto para o Tutorial HPS BlinkLED .","title":"Pr\u00f3ximos passo"},{"location":"Tutorial-HPS-Linux/#atualizando-os-arquivos","text":"Para atualizar o SDCARD com a vers\u00e3o rec\u00e9m gerada siga os passo a seguir.","title":"Atualizando os arquivos"},{"location":"Tutorial-HPS-Linux/#kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9 : /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Kernel"},{"location":"Tutorial-HPS-Linux/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildrrot. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"Tutorial-HPS-Linux/#uboot-script-e-device-tree","text":"$ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"uboot script e device tree"},{"location":"Tutorial-HPS-Running/","text":"Tutorial 4 - HPS - Linux embarcado \u00b6 Danger Nesse tutorial mexemos com grava\u00e7\u00e3o de disco, se errar o dispositivo pode corromper seus arquivos!!! Vamos nessa etapa executar um linux de exemplo fornecido pela Terasic, para isso, ser\u00e1 necess\u00e1rio programarmos um SDcard com a imagem. Esse Linux \u00e9 um ubuntu para sistemas embarcados. Vamos executar os seguintes passos: Download e gravar a Imagem padr\u00e3o (iso) no SDcard Insira o SDCard na FPGA Conecte o USB na porta UART (perto da porta Ethernet) Conecte a alimenta\u00e7\u00e3o Conecte-se ao terminal via UART Imagem padr\u00e3o (sdcard) \u00b6 Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem), essa imagem \u00e9 um ubuntu para ARM com algumas configura\u00e7\u00f5es espec\u00edficas para FPGA Cyclone V (vamos ver isso mais para frente). Download Fa\u00e7a o download da imagem Linux Console (Kernel 4.5) do site da terasic: - \"Linux BSP (Board Support Package): MicroSD Card Image\" Extraia o arquio de10_standard_linux_console.img do arquivo zipado, esse .img \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Agora temos que copiar o img para o cart\u00e3o de mem\u00f3ria. Insira o cart\u00e3o de mem\u00f3ria no computador Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg , que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: Cuidado, estou assumindo que nenhum dispositivo foi inserido ap\u00f3s o SDcard $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 O dmesg possui o log que o meu SDCARD foi alocado ao: /dev/mmclk0 , no seu linux pode ser outro nome! Warning Isso pode mudar de PC para PC! Agora vamos salvar a .iso no SDcard. Danger Cuidado, se errar o dispositivo (no meu caso: of=/dev/mmcblk0) pode acontecer coisas muito ruins com os seus dados $ sudo dd bs = 4M if = de10_standard_linux_console.img of = /dev/mmcblk0 conv = fsync status = progress $ sync dd O comando dd executa uma c\u00f3pia bit a bit de um arquivo de entrada input file: if para um output file: of O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 3,3 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 4096 1028095 1024000 500M b W95 FAT32 /dev/mmcblk0p2 1028096 7376895 6348800 3G 83 Linux /dev/mmcblk0p3 2048 4095 2048 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Success Agora remova o SDCard e o coloque na FPGA USB - UART \u00b6 O USB UART \u00e9 um conector que possibilita acessar a sa\u00edda serial do HPS via porta serial. No linux o driver \u00e9 reconhecido automaticamente, no Windows ser\u00e1 necess\u00e1rio instalar manualmente o driver da serial.. Uma vez conectado no linux host, verificamos que o mesmo foi mapeado para um dispositivo do tipo serial ( no meu caso com nome ttyUSB0 ): $ dmesg | tail .... [80473.426308] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected [80473.426333] usb 1-2: Detected FT232RL [80473.426456] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0 ... Warning Isso pode mudar de PC para PC! Para conectarmos nessa porta, precisamos usar um programa do tipo: emulador de terminal. No caso iremos utilizar o screen (verificar se possui instalado). Note que o comando a seguir deve ser modificado para o device ( /dev/ttyxxx ) na qual o seu linux associou a porta USB-Serial, extra\u00eddo do dmesg. $ screen /dev/ttyUSB0 115200,cs8 Para sair do terminal: ctrl+A : quit Linux \u00b6 Logue no linux com o usu\u00e1rio: root , sem senha. No linux verifique que existem um execut\u00e1vel chamado HPS_FPGA_LED na pasta /home/root/ . Esse programa faz com que os LEDs da FPGA pisquem. user e password user: root pass: `` Legal! Vamos agora descobrir como executar um kernel compilado por n\u00f3s!","title":"Tutorial 4 - HPS - Linux embarcado"},{"location":"Tutorial-HPS-Running/#tutorial-4-hps-linux-embarcado","text":"Danger Nesse tutorial mexemos com grava\u00e7\u00e3o de disco, se errar o dispositivo pode corromper seus arquivos!!! Vamos nessa etapa executar um linux de exemplo fornecido pela Terasic, para isso, ser\u00e1 necess\u00e1rio programarmos um SDcard com a imagem. Esse Linux \u00e9 um ubuntu para sistemas embarcados. Vamos executar os seguintes passos: Download e gravar a Imagem padr\u00e3o (iso) no SDcard Insira o SDCard na FPGA Conecte o USB na porta UART (perto da porta Ethernet) Conecte a alimenta\u00e7\u00e3o Conecte-se ao terminal via UART","title":"Tutorial 4 - HPS - Linux embarcado"},{"location":"Tutorial-HPS-Running/#imagem-padrao-sdcard","text":"Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem), essa imagem \u00e9 um ubuntu para ARM com algumas configura\u00e7\u00f5es espec\u00edficas para FPGA Cyclone V (vamos ver isso mais para frente). Download Fa\u00e7a o download da imagem Linux Console (Kernel 4.5) do site da terasic: - \"Linux BSP (Board Support Package): MicroSD Card Image\" Extraia o arquio de10_standard_linux_console.img do arquivo zipado, esse .img \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Agora temos que copiar o img para o cart\u00e3o de mem\u00f3ria. Insira o cart\u00e3o de mem\u00f3ria no computador Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg , que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: Cuidado, estou assumindo que nenhum dispositivo foi inserido ap\u00f3s o SDcard $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 O dmesg possui o log que o meu SDCARD foi alocado ao: /dev/mmclk0 , no seu linux pode ser outro nome! Warning Isso pode mudar de PC para PC! Agora vamos salvar a .iso no SDcard. Danger Cuidado, se errar o dispositivo (no meu caso: of=/dev/mmcblk0) pode acontecer coisas muito ruins com os seus dados $ sudo dd bs = 4M if = de10_standard_linux_console.img of = /dev/mmcblk0 conv = fsync status = progress $ sync dd O comando dd executa uma c\u00f3pia bit a bit de um arquivo de entrada input file: if para um output file: of O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 3,3 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 4096 1028095 1024000 500M b W95 FAT32 /dev/mmcblk0p2 1028096 7376895 6348800 3G 83 Linux /dev/mmcblk0p3 2048 4095 2048 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Success Agora remova o SDCard e o coloque na FPGA","title":"Imagem padr\u00e3o (sdcard)"},{"location":"Tutorial-HPS-Running/#usb-uart","text":"O USB UART \u00e9 um conector que possibilita acessar a sa\u00edda serial do HPS via porta serial. No linux o driver \u00e9 reconhecido automaticamente, no Windows ser\u00e1 necess\u00e1rio instalar manualmente o driver da serial.. Uma vez conectado no linux host, verificamos que o mesmo foi mapeado para um dispositivo do tipo serial ( no meu caso com nome ttyUSB0 ): $ dmesg | tail .... [80473.426308] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected [80473.426333] usb 1-2: Detected FT232RL [80473.426456] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0 ... Warning Isso pode mudar de PC para PC! Para conectarmos nessa porta, precisamos usar um programa do tipo: emulador de terminal. No caso iremos utilizar o screen (verificar se possui instalado). Note que o comando a seguir deve ser modificado para o device ( /dev/ttyxxx ) na qual o seu linux associou a porta USB-Serial, extra\u00eddo do dmesg. $ screen /dev/ttyUSB0 115200,cs8 Para sair do terminal: ctrl+A : quit","title":"USB - UART"},{"location":"Tutorial-HPS-Running/#linux","text":"Logue no linux com o usu\u00e1rio: root , sem senha. No linux verifique que existem um execut\u00e1vel chamado HPS_FPGA_LED na pasta /home/root/ . Esse programa faz com que os LEDs da FPGA pisquem. user e password user: root pass: `` Legal! Vamos agora descobrir como executar um kernel compilado por n\u00f3s!","title":"Linux"},{"location":"Tutorial-HPS-SDcard/","text":"Atualizando o SDCARD \u00b6 Premissas Atualizando o preload \u00b6 TBD Atualizando o uboot \u00b6 TBD uboot script \u00b6 $ cp u-boot.scr /run/media/corsi/B0DA-B234/ Atualizando Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. Atualizando o dts \u00b6 $ cp socfpga.dtb /run/media/corsi/B0DA-B234/ FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6","title":"Atualizando o SDCARD"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-sdcard","text":"Premissas","title":"Atualizando o SDCARD"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-preload","text":"TBD","title":"Atualizando o preload"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-uboot","text":"TBD","title":"Atualizando o uboot"},{"location":"Tutorial-HPS-SDcard/#uboot-script","text":"$ cp u-boot.scr /run/media/corsi/B0DA-B234/","title":"uboot script"},{"location":"Tutorial-HPS-SDcard/#atualizando-kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Atualizando Kernel"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-dts","text":"$ cp socfpga.dtb /run/media/corsi/B0DA-B234/","title":"Atualizando o dts"},{"location":"Tutorial-HPS-SDcard/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"Tutorial-HPS-SDcard/#uboot-script-e-device-tree","text":"","title":"uboot script e device tree"},{"location":"Tutorial-HPS/","text":"Vis\u00e3o geral \u00b6 A FPGA contida no kit DE10-Standard \u00e9 um chip SoC que em um \u00fanico dispositivo que possui duas partes: o fabric da FPGA e um Hardware Process System (HPS). HPS \u00e9 o termo utilizado pela Intel-Altera para definir a parte da FPGA que \u00e9 fixa e relativa ao processador ARM A9 (pode ser outro ARM, depende da fam\u00edlia da FPGA). O HPS possui uma unidade de processamento com um ou dois Cores (depende do chip, no nosso caso \u00e9 dual core ) e alguns perif\u00e9ricos conectados em seu barramento (DMA, UART, USB, EMACS, ...). Al\u00e9m dos perif\u00e9ricos j\u00e1 contidos no HPS \u00e9 poss\u00edvel conectarmos novos perif\u00e9ricos sintetizados na FPGA via a interface HPS FPGA Interfaces . Ler Introdu\u00e7\u00e3o: 1 Introduction to Cyclone V Hard Processor System (HPS) Fam\u00edlia de FPGAs \u00b6 A Altera possui quatro fam\u00edlia de FPGAs-SoC : Stratix 10 SoC: High end, 14nm com ARM-Cortex-A53 de 64bits quad-core Arria 10 SoC: 20nm, Cortex A9 duas core com grande capacidade na FPGA Temos um kit no lab Arria V SoC: 28nm, Cortex A9 com foco em telecomunica\u00e7\u00f5es Cyclone V SoC : Fam\u00edlia low end com valor mais baixo e mais low power. Cortex A9 \u00b6 O Cortex A9 existente no HPS da Cyclone V possui as caracter\u00edsticas a seguir (extra\u00eddo do datasheet ): ARM Cortex-A9 MPCore One or two ARM Cortex-A9 processors in a cluster NEON SIMD coprocessor and VFPv3 per processor Snoop Control Unit (SCU) to ensure coherency within the cluster Accelerator coherency port (ACP) that accepts coherency memory access requests Interrupt controller One general-purpose timer and one watchdog timer per processor \u2022 Debug and trace features 32 KB instruction and 32 KB data level 1 (L1) caches per processor Memory management unit (MMU) per processor ARM L2-310 level 2 (L2) cache Shared 512 KB L2 cache A seguir um diagrama detalhado do HPS: Conex\u00e3o entre HPS e FPGA \u00b6 Note que existe no diagrama anterior algumas interfaces definidas no \"FPGA Portion\", essas interfaces permitem a ponte entre o Fabric da FPGA e o ARM hard core do chip. As interfaces s\u00e3o, resumidamente: FPGA to HPS: Barramento na qual um Master na FPGA (Platform Designer) acessa o ARM HPS to FPGA: Barramento pelo qual o ARM acessa um perif\u00e9rico (slave) na FPGA Lightweight HPS to FPGA: Barramento de menor banda que conecta o ARM em um perif\u00e9rico na FPGA (slave) 1-6 Masters SDRAM Controller: Permite a FPGA ler e escrever da mem\u00f3ria SDRAM externa ao chip AXI \u00b6 Os barramentos s\u00e3o todos do tipo AXI , um padr\u00e3o definido pela pr\u00f3pria ARM e usada em seus microcontroladores. AXI - AVALON Via Platform Designer podemos conectarmos perif\u00e9ricos com o barramento Avalon (mm) no barramento AXI do ARM, isso \u00e9 poss\u00edvel por uma \"m\u00e1gica\" que a PD faz convertendo um barramento no outro de forma transparente ao usu\u00e1rio. SDRAM \u00b6 A SDRAM deve ser usada com muita cautela pois ela ser\u00e1 compartilhada com o Linux que estar\u00e1 em execu\u00e7\u00e3o no ARM, caso um perif\u00e9rico da FPGA acesse \"aleatoriamente\" a mem\u00f3ria SDRAM ele pode sobrescrever dados importantes do kernel e crashar todo o sistema. Essa aloca\u00e7\u00e3o deve ser realizada no boot do Linux onde iremos dizer qual regi\u00e3o de mem\u00f3ria o kernel pode utilizar. Note Essa mem\u00f3ria que \u00e9 acess\u00edvel tanto pelo Linux quanto pela FPGA \u00e9 uma boa maneira de compartilhamento de dados a serem processados. Aplica\u00e7\u00f5es \u00b6 Com isso agora \u00e9 poss\u00edvel unir o melhor dos dois mundos: flexibilidade e paralelismo da FPGA com o melhor dos processadores embarcados ARM. Nos nossos projetos, o NIOS ser\u00e1 substitu\u00eddo pelo ARM, possibilitando maior poder de processamento e tamb\u00e9m suportando a execu\u00e7\u00e3o de sistemas mais complexos, tal como o Linux. Pense na aplica\u00e7\u00e3o de uma imagem que ser\u00e1 processada pela FPGA a fim de aumentar o throughtput do sistema. Essa imagem ser\u00e1 lida por exemplo por uma c\u00e2mera USB conectada no HPS, como geralmente o HPS executa um Linux, temos facilidade de acesso ao driver dessa c\u00e2mera USB. A imagem ser\u00e1 ent\u00e3o lida via o driver e ent\u00e3o alocada na mem\u00f3ria SDRAM, o endere\u00e7o da mem\u00f3ria assim como as propriedades do processamento ser\u00e3o transferidas para um perif\u00e9rico customizado no Fabric da FPGA via a interface LT-AXI. O perif\u00e9rico que est\u00e1 em modo wait, ap\u00f3s ser configurado, come\u00e7a a ler a imagem na mem\u00f3ria SDRAM, processar e salvar o resultado na pr\u00f3pria mem\u00f3ria. Ao final da convers\u00e3o uma interrup\u00e7\u00e3o \u00e9 gerada e o Linux ir\u00e1 tratar o dado. Enquanto o perif\u00e9rico processa o dado, a aplica\u00e7\u00e3o pode de forma concorrente, ler uma nova imagem e j\u00e1 alocar em um novo endere\u00e7o de mem\u00f3ria, pois o processamento e a aquisi\u00e7\u00e3o agora funcionam de forma simult\u00e2nea. Pr\u00f3ximos passos \u00b6 Vamos agora subir executar um Linux no ARM, iremos nesse momento trabalhar com uma imagem j\u00e1 pronto. Siga para o tutorial ter que configurar nossa infra para podermos gerar c\u00f3digos para o ARM, siga o para: Tutorial HPS BuildSystem .","title":"Vis\u00e3o geral"},{"location":"Tutorial-HPS/#visao-geral","text":"A FPGA contida no kit DE10-Standard \u00e9 um chip SoC que em um \u00fanico dispositivo que possui duas partes: o fabric da FPGA e um Hardware Process System (HPS). HPS \u00e9 o termo utilizado pela Intel-Altera para definir a parte da FPGA que \u00e9 fixa e relativa ao processador ARM A9 (pode ser outro ARM, depende da fam\u00edlia da FPGA). O HPS possui uma unidade de processamento com um ou dois Cores (depende do chip, no nosso caso \u00e9 dual core ) e alguns perif\u00e9ricos conectados em seu barramento (DMA, UART, USB, EMACS, ...). Al\u00e9m dos perif\u00e9ricos j\u00e1 contidos no HPS \u00e9 poss\u00edvel conectarmos novos perif\u00e9ricos sintetizados na FPGA via a interface HPS FPGA Interfaces . Ler Introdu\u00e7\u00e3o: 1 Introduction to Cyclone V Hard Processor System (HPS)","title":"Vis\u00e3o geral"},{"location":"Tutorial-HPS/#familia-de-fpgas","text":"A Altera possui quatro fam\u00edlia de FPGAs-SoC : Stratix 10 SoC: High end, 14nm com ARM-Cortex-A53 de 64bits quad-core Arria 10 SoC: 20nm, Cortex A9 duas core com grande capacidade na FPGA Temos um kit no lab Arria V SoC: 28nm, Cortex A9 com foco em telecomunica\u00e7\u00f5es Cyclone V SoC : Fam\u00edlia low end com valor mais baixo e mais low power.","title":"Fam\u00edlia de FPGAs"},{"location":"Tutorial-HPS/#cortex-a9","text":"O Cortex A9 existente no HPS da Cyclone V possui as caracter\u00edsticas a seguir (extra\u00eddo do datasheet ): ARM Cortex-A9 MPCore One or two ARM Cortex-A9 processors in a cluster NEON SIMD coprocessor and VFPv3 per processor Snoop Control Unit (SCU) to ensure coherency within the cluster Accelerator coherency port (ACP) that accepts coherency memory access requests Interrupt controller One general-purpose timer and one watchdog timer per processor \u2022 Debug and trace features 32 KB instruction and 32 KB data level 1 (L1) caches per processor Memory management unit (MMU) per processor ARM L2-310 level 2 (L2) cache Shared 512 KB L2 cache A seguir um diagrama detalhado do HPS:","title":"Cortex A9"},{"location":"Tutorial-HPS/#conexao-entre-hps-e-fpga","text":"Note que existe no diagrama anterior algumas interfaces definidas no \"FPGA Portion\", essas interfaces permitem a ponte entre o Fabric da FPGA e o ARM hard core do chip. As interfaces s\u00e3o, resumidamente: FPGA to HPS: Barramento na qual um Master na FPGA (Platform Designer) acessa o ARM HPS to FPGA: Barramento pelo qual o ARM acessa um perif\u00e9rico (slave) na FPGA Lightweight HPS to FPGA: Barramento de menor banda que conecta o ARM em um perif\u00e9rico na FPGA (slave) 1-6 Masters SDRAM Controller: Permite a FPGA ler e escrever da mem\u00f3ria SDRAM externa ao chip","title":"Conex\u00e3o entre HPS e FPGA"},{"location":"Tutorial-HPS/#axi","text":"Os barramentos s\u00e3o todos do tipo AXI , um padr\u00e3o definido pela pr\u00f3pria ARM e usada em seus microcontroladores. AXI - AVALON Via Platform Designer podemos conectarmos perif\u00e9ricos com o barramento Avalon (mm) no barramento AXI do ARM, isso \u00e9 poss\u00edvel por uma \"m\u00e1gica\" que a PD faz convertendo um barramento no outro de forma transparente ao usu\u00e1rio.","title":"AXI"},{"location":"Tutorial-HPS/#sdram","text":"A SDRAM deve ser usada com muita cautela pois ela ser\u00e1 compartilhada com o Linux que estar\u00e1 em execu\u00e7\u00e3o no ARM, caso um perif\u00e9rico da FPGA acesse \"aleatoriamente\" a mem\u00f3ria SDRAM ele pode sobrescrever dados importantes do kernel e crashar todo o sistema. Essa aloca\u00e7\u00e3o deve ser realizada no boot do Linux onde iremos dizer qual regi\u00e3o de mem\u00f3ria o kernel pode utilizar. Note Essa mem\u00f3ria que \u00e9 acess\u00edvel tanto pelo Linux quanto pela FPGA \u00e9 uma boa maneira de compartilhamento de dados a serem processados.","title":"SDRAM"},{"location":"Tutorial-HPS/#aplicacoes","text":"Com isso agora \u00e9 poss\u00edvel unir o melhor dos dois mundos: flexibilidade e paralelismo da FPGA com o melhor dos processadores embarcados ARM. Nos nossos projetos, o NIOS ser\u00e1 substitu\u00eddo pelo ARM, possibilitando maior poder de processamento e tamb\u00e9m suportando a execu\u00e7\u00e3o de sistemas mais complexos, tal como o Linux. Pense na aplica\u00e7\u00e3o de uma imagem que ser\u00e1 processada pela FPGA a fim de aumentar o throughtput do sistema. Essa imagem ser\u00e1 lida por exemplo por uma c\u00e2mera USB conectada no HPS, como geralmente o HPS executa um Linux, temos facilidade de acesso ao driver dessa c\u00e2mera USB. A imagem ser\u00e1 ent\u00e3o lida via o driver e ent\u00e3o alocada na mem\u00f3ria SDRAM, o endere\u00e7o da mem\u00f3ria assim como as propriedades do processamento ser\u00e3o transferidas para um perif\u00e9rico customizado no Fabric da FPGA via a interface LT-AXI. O perif\u00e9rico que est\u00e1 em modo wait, ap\u00f3s ser configurado, come\u00e7a a ler a imagem na mem\u00f3ria SDRAM, processar e salvar o resultado na pr\u00f3pria mem\u00f3ria. Ao final da convers\u00e3o uma interrup\u00e7\u00e3o \u00e9 gerada e o Linux ir\u00e1 tratar o dado. Enquanto o perif\u00e9rico processa o dado, a aplica\u00e7\u00e3o pode de forma concorrente, ler uma nova imagem e j\u00e1 alocar em um novo endere\u00e7o de mem\u00f3ria, pois o processamento e a aquisi\u00e7\u00e3o agora funcionam de forma simult\u00e2nea.","title":"Aplica\u00e7\u00f5es"},{"location":"Tutorial-HPS/#proximos-passos","text":"Vamos agora subir executar um Linux no ARM, iremos nesse momento trabalhar com uma imagem j\u00e1 pronto. Siga para o tutorial ter que configurar nossa infra para podermos gerar c\u00f3digos para o ARM, siga o para: Tutorial HPS BuildSystem .","title":"Pr\u00f3ximos passos"},{"location":"info-FPGA-e-Softwares/","text":"Infraestrutura / FPGA e SWs \u00b6 Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente. DE10-Standard \u00b6 Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic ao curso to $350 que possui em seu core uma FPGA Cyclone V com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip. Softwares \u00b6 Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Infraestrutura / FPGA e SWs"},{"location":"info-FPGA-e-Softwares/#infraestrutura-fpga-e-sws","text":"Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente.","title":"Infraestrutura / FPGA e SWs"},{"location":"info-FPGA-e-Softwares/#de10-standard","text":"Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic ao curso to $350 que possui em seu core uma FPGA Cyclone V com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip.","title":"DE10-Standard"},{"location":"info-FPGA-e-Softwares/#softwares","text":"Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Softwares"},{"location":"info-HPS-Serial/","text":"Screen \u00b6 Possu\u00edmos algumas formas de acessar e utilizar esse sistema: Via terminal UART Via terminal ssh Se o linux possuir interface gr\u00e1fica, podemos usar um teclado e mouse. Interface gr\u00e1fica via ssh UART \u00b6 O linux no HPS \u00e9 geralmente configurado (no bootloader) para possuir um terminal redirecionado para uma porta UART, essa porta UART \u00e9 dispon\u00edvel via FTDI em um dos USBs da placa (o que estiver escrito UART) e ent\u00e3o pode ser acessado como uma UART. Para isso h\u00e1 uma porta USB espec\u00edfica (UART). Uma vez conectada a porta USB ao PC e energizada a placa, podemos verificar em qual device a porta serial foi mapeada (no host ): $ demsg | tail [ 95158 .497894 ] ftdi_sio 1 -1.1:1.0: device disconnected [ 95161 .649187 ] usb 1 -1.1: new full-speed USB device number 22 using xhci_hcd [ 95161 .748948 ] ftdi_sio 1 -1.1:1.0: FTDI USB Serial Device converter detected [ 95161 .749067 ] usb 1 -1.1: Detected FT232RL [ 95161 .756092 ] usb 1 -1.1: FTDI USB Serial Device converter now attached to ttyUSB0 No log, verificamos que um dispositivo FTDI USB Serial Device foi conectado a ttyUSB0 . E ent\u00e3o podemos abrir o terminal por qualquer programa de porta serial (PUTTY, ...), nesse exemplo utilizaremos o programa screen . $ screen /dev/ttyUSB0 115200 ,cs8 Para melhoramos a interface com o screen crie um arquivo ~/.screenrc e adicione o seguinte conte\u00fado a ele # Enable mouse scrolling and scroll bar history scrolling termcapinfo xterm* ti@:te@ talvez seja necess\u00e1rio instalar o screen. Feito isso, reinicie o target (religando a energia) para termos acesso a todo o log de inicializa\u00e7\u00e3o. notem que no meu caso o nome atribuido ao USB-UART foi o /dev/ttyUSB0 , isso pode mudar no PC de voc\u00eas Uma vez conectado, agora temos acesso a todas as funcionalidades do linux como um bash normal. Na verdade o terminal j\u00e1 \u00e9 configurado para funcionar j\u00e1 no boot, ou seja, conseguimos ter acesso as informa\u00e7\u00f5es do u-boot. Kernel e porta serial \u00b6 Como o kernel sabe qual porta ele deve utilizar para imprimir o log e usar como terminal ? Esse par\u00e2metro \u00e9 passado pelo u-boot para o kernel via o Device Tree : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-1.0\", \"snps,dw-apb-uart\"; reg = < 0xFFC02000 0x00001000 >; interrupt-parent = < &hps_0_arm_gic_0 >; interrupts = < 0 162 4 >; reg-io-width = < 4 >; reg-shift = < 2 >; clock-frequency = < 100000000 >; }; E ent\u00e3o passado com o argumento para o kernel: bootargs = \"console=ttyS0,115200\"; (esse exemplo n\u00e3o \u00e9 da nossa FPGA)","title":"Screen"},{"location":"info-HPS-Serial/#screen","text":"Possu\u00edmos algumas formas de acessar e utilizar esse sistema: Via terminal UART Via terminal ssh Se o linux possuir interface gr\u00e1fica, podemos usar um teclado e mouse. Interface gr\u00e1fica via ssh","title":"Screen"},{"location":"info-HPS-Serial/#uart","text":"O linux no HPS \u00e9 geralmente configurado (no bootloader) para possuir um terminal redirecionado para uma porta UART, essa porta UART \u00e9 dispon\u00edvel via FTDI em um dos USBs da placa (o que estiver escrito UART) e ent\u00e3o pode ser acessado como uma UART. Para isso h\u00e1 uma porta USB espec\u00edfica (UART). Uma vez conectada a porta USB ao PC e energizada a placa, podemos verificar em qual device a porta serial foi mapeada (no host ): $ demsg | tail [ 95158 .497894 ] ftdi_sio 1 -1.1:1.0: device disconnected [ 95161 .649187 ] usb 1 -1.1: new full-speed USB device number 22 using xhci_hcd [ 95161 .748948 ] ftdi_sio 1 -1.1:1.0: FTDI USB Serial Device converter detected [ 95161 .749067 ] usb 1 -1.1: Detected FT232RL [ 95161 .756092 ] usb 1 -1.1: FTDI USB Serial Device converter now attached to ttyUSB0 No log, verificamos que um dispositivo FTDI USB Serial Device foi conectado a ttyUSB0 . E ent\u00e3o podemos abrir o terminal por qualquer programa de porta serial (PUTTY, ...), nesse exemplo utilizaremos o programa screen . $ screen /dev/ttyUSB0 115200 ,cs8 Para melhoramos a interface com o screen crie um arquivo ~/.screenrc e adicione o seguinte conte\u00fado a ele # Enable mouse scrolling and scroll bar history scrolling termcapinfo xterm* ti@:te@ talvez seja necess\u00e1rio instalar o screen. Feito isso, reinicie o target (religando a energia) para termos acesso a todo o log de inicializa\u00e7\u00e3o. notem que no meu caso o nome atribuido ao USB-UART foi o /dev/ttyUSB0 , isso pode mudar no PC de voc\u00eas Uma vez conectado, agora temos acesso a todas as funcionalidades do linux como um bash normal. Na verdade o terminal j\u00e1 \u00e9 configurado para funcionar j\u00e1 no boot, ou seja, conseguimos ter acesso as informa\u00e7\u00f5es do u-boot.","title":"UART"},{"location":"info-HPS-Serial/#kernel-e-porta-serial","text":"Como o kernel sabe qual porta ele deve utilizar para imprimir o log e usar como terminal ? Esse par\u00e2metro \u00e9 passado pelo u-boot para o kernel via o Device Tree : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-1.0\", \"snps,dw-apb-uart\"; reg = < 0xFFC02000 0x00001000 >; interrupt-parent = < &hps_0_arm_gic_0 >; interrupts = < 0 162 4 >; reg-io-width = < 4 >; reg-shift = < 2 >; clock-frequency = < 100000000 >; }; E ent\u00e3o passado com o argumento para o kernel: bootargs = \"console=ttyS0,115200\"; (esse exemplo n\u00e3o \u00e9 da nossa FPGA)","title":"Kernel e porta serial"},{"location":"info-HPS-ethernet/","text":"Ethernet \u00b6 Cyclone V Hard Processor System Technical Reference Manual https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/cyclone-v/cv_54001.pdf Linux \u00b6 Com um cabo ethernet conectado ao RJ45, precisamos configurar o Linux para utilizar essa \"porta\". No target , verifique que o linux detecta a placa de rede, com o comando ifconfig eth0 up . Alterando o MAC \u00b6 Para conectar na rede do laborat\u00f3rio de Arq. ser\u00e1 necess\u00e1rio editar o MAC da placa, caso contr\u00e1rio o mesmo n\u00e3o poder\u00e1 se conectar. Para isso, execute os comandos a seguir: $ ifconfig eth0 down $ ifconfig eth0 hw ether 02 :01:02:03:04:08 $ ifconfig eth0 up Note Ser\u00e1 necess\u00e1rio editar o MAC 02:01:02:03:04:08 para o que foi fornecido pelo professor Warning Esse MAC s\u00f3 dever\u00e1 ser utilizado no kit de desenvolvimento e durante o desenvolvimento dos projetos. O uso indevido ser\u00e1 considerado c\u00f3digo de \u00e9tica. Requisitando IP (DHCP) \u00b6 Com o MAC configurado \u00e9 necess\u00e1rio buscar um IP no servidor de DHCP, para isso utilizaremos o programa udhcpc $ udhcpc eth0 Verifique o IP com o comando ifconfig e tente pingar algum site ping google.com . Automatizando no boot \u00b6 Essas configura\u00e7\u00f5es n\u00e3o s\u00e3o persistentes, se reiniciar o linux embarcados ter\u00e1 que fazer tudo novamente. Para facilitar nossa vida, vamos executar isso no boot. RC \u00b6 J\u00e1 reparou nas pastas /etc/rc* do seu sistema operacional? \u00c9 l\u00e1 que reside grande parte dos scripts que s\u00e3o executados no boot/ reboot/ halt. Cada distribui\u00e7\u00e3o utiliza de forma diferente os scripts, por exemplo, o debian utiliza da seguinte forma: https://wiki.debian.org/BootProcess runlevel directory meaning N none System bootup (NONE). There is no /etc/rcN.d/ directory. 0 /etc/rc0.d/ Halt the system. S /etc/rcS.d/ Single-user mode on boot. The lower case s can be used as alias. 1 /etc/rc1.d/ Single-user mode switched from multi-user mode. 2 .. 5 /etc/rc{2,3,4,5}.d/ Multi-user mode. The Debian system does not pre-assign any special meaning differences among these. 6 /etc/rc6.d/ Reboot the system. 7 .. 9 /etc/rc{7,8,9}.d/ Valid multi-user mode but traditional Unix variants don\u2019t use. Their /etc/rc?.d/ directories are not populated when packages are installed. Dentro de cada pasta rc.x os scripts possuem nomes que ditam a sequ\u00eancia na qual os scripts da pasta ser\u00e3o chamados. Adicionando script ao boot (systemd) \u00b6 Crie um script com o nome S60MAC.sh na pasta /etc/init.d e adicione: ### Change mac #!/bin/bash case \" $1 \" in start ) ifconfig eth0 down ifconfig eth0 hw ether 02 :01:02:03:04:08 ifconfig eth0 up udchpc eth0 ;; * ) exit 1 ;; O script deve ser execut\u00e1vel: chmod +x S60MAC.sh Uma vez criado o script ser\u00e1 necess\u00e1rio adicionar a inicializa\u00e7\u00e3o do sistema, para isso devemos chamar (quando a iso utiliza systemd, que \u00e9 o caso do Amstrong, mas n\u00e3o do buildroot): $ systemctl enable S60MAC.sh ref: https://forums.kali.org/showthread.php?21985-How-to-make-mac-address-random-at-each-boot-up","title":"Ethernet"},{"location":"info-HPS-ethernet/#ethernet","text":"Cyclone V Hard Processor System Technical Reference Manual https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/cyclone-v/cv_54001.pdf","title":"Ethernet"},{"location":"info-HPS-ethernet/#linux","text":"Com um cabo ethernet conectado ao RJ45, precisamos configurar o Linux para utilizar essa \"porta\". No target , verifique que o linux detecta a placa de rede, com o comando ifconfig eth0 up .","title":"Linux"},{"location":"info-HPS-ethernet/#alterando-o-mac","text":"Para conectar na rede do laborat\u00f3rio de Arq. ser\u00e1 necess\u00e1rio editar o MAC da placa, caso contr\u00e1rio o mesmo n\u00e3o poder\u00e1 se conectar. Para isso, execute os comandos a seguir: $ ifconfig eth0 down $ ifconfig eth0 hw ether 02 :01:02:03:04:08 $ ifconfig eth0 up Note Ser\u00e1 necess\u00e1rio editar o MAC 02:01:02:03:04:08 para o que foi fornecido pelo professor Warning Esse MAC s\u00f3 dever\u00e1 ser utilizado no kit de desenvolvimento e durante o desenvolvimento dos projetos. O uso indevido ser\u00e1 considerado c\u00f3digo de \u00e9tica.","title":"Alterando o MAC"},{"location":"info-HPS-ethernet/#requisitando-ip-dhcp","text":"Com o MAC configurado \u00e9 necess\u00e1rio buscar um IP no servidor de DHCP, para isso utilizaremos o programa udhcpc $ udhcpc eth0 Verifique o IP com o comando ifconfig e tente pingar algum site ping google.com .","title":"Requisitando IP (DHCP)"},{"location":"info-HPS-ethernet/#automatizando-no-boot","text":"Essas configura\u00e7\u00f5es n\u00e3o s\u00e3o persistentes, se reiniciar o linux embarcados ter\u00e1 que fazer tudo novamente. Para facilitar nossa vida, vamos executar isso no boot.","title":"Automatizando no boot"},{"location":"info-HPS-ethernet/#rc","text":"J\u00e1 reparou nas pastas /etc/rc* do seu sistema operacional? \u00c9 l\u00e1 que reside grande parte dos scripts que s\u00e3o executados no boot/ reboot/ halt. Cada distribui\u00e7\u00e3o utiliza de forma diferente os scripts, por exemplo, o debian utiliza da seguinte forma: https://wiki.debian.org/BootProcess runlevel directory meaning N none System bootup (NONE). There is no /etc/rcN.d/ directory. 0 /etc/rc0.d/ Halt the system. S /etc/rcS.d/ Single-user mode on boot. The lower case s can be used as alias. 1 /etc/rc1.d/ Single-user mode switched from multi-user mode. 2 .. 5 /etc/rc{2,3,4,5}.d/ Multi-user mode. The Debian system does not pre-assign any special meaning differences among these. 6 /etc/rc6.d/ Reboot the system. 7 .. 9 /etc/rc{7,8,9}.d/ Valid multi-user mode but traditional Unix variants don\u2019t use. Their /etc/rc?.d/ directories are not populated when packages are installed. Dentro de cada pasta rc.x os scripts possuem nomes que ditam a sequ\u00eancia na qual os scripts da pasta ser\u00e3o chamados.","title":"RC"},{"location":"info-HPS-ethernet/#adicionando-script-ao-boot-systemd","text":"Crie um script com o nome S60MAC.sh na pasta /etc/init.d e adicione: ### Change mac #!/bin/bash case \" $1 \" in start ) ifconfig eth0 down ifconfig eth0 hw ether 02 :01:02:03:04:08 ifconfig eth0 up udchpc eth0 ;; * ) exit 1 ;; O script deve ser execut\u00e1vel: chmod +x S60MAC.sh Uma vez criado o script ser\u00e1 necess\u00e1rio adicionar a inicializa\u00e7\u00e3o do sistema, para isso devemos chamar (quando a iso utiliza systemd, que \u00e9 o caso do Amstrong, mas n\u00e3o do buildroot): $ systemctl enable S60MAC.sh ref: https://forums.kali.org/showthread.php?21985-How-to-make-mac-address-random-at-each-boot-up","title":"Adicionando script ao boot (systemd)"},{"location":"info-SDcard/","text":"Atualizando o SDCARD \u00b6 Premissas Atualizando o preload \u00b6 TBD Atualizando o uboot \u00b6 TBD uboot script \u00b6 $ cp u-boot.scr /run/media/corsi/B0DA-B234/ Atualizando Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. Atualizando o dts \u00b6 $ cp socfpga.dtb /run/media/corsi/B0DA-B234/ FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6","title":"Atualizando o SDCARD"},{"location":"info-SDcard/#atualizando-o-sdcard","text":"Premissas","title":"Atualizando o SDCARD"},{"location":"info-SDcard/#atualizando-o-preload","text":"TBD","title":"Atualizando o preload"},{"location":"info-SDcard/#atualizando-o-uboot","text":"TBD","title":"Atualizando o uboot"},{"location":"info-SDcard/#uboot-script","text":"$ cp u-boot.scr /run/media/corsi/B0DA-B234/","title":"uboot script"},{"location":"info-SDcard/#atualizando-kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Atualizando Kernel"},{"location":"info-SDcard/#atualizando-o-dts","text":"$ cp socfpga.dtb /run/media/corsi/B0DA-B234/","title":"Atualizando o dts"},{"location":"info-SDcard/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"info-SDcard/#uboot-script-e-device-tree","text":"","title":"uboot script e device tree"},{"location":"info-VHDL/","text":"VHDL \u00b6 Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"},{"location":"info-VHDL/#vhdl","text":"Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"},{"location":"2019/Elisa-Yocto/","text":"Elisa Malzoni - Yocto \u00b6 Aluna: Elisa Monteiro Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/elisamalzoni/Embarcados-Avancados Ano: 2019 Hardware utilizado no tutorial DE10-Standard Raspberry 3 O que \u00e9 o Yocto Project \u00b6 Projeto open source para cria\u00e7\u00e3o de sistemas customizados baseados em Linux, para embarcados, independentemente da arquiterura do hardware. Layer Model \u00b6 S\u00e3o reposit\u00f3rios que cont\u00e9m os conjuntos de instru\u00e7\u00f5es que s\u00e3o mandadas para o OpenEmbedded build system. Voc\u00ea pode modificar, compartilhar e reusar as layers . Essas layers podem conter mudan\u00e7as nas instru\u00e7\u00f5es ou configura\u00e7\u00f5es anteriores ou novas intru\u00e7\u00f5es e configura\u00e7\u00f5es. Separar as camadas dependendo das suas informa\u00e7\u00f5es pode aumentar a personaliza\u00e7\u00e3oe facilitar a reutiliza\u00e7\u00e3o das camadas. ex.: camadas de BSP, GUI, configura\u00e7\u00e3o da distro, middleware ou at\u00e9 a camada da aplica\u00e7\u00e3o. Layers geralmente tem nomes que come\u00e7am com meta- . BitBake \u00b6 Derivado do OpenEmbedded build system, \u00e9 utilizado para gerar as imagens. Poky \u00b6 \u00c9 a distribui\u00e7\u00e3o refer\u00eancia do Yocto e ser\u00e1 tamb\u00e9m utilizada na demonstra\u00e7\u00e3o. J\u00e1 vem com um conjunto de metadados, para come\u00e7ar a contru\u00e7\u00e3o da sua pr\u00f3pria distro. Poky \u00e9 a combina\u00e7\u00e3o dos reposit\u00f3rios do BitBake, OpenEmbedded-Core (dentro do meta ), meta-poky , meta-yocto-bsp , tamb\u00e9m a documenta\u00e7\u00e3o. BitBake agenda e executa as tarefas. Principal componente do OpenEmbedded build system. meta-poky metadados espec\u00edficos do poky. meta-yocto-bsp Board Support Packages (BSPs). OpenEmbedded-Core (OE-Core) metadata metadados de configura\u00e7\u00f5es compartilhadas, defini\u00e7\u00e3o de vari\u00e1veis globais, classes compartilhadas, pacotes, e recipes . Classes definem o encapsulamento e as heran\u00e7as da l\u00f3gica de build. Recipes s\u00e3o as unidades l\u00f3gicas de software e de imagens para buildar. Documenta\u00e7\u00e3o cont\u00e9m o c\u00f3digo fonte utilizado para gerar os manuais de usu\u00e1rio do Yocto Project. Uma Recipe \u00e9 uma cole\u00e7\u00e3o de metadados n\u00e3o execut\u00e1veis usada pelo BitBake para definir var\u00e1veis ou tarefas no tempo de build. Uma Recipe pode conter: Descri\u00e7\u00e3o da recipe vers\u00e3o licen\u00e7a do pacote reposit\u00f3rio de origem indicar os processos de build adi\u00e7\u00e3o de tarefas ou prerequisitos das tarefas Buildroot vs Yocto \u00b6 Tanto Yocto quanto Buildroot no final ter\u00e3o: root filesystem, para seu sitema embarcado kernel bootloader e uma toolchain compat\u00edvel O buildroot foca em simplicidade. Seu n\u00facleo \u00e9 mantido o qu\u00e3o simples e pequeno for poss\u00edvel, fazendo com que seja f\u00e1cil seu uso e compreens\u00e3o. Enquanto o Yocto tenta ser vers\u00e1til e suporta uma grande variedade de sistemas embarcados. O Buildroot gera somente a imagem do sistema de arquivos. Assim quando um sistema precisar se atualizado a imagem inteira deve ser gerada novamente. J\u00e1 a sa\u00edda do Yocto \u00e9 uma distribui\u00e7\u00e3o, onde pode exitir um sistema de gerenciamento de pacotes no qual pacotes podem ser atualizados individualmente, ou at\u00e9 mesmo serem removidas. No Yocto \u00e9 mais f\u00e1cil gerar altera\u00e7\u00f5es com mequenas mudan\u00e7as e sua escalabilidade tamb\u00e9m \u00e9 maior. Enquanto o Buildroot tenta se manter simples a curva de aprendizado do Yocto \u00e9 um pouco mais desafiadora e sua terminologia \u00e9 masi complicada. O conjunto de pacotes suportados pelo Buildroot \u00e9 menor. Tamb\u00e9m n\u00e3o possui mecanismo para detectar mudan\u00e7as entre builds. Compilando uma iso \u00b6 Warning Mesmo seguindo os tutoriais do Yocto e guias da altera, n\u00e3o consegui compilar para a placa usada no curso, assim utilizarei um Raspberry Pi 3 Model B. Links uteis \u00b6 Reference Manual Yocto Overview manual Deciding between Buildroot & Yocto Yocto e Raspberry Pi 3 Prepara\u00e7\u00e3o do host \u00b6 Voc\u00ea deve ter: 20 gbytes livres no disco Usar uma das vers\u00f5es recentes dos seguintes sistemas: Fedora, openSUSE, CentOS, Debian ou Ubuntu git 1.8.3.1 ou maior tar 1.27 ou maior python 3.4 ou maior Para instalar os pacotes essenciais no host rode o comando abaixo, se voc\u00ea usar uma distribui\u00e7\u00e3o ubuntu. $ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm Clone o Yocto $ git clone -b thud http://git.yoctoproject.org/git/poky yocto $ git clone -b thud git://git.openembedded.org/meta-openembedded yocto/meta-openembedded Clone a layer do Angstrom $ git clone -b angstrom-v2018.12-thud git://github.com/Angstrom-distribution/meta-angstrom.git yocto/meta-angstrom Clone a layer do Raspberry Pi $ git clone -b thud git://git.yoctoproject.org/meta-raspberrypi yocto/meta-raspberrypi Clone a layer do Qt 5 $ git clone -b thud https://github.com/meta-qt5/meta-qt5.git yocto/meta-qt5 Iniciando o sistema de desenvolvimento. Isso precisa ser feito sempre que abrir um novo terminal $ cd yocto $ source oe-init-build-env Precisamos agora incluir as layers clonadas acima. Modifique o arquivo /yocto/build/conf/bblayers.conf para isso: # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf # changes incompatibly POKY_BBLAYERS_CONF_VERSION = \"2\" BBPATH = \"${TOPDIR}\" BBFILES ?= \"\" BBLAYERS ?= \" \\ ${TOPDIR}/../meta \\ ${TOPDIR}/../meta-angstrom \\ ${TOPDIR}/../meta-poky \\ ${TOPDIR}/../meta-yocto-bsp \\ ${TOPDIR}/../meta-raspberrypi \\ ${TOPDIR}/../meta-qt5 \\ ${TOPDIR}/../meta-openembedded/meta-multimedia \\ ${TOPDIR}/../meta-openembedded/meta-networking \\ ${TOPDIR}/../meta-openembedded/meta-oe \\ ${TOPDIR}/../meta-openembedded/meta-python \\ ${TOPDIR}/../meta-openembedded/meta-webserver \\ \" No arquivo yocto/build/conf/local.conf adicione as seguintes linhas: MACHINE ??= \"raspberrypi3\" DISTRO ?= \"angstrom\" RPI_USE_U_BOOT = \"1\" Compilando \u00b6 $ bitbake core-image-base Voc\u00ea dever\u00e1 ter a seguinte sa\u00edda: Build Configuration: BB_VERSION = \"1.40.0\" BUILD_SYS = \"x86_64-linux\" NATIVELSBSTRING = \"ubuntu-18.04\" TARGET_SYS = \"arm-angstrom-linux-gnueabi\" MACHINE = \"raspberrypi3\" DISTRO = \"angstrom\" DISTRO_VERSION = \"v2018.12\" TUNE_FEATURES = \"arm armv7a vfp thumb neon callconvention-hard\" TARGET_FPU = \"hard\" meta = \"thud:8cd3ee6e1a50ad9f40466bcadb236c619c42ef19\" meta-angstrom = \"angstrom-v2018.12-thud:fdf4ca41ba6d455a906465a4d2f0d71dbb70224c\" meta-poky meta-yocto-bsp = \"thud:8cd3ee6e1a50ad9f40466bcadb236c619c42ef19\" meta-raspberrypi = \"thud:4e5be97d75668804694412f9b86e9291edb38b9d\" meta-qt5 = \"thud:1520d5b2b2beec5e1c3209d3178219e93ef08bca\" meta-multimedia meta-networking meta-oe meta-python meta-webserver = \"thud:446bd615fd7cb9bc7a159fe5c2019ed08d1a7a93\" Depois de compilado procure um desses arquivos e transfira a imagem para o arquivo. Eu utilizei o etcher para isso. /yocto/build/tmp-glibc/deploy/images/raspberrypi3/Angstrom-core-image-base-glibc-ipk-v2018.12-raspberrypi3.rootfs.rpi-sdimg /yocto/deploy/images/raspberrypi3/Angstrom-core-image-base-glibc-ipk-v2018.12-raspberrypi3.rootfs.rpi-sdimg At\u00e9 onde cheguei com a cyclone5? \u00b6 Clone o reposit\u00f3rio do Poky $ git clone git://git.yoctoproject.org/poky Cria\u00e7\u00e3o da Imagem \u00b6 Primeiro precisamos inicializar o ambiente de desenvolvimento: $ cd poky $ source oe-init-build-env Clone a layer da altera da seguinte maneira: $ cd poky $ git clone https://github.com/kraj/meta-altera.git Mude a vari\u00e1vel MACHINE para \"cyclone5\" no arquivo de configura\u00e7\u00e3o local.conf Adicione uma layer ao arquivo de configura\u00e7\u00e3o de layers: $ cd ~/poky/build $ bitbake-layers add-layer ../meta-altera Mas nao consegui nem compilar usando BitBake.","title":"Elisa Malzoni - Yocto"},{"location":"2019/Elisa-Yocto/#elisa-malzoni-yocto","text":"Aluna: Elisa Monteiro Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/elisamalzoni/Embarcados-Avancados Ano: 2019 Hardware utilizado no tutorial DE10-Standard Raspberry 3","title":"Elisa Malzoni - Yocto"},{"location":"2019/Elisa-Yocto/#o-que-e-o-yocto-project","text":"Projeto open source para cria\u00e7\u00e3o de sistemas customizados baseados em Linux, para embarcados, independentemente da arquiterura do hardware.","title":"O que \u00e9 o Yocto Project"},{"location":"2019/Elisa-Yocto/#layer-model","text":"S\u00e3o reposit\u00f3rios que cont\u00e9m os conjuntos de instru\u00e7\u00f5es que s\u00e3o mandadas para o OpenEmbedded build system. Voc\u00ea pode modificar, compartilhar e reusar as layers . Essas layers podem conter mudan\u00e7as nas instru\u00e7\u00f5es ou configura\u00e7\u00f5es anteriores ou novas intru\u00e7\u00f5es e configura\u00e7\u00f5es. Separar as camadas dependendo das suas informa\u00e7\u00f5es pode aumentar a personaliza\u00e7\u00e3oe facilitar a reutiliza\u00e7\u00e3o das camadas. ex.: camadas de BSP, GUI, configura\u00e7\u00e3o da distro, middleware ou at\u00e9 a camada da aplica\u00e7\u00e3o. Layers geralmente tem nomes que come\u00e7am com meta- .","title":"Layer Model"},{"location":"2019/Elisa-Yocto/#bitbake","text":"Derivado do OpenEmbedded build system, \u00e9 utilizado para gerar as imagens.","title":"BitBake"},{"location":"2019/Elisa-Yocto/#poky","text":"\u00c9 a distribui\u00e7\u00e3o refer\u00eancia do Yocto e ser\u00e1 tamb\u00e9m utilizada na demonstra\u00e7\u00e3o. J\u00e1 vem com um conjunto de metadados, para come\u00e7ar a contru\u00e7\u00e3o da sua pr\u00f3pria distro. Poky \u00e9 a combina\u00e7\u00e3o dos reposit\u00f3rios do BitBake, OpenEmbedded-Core (dentro do meta ), meta-poky , meta-yocto-bsp , tamb\u00e9m a documenta\u00e7\u00e3o. BitBake agenda e executa as tarefas. Principal componente do OpenEmbedded build system. meta-poky metadados espec\u00edficos do poky. meta-yocto-bsp Board Support Packages (BSPs). OpenEmbedded-Core (OE-Core) metadata metadados de configura\u00e7\u00f5es compartilhadas, defini\u00e7\u00e3o de vari\u00e1veis globais, classes compartilhadas, pacotes, e recipes . Classes definem o encapsulamento e as heran\u00e7as da l\u00f3gica de build. Recipes s\u00e3o as unidades l\u00f3gicas de software e de imagens para buildar. Documenta\u00e7\u00e3o cont\u00e9m o c\u00f3digo fonte utilizado para gerar os manuais de usu\u00e1rio do Yocto Project. Uma Recipe \u00e9 uma cole\u00e7\u00e3o de metadados n\u00e3o execut\u00e1veis usada pelo BitBake para definir var\u00e1veis ou tarefas no tempo de build. Uma Recipe pode conter: Descri\u00e7\u00e3o da recipe vers\u00e3o licen\u00e7a do pacote reposit\u00f3rio de origem indicar os processos de build adi\u00e7\u00e3o de tarefas ou prerequisitos das tarefas","title":"Poky"},{"location":"2019/Elisa-Yocto/#buildroot-vs-yocto","text":"Tanto Yocto quanto Buildroot no final ter\u00e3o: root filesystem, para seu sitema embarcado kernel bootloader e uma toolchain compat\u00edvel O buildroot foca em simplicidade. Seu n\u00facleo \u00e9 mantido o qu\u00e3o simples e pequeno for poss\u00edvel, fazendo com que seja f\u00e1cil seu uso e compreens\u00e3o. Enquanto o Yocto tenta ser vers\u00e1til e suporta uma grande variedade de sistemas embarcados. O Buildroot gera somente a imagem do sistema de arquivos. Assim quando um sistema precisar se atualizado a imagem inteira deve ser gerada novamente. J\u00e1 a sa\u00edda do Yocto \u00e9 uma distribui\u00e7\u00e3o, onde pode exitir um sistema de gerenciamento de pacotes no qual pacotes podem ser atualizados individualmente, ou at\u00e9 mesmo serem removidas. No Yocto \u00e9 mais f\u00e1cil gerar altera\u00e7\u00f5es com mequenas mudan\u00e7as e sua escalabilidade tamb\u00e9m \u00e9 maior. Enquanto o Buildroot tenta se manter simples a curva de aprendizado do Yocto \u00e9 um pouco mais desafiadora e sua terminologia \u00e9 masi complicada. O conjunto de pacotes suportados pelo Buildroot \u00e9 menor. Tamb\u00e9m n\u00e3o possui mecanismo para detectar mudan\u00e7as entre builds.","title":"Buildroot vs Yocto"},{"location":"2019/Elisa-Yocto/#compilando-uma-iso","text":"Warning Mesmo seguindo os tutoriais do Yocto e guias da altera, n\u00e3o consegui compilar para a placa usada no curso, assim utilizarei um Raspberry Pi 3 Model B.","title":"Compilando uma iso"},{"location":"2019/Elisa-Yocto/#links-uteis","text":"Reference Manual Yocto Overview manual Deciding between Buildroot & Yocto Yocto e Raspberry Pi 3","title":"Links uteis"},{"location":"2019/Elisa-Yocto/#preparacao-do-host","text":"Voc\u00ea deve ter: 20 gbytes livres no disco Usar uma das vers\u00f5es recentes dos seguintes sistemas: Fedora, openSUSE, CentOS, Debian ou Ubuntu git 1.8.3.1 ou maior tar 1.27 ou maior python 3.4 ou maior Para instalar os pacotes essenciais no host rode o comando abaixo, se voc\u00ea usar uma distribui\u00e7\u00e3o ubuntu. $ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm Clone o Yocto $ git clone -b thud http://git.yoctoproject.org/git/poky yocto $ git clone -b thud git://git.openembedded.org/meta-openembedded yocto/meta-openembedded Clone a layer do Angstrom $ git clone -b angstrom-v2018.12-thud git://github.com/Angstrom-distribution/meta-angstrom.git yocto/meta-angstrom Clone a layer do Raspberry Pi $ git clone -b thud git://git.yoctoproject.org/meta-raspberrypi yocto/meta-raspberrypi Clone a layer do Qt 5 $ git clone -b thud https://github.com/meta-qt5/meta-qt5.git yocto/meta-qt5 Iniciando o sistema de desenvolvimento. Isso precisa ser feito sempre que abrir um novo terminal $ cd yocto $ source oe-init-build-env Precisamos agora incluir as layers clonadas acima. Modifique o arquivo /yocto/build/conf/bblayers.conf para isso: # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf # changes incompatibly POKY_BBLAYERS_CONF_VERSION = \"2\" BBPATH = \"${TOPDIR}\" BBFILES ?= \"\" BBLAYERS ?= \" \\ ${TOPDIR}/../meta \\ ${TOPDIR}/../meta-angstrom \\ ${TOPDIR}/../meta-poky \\ ${TOPDIR}/../meta-yocto-bsp \\ ${TOPDIR}/../meta-raspberrypi \\ ${TOPDIR}/../meta-qt5 \\ ${TOPDIR}/../meta-openembedded/meta-multimedia \\ ${TOPDIR}/../meta-openembedded/meta-networking \\ ${TOPDIR}/../meta-openembedded/meta-oe \\ ${TOPDIR}/../meta-openembedded/meta-python \\ ${TOPDIR}/../meta-openembedded/meta-webserver \\ \" No arquivo yocto/build/conf/local.conf adicione as seguintes linhas: MACHINE ??= \"raspberrypi3\" DISTRO ?= \"angstrom\" RPI_USE_U_BOOT = \"1\"","title":"Prepara\u00e7\u00e3o do host"},{"location":"2019/Elisa-Yocto/#compilando","text":"$ bitbake core-image-base Voc\u00ea dever\u00e1 ter a seguinte sa\u00edda: Build Configuration: BB_VERSION = \"1.40.0\" BUILD_SYS = \"x86_64-linux\" NATIVELSBSTRING = \"ubuntu-18.04\" TARGET_SYS = \"arm-angstrom-linux-gnueabi\" MACHINE = \"raspberrypi3\" DISTRO = \"angstrom\" DISTRO_VERSION = \"v2018.12\" TUNE_FEATURES = \"arm armv7a vfp thumb neon callconvention-hard\" TARGET_FPU = \"hard\" meta = \"thud:8cd3ee6e1a50ad9f40466bcadb236c619c42ef19\" meta-angstrom = \"angstrom-v2018.12-thud:fdf4ca41ba6d455a906465a4d2f0d71dbb70224c\" meta-poky meta-yocto-bsp = \"thud:8cd3ee6e1a50ad9f40466bcadb236c619c42ef19\" meta-raspberrypi = \"thud:4e5be97d75668804694412f9b86e9291edb38b9d\" meta-qt5 = \"thud:1520d5b2b2beec5e1c3209d3178219e93ef08bca\" meta-multimedia meta-networking meta-oe meta-python meta-webserver = \"thud:446bd615fd7cb9bc7a159fe5c2019ed08d1a7a93\" Depois de compilado procure um desses arquivos e transfira a imagem para o arquivo. Eu utilizei o etcher para isso. /yocto/build/tmp-glibc/deploy/images/raspberrypi3/Angstrom-core-image-base-glibc-ipk-v2018.12-raspberrypi3.rootfs.rpi-sdimg /yocto/deploy/images/raspberrypi3/Angstrom-core-image-base-glibc-ipk-v2018.12-raspberrypi3.rootfs.rpi-sdimg","title":"Compilando"},{"location":"2019/Elisa-Yocto/#ate-onde-cheguei-com-a-cyclone5","text":"Clone o reposit\u00f3rio do Poky $ git clone git://git.yoctoproject.org/poky","title":"At\u00e9 onde cheguei com a cyclone5?"},{"location":"2019/Elisa-Yocto/#criacao-da-imagem","text":"Primeiro precisamos inicializar o ambiente de desenvolvimento: $ cd poky $ source oe-init-build-env Clone a layer da altera da seguinte maneira: $ cd poky $ git clone https://github.com/kraj/meta-altera.git Mude a vari\u00e1vel MACHINE para \"cyclone5\" no arquivo de configura\u00e7\u00e3o local.conf Adicione uma layer ao arquivo de configura\u00e7\u00e3o de layers: $ cd ~/poky/build $ bitbake-layers add-layer ../meta-altera Mas nao consegui nem compilar usando BitBake.","title":"Cria\u00e7\u00e3o da Imagem"},{"location":"2019/Gabriel-TensorFlow/","text":"Gabriel Moreira - TensorFlow \u00b6 Aluno: Gabriel Moreira Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/gabsmoreira/speech_recognition Ano: 2019 Hardware utilizado no tutorial Jetson Nano JetBot O objetivo do tutorial \u00e9 implementar um simples sistema de reconhecimento de comandos por voz com alguns ajustes em uma placa da NVIDIA Jetson Nano. Tal placa possui uma GPU incluida, o que a torna ideal para executar programas que fazem uso de redes neurais. Configurando Jetson Nano \u00b6 ISO \u00b6 Antes de tudo, precisamos preparar a placa Jetson Nano para a prototipa\u00e7\u00e3o. Para isso, \u00e9 necess\u00e1rio fazer o download da imagem do sistema operacional oferecido pela pr\u00f3pria NVIDIA. Fa\u00e7a o download da imagem nesse link: https://developer.nvidia.com/jetson-nano-sd-card-image-r3223 Em seguida, fa\u00e7a o download do programa que escreve a imagem no cart\u00e3o SD, chamado Etcher. Isso facilitar\u00e1 muito o desenvolvimento. Link do Etcher: https://www.balena.io/etcher Instale o Etcher e execute-o. A seguinte tela ir\u00e1 aparecer. Selecione a imagem e o disco corretamente e clique em Flash! Isso pode levar de 10-15 minutos para ser feito. V\u00e1 tomar um caf\u00e9! \u2615 Assim que o processo for conclu\u00eddo, remova o cart\u00e3o do computador e coloque na placa. Conectar o hardware \u00b6 Antes de tudo, conecte a placa Jetson em um monitor usando a sa\u00edda HDMI. Conecte tamb\u00e9m o mouse, teclado e o cabo Ethernet. Est\u00e1 na hora de completar os passos para a configura\u00e7\u00e3o do sistema operacional. Isso requer a escolha de um usu\u00e1rio, senha e mais algumas configura\u00e7\u00f5es que n\u00e3o s\u00e3o relevantes para o projeto. Conecte agora o microfone na placa usando um adaptador USB. Para verificar se o microfone foi devidamente reconhecido pelo sistema operacional execute o comando dmesg . $ sudo dmesg | tail -n10 Atualizando e instalando depend\u00eancias \u00b6 No linux da Jetson Nano, executar: Update de libs e packages: $ sudo apt update $ sudo apt upgrade Instalar Pip3: $ sudo apt install python3-pip $ sudo pip3 install -U pip Instalar depend\u00eancias do TensorFlow: $ sudo apt install libhdf5-serial-dev hdf5-tools libhdf5-dev zlib1g-dev zip libjpeg8-dev $ sudo pip3 install -U numpy == 1 .16.1 future == 0 .17.1 mock == 3 .0.5 h5py == 2 .9.0 keras_preprocessing == 1 .0.5 keras_applications == 1 .0.6 enum34 futures testresources setuptools protobuf Instalar Tensorflow: $ sudo pip3 install --pre --extra-index-url https://developer.download.nvidia.com/compute/redist/jp/v42 tensorflow-gpu $ sudo pip3 install -U pip Testando \u00b6 Testar instala\u00e7\u00e3o do TensorFlow: $ python3 >>> import tensorflow as tf O comando acima deve executar sem nenhum erro se o TensorFlow tiver sido instalado corretamente. Download do exemplo do TensorFlow \u00b6 O TensorFlow possui um exemplo em seu reposit\u00f3rio de utiliza\u00e7\u00e3o de redes neurais para reconhecimento de comandos por voz. Nesse tutorial, utilizaremos esse mesmo exemplo com algumas adapta\u00e7\u00f5es, uma vez que o modelo fornecido recebe como input um arquivo de \u00e1udio .wav . Nosso objetivo \u00e9 criar um programa que recebe um stream de \u00e1udio que deve ser processado continuamente, assim como \u00e9 visto em assistentes de voz (Google e Siri). O primeiro passo \u00e9 clonar o reposit\u00f3rio raiz do TensorFlow. $ git clone https://github.com/tensorflow/tensorflow.git Esse comando pode demorar um pouco para ser executado, uma vez que o reposit\u00f3rio \u00e9 grande. V\u00e1 tomar um caf\u00e9! \u2615 V\u00e1 at\u00e9 a pasta do exemplo que queremos executar. $ cd tensorflow/tensorflow/examples/speech_commands/ Note que na pasta existem diversos arquivos, os principais s\u00e3o: train.py : utilizado para treinar o modelo. freeze.py : utilizado para compilar o modelo treinado. label_wav.py : utilizado para reconhecer um comando, dado um arquivo .wav de input e um modelo previamente treinado O segundo passo \u00e9 treinar a rede neural para que fique com uma boa acur\u00e1cia e consiga processar os nossos comandos de voz. Para isso execute o script train.py com os seguintes par\u00e2metros. $ python3 train.py Para que o modelo fique aceit\u00e1vel, \u00e9 necess\u00e1rio deixar pelo menos 8 horas treinando. Caso voc\u00ea n\u00e3o tenha esse tempo, o link para o modelo treinado (e compilado) est\u00e1 aqui: https://github.com/gabsmoreira/speech_recognition/raw/master/my_frozen_graph.pb A placa Jetson n\u00e3o foi projetada para treinar redes neurais, o ideal seria fazer isso em um computador mais potente e depois transferir o arquivo contento os pesos da rede neural via SCP . Com o modelo treinado, agora compile usando o checkpoint que quiser: $ python3 freeze.py --start_checkpoint = conv.ckpt-12000 --output_file = my_frozen_graph.pb Agora teste o modelo treinado. Para isso, \u00e9 necess\u00e1rio ter o path das labels do modelo (que normalmente est\u00e1 localizado no /tmp/speech_commands_train/conv_labels.txt ) $ python3 label_wav.py --graph = my_frozen_graph.pb --labels ={ PATH DAS LABELS } --wav ={ PATH DO WAV FILE } Modificando o script \u00b6 O primeiro passo \u00e9 criar um pequeno exemplo de captura e processamento de stream de \u00e1udio usando o pyaudio . Antes de criar o novo arquivo, instale a biblioteca acima. $ pip3 install pyaudio Crie um arquivo com o nome audio_stream.py e coloque o seguinte c\u00f3digo: from __future__ import absolute_import from __future__ import division from __future__ import print_function import argparse import sys import pyaudio import numpy as np import audioop import wave import tensorflow as tf import time FLAGS = None CHUNK = 4096 # number of data points to read at a time RATE = 16000 # time resolution of the recording device (Hz) CHANNELS = 1 # number of channels FORMAT = pyaudio . paInt16 # audio format from pyaudio p = pyaudio . PyAudio () # start the PyAudio class devinfo = p . get_device_info_by_index ( 0 ) # get the first recorder device # stream from pyaudio stream = p . open ( format = FORMAT , channels = CHANNELS , rate = RATE , input = True , frames_per_buffer = CHUNK ) while True : # transform data into a numpy array data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) # get audio rms rms = audioop . rms ( data , 2 ) # if audio rms reaches 900 or more set recording for true # and start appending the data into the frames array. # this means someone is talking if rms > 900 : if recording == False : recording = True frames . append ( data ) else : if recording == True : time_from_previous = time . time () # get data from stream for the next 0.5 seconds # after the volume while time . time () - time_from_previous < 0.5 : data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) frames . append ( data ) # write frames inside wav file _file = wave . open ( \"out.wav\" , \"wb\" ) _file . setnchannels ( CHANNELS ) _file . setsampwidth ( p . get_sample_size ( FORMAT )) _file . setframerate ( RATE ) _file . writeframes ( b '' . join ( frames )) _file . close () # clear frames array since the data was # written inside wav file frames = [] recording = False A ideia \u00e9 criar um stream que comeca a gravar os dados do \u00e1udio em uma array assim que o \"volume\" do \u00e1udio passa de 900 (isso pode depender do microfone usado) e para depois de 0.5 segundos assim que o audio volta a ficar com um valor menor que 900. Tal array \u00e9 escrita em um arquivo .wav constantemente. Com esse c\u00f3digo, transformamos um stream de \u00e1udio em diversos .wav que agora podem ser usados no modelo treinado. O que falta ent\u00e3o \u00e9 unir esse c\u00f3digo do stream de \u00e1udio com a predi\u00e7\u00e3o do modelo. C\u00f3digo fonte, python from __future__ import absolute_import from __future__ import division from __future__ import print_function import argparse import sys import pyaudio import numpy as np import audioop import wave import tensorflow as tf import time FLAGS = None CHUNK = 4096 # number of data points to read at a time RATE = 16000 # time resolution of the recording device (Hz) CHANNELS = 1 # number of channels FORMAT = pyaudio . paInt16 # audio format from pyaudio p = pyaudio . PyAudio () # start the PyAudio class devinfo = p . get_device_info_by_index ( 0 ) # get the first recorder device # stream from pyaudio stream = p . open ( format = FORMAT , channels = CHANNELS , rate = RATE , input = True , frames_per_buffer = CHUNK ) def load_graph ( filename ): \"\"\"Unpersists graph from file as default graph.\"\"\" with tf . io . gfile . GFile ( filename , 'rb' ) as f : graph_def = tf . compat . v1 . GraphDef () graph_def . ParseFromString ( f . read ()) tf . import_graph_def ( graph_def , name = '' ) def load_labels ( filename ): \"\"\"Read in labels, one label per line.\"\"\" return [ line . rstrip () for line in tf . io . gfile . GFile ( filename )] def run_graph ( wav_data , labels , input_layer_name , output_layer_name , num_top_predictions ): \"\"\"Runs the audio data through the graph and prints predictions.\"\"\" with tf . compat . v1 . Session () as sess : # Feed the audio data as input to the graph. # predictions will contain a two-dimensional array, where one # dimension represents the input image count, and the other has # predictions per class softmax_tensor = sess . graph . get_tensor_by_name ( output_layer_name ) predictions , = sess . run ( softmax_tensor , { input_layer_name : wav_data }) # Sort to show labels in order of confidence top_k = predictions . argsort ()[ - num_top_predictions :][:: - 1 ] for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] print ( ' %s (score = %.5f )' % ( human_string , score )) return 0 def label_wav ( wav , labels , graph , input_name , output_name , how_many_labels ): \"\"\"Loads the model and labels, and runs the inference to print predictions.\"\"\" if not wav or not tf . io . gfile . exists ( wav ): tf . compat . v1 . logging . fatal ( 'Audio file does not exist %s ' , wav ) if not labels or not tf . io . gfile . exists ( labels ): tf . compat . v1 . logging . fatal ( 'Labels file does not exist %s ' , labels ) if not graph or not tf . io . gfile . exists ( graph ): tf . compat . v1 . logging . fatal ( 'Graph file does not exist %s ' , graph ) labels_list = load_labels ( labels ) # load graph, which is stored in the default session load_graph ( graph ) with open ( wav , 'rb' ) as wav_file : wav_data = wav_file . read () run_graph ( wav_data , labels_list , input_name , output_name , how_many_labels ) def prepare ( graph , labels ): \"\"\"Loads data labels and tensor graphs\"\"\" labels_list = load_labels ( labels ) load_graph ( graph ) return labels_list def main ( _ ): # initialize variables and prepare graph labels = prepare ( FLAGS . graph , FLAGS . labels ) recording = False frames = [] time_from_previous = 0 with tf . compat . v1 . Session () as sess : # loads softmax tensor softmax_tensor = sess . graph . get_tensor_by_name ( FLAGS . output_name ) while True : # transform data into a numpy array data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) # get audio rms rms = audioop . rms ( data , 2 ) # if audio rms reaches 900 or more set recording for true # and start appending the data into the frames array. # this means someone is talking if rms > 900 : if recording == False : recording = True frames . append ( data ) else : if recording == True : time_from_previous = time . time () # get data from stream for the next 0.5 seconds # after the volume while time . time () - time_from_previous < 0.5 : data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) frames . append ( data ) # write frames inside wav file _file = wave . open ( \"out.wav\" , \"wb\" ) _file . setnchannels ( CHANNELS ) _file . setsampwidth ( p . get_sample_size ( FORMAT )) _file . setframerate ( RATE ) _file . writeframes ( b '' . join ( frames )) _file . close () # clear frames array since the data was # written inside wav file frames = [] # read wav file to get the input data for # our neural network with open ( 'out.wav' , 'rb' ) as wav_file : wav_data = wav_file . read () # this is where the model predicts based on the input data predictions , = sess . run ( softmax_tensor , { FLAGS . input_name : wav_data }) # Sort to show labels in order of confidence top_k = predictions . argsort ()[ - FLAGS . how_many_labels :][:: - 1 ] for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] print ( ' %s (score = %.5f )' % ( human_string , score )) recording = False if __name__ == '__main__' : parser = argparse . ArgumentParser () parser . add_argument ( '--wav' , type = str , default = '' , help = 'Audio file to be identified.' ) parser . add_argument ( '--graph' , type = str , default = '' , help = 'Model to use for identification.' ) parser . add_argument ( '--labels' , type = str , default = '' , help = 'Path to file containing labels.' ) parser . add_argument ( '--input_name' , type = str , default = 'wav_data:0' , help = 'Name of WAVE data input node in model.' ) parser . add_argument ( '--output_name' , type = str , default = 'labels_softmax:0' , help = 'Name of node outputting a prediction in the model.' ) parser . add_argument ( '--how_many_labels' , type = int , default = 1 , help = 'Number of results to show.' ) FLAGS , unparsed = parser . parse_known_args () tf . compat . v1 . app . run ( main = main , argv = [ sys . argv [ 0 ]] + unparsed ) Agora para testar o script, basta executar o arquivo python. $ python3 audio_stream.py Veja o v\u00eddeo da demonstra\u00e7\u00e3o Extra - controle do JetBot por comando de voz \u00b6 Para fazer essa parte do tutorial, \u00e9 necess\u00e1rio ter o mesmo material/recursos propostos no link do JetBot. Link do tutorial do JetBot: https://github.com/NVIDIA-AI-IOT/jetbot/wiki/bill-of-materials Para montar a parte de hardware, basta seguir esse tutorial: https://github.com/NVIDIA-AI-IOT/jetbot/wiki/Hardware-Setup A parte de software j\u00e1 temos, basta instalar s\u00f3 mais alguns pacotes. Intalar bibliotecas adicionais \u00b6 $ cd $ wget https://nvidia.box.com/shared/static/phqe92v26cbhqjohwtvxorrwnmrnfx1o.whl -O torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install numpy torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install traitlets Instalar biblioteca do JetBot \u00b6 $ git clone https://github.com/NVIDIA-AI-IOT/jetbot $ cd jetbot $ sudo python3 setup.py install Para transformar o c\u00f3digo anterior que temos para controlar o robo \u00e9 bem simples: Basta instanciar um objeto robot antes de todo o script, lembrando sempre de importar a biblioteca do JetBot. Eu tamb\u00e9m optei por fazer um dicion\u00e1rio de a\u00e7\u00f5es poss\u00edveis do rob\u00f4, para ser mais econ\u00f4mico nos \"ifs\". from jetbot import Robot robot = Robot () function_chooser = { 'left' : robot . left , 'right' : robot . right , 'go' : robot . forward , 'down' : robot . backward } Agora o que resta \u00e9 fazer o rob\u00f4 executar a a\u00e7\u00e3o assim que ele reconhece o comando. for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] if human_string in [ 'left' , 'right' , 'go' , 'down' ]: # run robot action function_chooser [ human_string ]( velocity = 0.3 ) time . sleep ( 0.5 ) robot . stop () O c\u00f3digo inteiro do movimento do rob\u00f4 est\u00e1 no arquivo chamado robot_control.py A foto da montagem final ficou assim: Veja o v\u00eddeo da demonstra\u00e7\u00e3o:","title":"Gabriel Moreira - TensorFlow"},{"location":"2019/Gabriel-TensorFlow/#gabriel-moreira-tensorflow","text":"Aluno: Gabriel Moreira Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/gabsmoreira/speech_recognition Ano: 2019 Hardware utilizado no tutorial Jetson Nano JetBot O objetivo do tutorial \u00e9 implementar um simples sistema de reconhecimento de comandos por voz com alguns ajustes em uma placa da NVIDIA Jetson Nano. Tal placa possui uma GPU incluida, o que a torna ideal para executar programas que fazem uso de redes neurais.","title":"Gabriel Moreira - TensorFlow"},{"location":"2019/Gabriel-TensorFlow/#configurando-jetson-nano","text":"","title":"Configurando Jetson Nano"},{"location":"2019/Gabriel-TensorFlow/#iso","text":"Antes de tudo, precisamos preparar a placa Jetson Nano para a prototipa\u00e7\u00e3o. Para isso, \u00e9 necess\u00e1rio fazer o download da imagem do sistema operacional oferecido pela pr\u00f3pria NVIDIA. Fa\u00e7a o download da imagem nesse link: https://developer.nvidia.com/jetson-nano-sd-card-image-r3223 Em seguida, fa\u00e7a o download do programa que escreve a imagem no cart\u00e3o SD, chamado Etcher. Isso facilitar\u00e1 muito o desenvolvimento. Link do Etcher: https://www.balena.io/etcher Instale o Etcher e execute-o. A seguinte tela ir\u00e1 aparecer. Selecione a imagem e o disco corretamente e clique em Flash! Isso pode levar de 10-15 minutos para ser feito. V\u00e1 tomar um caf\u00e9! \u2615 Assim que o processo for conclu\u00eddo, remova o cart\u00e3o do computador e coloque na placa.","title":"ISO"},{"location":"2019/Gabriel-TensorFlow/#conectar-o-hardware","text":"Antes de tudo, conecte a placa Jetson em um monitor usando a sa\u00edda HDMI. Conecte tamb\u00e9m o mouse, teclado e o cabo Ethernet. Est\u00e1 na hora de completar os passos para a configura\u00e7\u00e3o do sistema operacional. Isso requer a escolha de um usu\u00e1rio, senha e mais algumas configura\u00e7\u00f5es que n\u00e3o s\u00e3o relevantes para o projeto. Conecte agora o microfone na placa usando um adaptador USB. Para verificar se o microfone foi devidamente reconhecido pelo sistema operacional execute o comando dmesg . $ sudo dmesg | tail -n10","title":"Conectar o hardware"},{"location":"2019/Gabriel-TensorFlow/#atualizando-e-instalando-dependencias","text":"No linux da Jetson Nano, executar: Update de libs e packages: $ sudo apt update $ sudo apt upgrade Instalar Pip3: $ sudo apt install python3-pip $ sudo pip3 install -U pip Instalar depend\u00eancias do TensorFlow: $ sudo apt install libhdf5-serial-dev hdf5-tools libhdf5-dev zlib1g-dev zip libjpeg8-dev $ sudo pip3 install -U numpy == 1 .16.1 future == 0 .17.1 mock == 3 .0.5 h5py == 2 .9.0 keras_preprocessing == 1 .0.5 keras_applications == 1 .0.6 enum34 futures testresources setuptools protobuf Instalar Tensorflow: $ sudo pip3 install --pre --extra-index-url https://developer.download.nvidia.com/compute/redist/jp/v42 tensorflow-gpu $ sudo pip3 install -U pip","title":"Atualizando e instalando depend\u00eancias"},{"location":"2019/Gabriel-TensorFlow/#testando","text":"Testar instala\u00e7\u00e3o do TensorFlow: $ python3 >>> import tensorflow as tf O comando acima deve executar sem nenhum erro se o TensorFlow tiver sido instalado corretamente.","title":"Testando"},{"location":"2019/Gabriel-TensorFlow/#download-do-exemplo-do-tensorflow","text":"O TensorFlow possui um exemplo em seu reposit\u00f3rio de utiliza\u00e7\u00e3o de redes neurais para reconhecimento de comandos por voz. Nesse tutorial, utilizaremos esse mesmo exemplo com algumas adapta\u00e7\u00f5es, uma vez que o modelo fornecido recebe como input um arquivo de \u00e1udio .wav . Nosso objetivo \u00e9 criar um programa que recebe um stream de \u00e1udio que deve ser processado continuamente, assim como \u00e9 visto em assistentes de voz (Google e Siri). O primeiro passo \u00e9 clonar o reposit\u00f3rio raiz do TensorFlow. $ git clone https://github.com/tensorflow/tensorflow.git Esse comando pode demorar um pouco para ser executado, uma vez que o reposit\u00f3rio \u00e9 grande. V\u00e1 tomar um caf\u00e9! \u2615 V\u00e1 at\u00e9 a pasta do exemplo que queremos executar. $ cd tensorflow/tensorflow/examples/speech_commands/ Note que na pasta existem diversos arquivos, os principais s\u00e3o: train.py : utilizado para treinar o modelo. freeze.py : utilizado para compilar o modelo treinado. label_wav.py : utilizado para reconhecer um comando, dado um arquivo .wav de input e um modelo previamente treinado O segundo passo \u00e9 treinar a rede neural para que fique com uma boa acur\u00e1cia e consiga processar os nossos comandos de voz. Para isso execute o script train.py com os seguintes par\u00e2metros. $ python3 train.py Para que o modelo fique aceit\u00e1vel, \u00e9 necess\u00e1rio deixar pelo menos 8 horas treinando. Caso voc\u00ea n\u00e3o tenha esse tempo, o link para o modelo treinado (e compilado) est\u00e1 aqui: https://github.com/gabsmoreira/speech_recognition/raw/master/my_frozen_graph.pb A placa Jetson n\u00e3o foi projetada para treinar redes neurais, o ideal seria fazer isso em um computador mais potente e depois transferir o arquivo contento os pesos da rede neural via SCP . Com o modelo treinado, agora compile usando o checkpoint que quiser: $ python3 freeze.py --start_checkpoint = conv.ckpt-12000 --output_file = my_frozen_graph.pb Agora teste o modelo treinado. Para isso, \u00e9 necess\u00e1rio ter o path das labels do modelo (que normalmente est\u00e1 localizado no /tmp/speech_commands_train/conv_labels.txt ) $ python3 label_wav.py --graph = my_frozen_graph.pb --labels ={ PATH DAS LABELS } --wav ={ PATH DO WAV FILE }","title":"Download do exemplo do TensorFlow"},{"location":"2019/Gabriel-TensorFlow/#modificando-o-script","text":"O primeiro passo \u00e9 criar um pequeno exemplo de captura e processamento de stream de \u00e1udio usando o pyaudio . Antes de criar o novo arquivo, instale a biblioteca acima. $ pip3 install pyaudio Crie um arquivo com o nome audio_stream.py e coloque o seguinte c\u00f3digo: from __future__ import absolute_import from __future__ import division from __future__ import print_function import argparse import sys import pyaudio import numpy as np import audioop import wave import tensorflow as tf import time FLAGS = None CHUNK = 4096 # number of data points to read at a time RATE = 16000 # time resolution of the recording device (Hz) CHANNELS = 1 # number of channels FORMAT = pyaudio . paInt16 # audio format from pyaudio p = pyaudio . PyAudio () # start the PyAudio class devinfo = p . get_device_info_by_index ( 0 ) # get the first recorder device # stream from pyaudio stream = p . open ( format = FORMAT , channels = CHANNELS , rate = RATE , input = True , frames_per_buffer = CHUNK ) while True : # transform data into a numpy array data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) # get audio rms rms = audioop . rms ( data , 2 ) # if audio rms reaches 900 or more set recording for true # and start appending the data into the frames array. # this means someone is talking if rms > 900 : if recording == False : recording = True frames . append ( data ) else : if recording == True : time_from_previous = time . time () # get data from stream for the next 0.5 seconds # after the volume while time . time () - time_from_previous < 0.5 : data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) frames . append ( data ) # write frames inside wav file _file = wave . open ( \"out.wav\" , \"wb\" ) _file . setnchannels ( CHANNELS ) _file . setsampwidth ( p . get_sample_size ( FORMAT )) _file . setframerate ( RATE ) _file . writeframes ( b '' . join ( frames )) _file . close () # clear frames array since the data was # written inside wav file frames = [] recording = False A ideia \u00e9 criar um stream que comeca a gravar os dados do \u00e1udio em uma array assim que o \"volume\" do \u00e1udio passa de 900 (isso pode depender do microfone usado) e para depois de 0.5 segundos assim que o audio volta a ficar com um valor menor que 900. Tal array \u00e9 escrita em um arquivo .wav constantemente. Com esse c\u00f3digo, transformamos um stream de \u00e1udio em diversos .wav que agora podem ser usados no modelo treinado. O que falta ent\u00e3o \u00e9 unir esse c\u00f3digo do stream de \u00e1udio com a predi\u00e7\u00e3o do modelo. C\u00f3digo fonte, python from __future__ import absolute_import from __future__ import division from __future__ import print_function import argparse import sys import pyaudio import numpy as np import audioop import wave import tensorflow as tf import time FLAGS = None CHUNK = 4096 # number of data points to read at a time RATE = 16000 # time resolution of the recording device (Hz) CHANNELS = 1 # number of channels FORMAT = pyaudio . paInt16 # audio format from pyaudio p = pyaudio . PyAudio () # start the PyAudio class devinfo = p . get_device_info_by_index ( 0 ) # get the first recorder device # stream from pyaudio stream = p . open ( format = FORMAT , channels = CHANNELS , rate = RATE , input = True , frames_per_buffer = CHUNK ) def load_graph ( filename ): \"\"\"Unpersists graph from file as default graph.\"\"\" with tf . io . gfile . GFile ( filename , 'rb' ) as f : graph_def = tf . compat . v1 . GraphDef () graph_def . ParseFromString ( f . read ()) tf . import_graph_def ( graph_def , name = '' ) def load_labels ( filename ): \"\"\"Read in labels, one label per line.\"\"\" return [ line . rstrip () for line in tf . io . gfile . GFile ( filename )] def run_graph ( wav_data , labels , input_layer_name , output_layer_name , num_top_predictions ): \"\"\"Runs the audio data through the graph and prints predictions.\"\"\" with tf . compat . v1 . Session () as sess : # Feed the audio data as input to the graph. # predictions will contain a two-dimensional array, where one # dimension represents the input image count, and the other has # predictions per class softmax_tensor = sess . graph . get_tensor_by_name ( output_layer_name ) predictions , = sess . run ( softmax_tensor , { input_layer_name : wav_data }) # Sort to show labels in order of confidence top_k = predictions . argsort ()[ - num_top_predictions :][:: - 1 ] for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] print ( ' %s (score = %.5f )' % ( human_string , score )) return 0 def label_wav ( wav , labels , graph , input_name , output_name , how_many_labels ): \"\"\"Loads the model and labels, and runs the inference to print predictions.\"\"\" if not wav or not tf . io . gfile . exists ( wav ): tf . compat . v1 . logging . fatal ( 'Audio file does not exist %s ' , wav ) if not labels or not tf . io . gfile . exists ( labels ): tf . compat . v1 . logging . fatal ( 'Labels file does not exist %s ' , labels ) if not graph or not tf . io . gfile . exists ( graph ): tf . compat . v1 . logging . fatal ( 'Graph file does not exist %s ' , graph ) labels_list = load_labels ( labels ) # load graph, which is stored in the default session load_graph ( graph ) with open ( wav , 'rb' ) as wav_file : wav_data = wav_file . read () run_graph ( wav_data , labels_list , input_name , output_name , how_many_labels ) def prepare ( graph , labels ): \"\"\"Loads data labels and tensor graphs\"\"\" labels_list = load_labels ( labels ) load_graph ( graph ) return labels_list def main ( _ ): # initialize variables and prepare graph labels = prepare ( FLAGS . graph , FLAGS . labels ) recording = False frames = [] time_from_previous = 0 with tf . compat . v1 . Session () as sess : # loads softmax tensor softmax_tensor = sess . graph . get_tensor_by_name ( FLAGS . output_name ) while True : # transform data into a numpy array data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) # get audio rms rms = audioop . rms ( data , 2 ) # if audio rms reaches 900 or more set recording for true # and start appending the data into the frames array. # this means someone is talking if rms > 900 : if recording == False : recording = True frames . append ( data ) else : if recording == True : time_from_previous = time . time () # get data from stream for the next 0.5 seconds # after the volume while time . time () - time_from_previous < 0.5 : data = np . fromstring ( stream . read ( CHUNK ), dtype = np . int16 ) frames . append ( data ) # write frames inside wav file _file = wave . open ( \"out.wav\" , \"wb\" ) _file . setnchannels ( CHANNELS ) _file . setsampwidth ( p . get_sample_size ( FORMAT )) _file . setframerate ( RATE ) _file . writeframes ( b '' . join ( frames )) _file . close () # clear frames array since the data was # written inside wav file frames = [] # read wav file to get the input data for # our neural network with open ( 'out.wav' , 'rb' ) as wav_file : wav_data = wav_file . read () # this is where the model predicts based on the input data predictions , = sess . run ( softmax_tensor , { FLAGS . input_name : wav_data }) # Sort to show labels in order of confidence top_k = predictions . argsort ()[ - FLAGS . how_many_labels :][:: - 1 ] for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] print ( ' %s (score = %.5f )' % ( human_string , score )) recording = False if __name__ == '__main__' : parser = argparse . ArgumentParser () parser . add_argument ( '--wav' , type = str , default = '' , help = 'Audio file to be identified.' ) parser . add_argument ( '--graph' , type = str , default = '' , help = 'Model to use for identification.' ) parser . add_argument ( '--labels' , type = str , default = '' , help = 'Path to file containing labels.' ) parser . add_argument ( '--input_name' , type = str , default = 'wav_data:0' , help = 'Name of WAVE data input node in model.' ) parser . add_argument ( '--output_name' , type = str , default = 'labels_softmax:0' , help = 'Name of node outputting a prediction in the model.' ) parser . add_argument ( '--how_many_labels' , type = int , default = 1 , help = 'Number of results to show.' ) FLAGS , unparsed = parser . parse_known_args () tf . compat . v1 . app . run ( main = main , argv = [ sys . argv [ 0 ]] + unparsed ) Agora para testar o script, basta executar o arquivo python. $ python3 audio_stream.py Veja o v\u00eddeo da demonstra\u00e7\u00e3o","title":"Modificando o script"},{"location":"2019/Gabriel-TensorFlow/#extra-controle-do-jetbot-por-comando-de-voz","text":"Para fazer essa parte do tutorial, \u00e9 necess\u00e1rio ter o mesmo material/recursos propostos no link do JetBot. Link do tutorial do JetBot: https://github.com/NVIDIA-AI-IOT/jetbot/wiki/bill-of-materials Para montar a parte de hardware, basta seguir esse tutorial: https://github.com/NVIDIA-AI-IOT/jetbot/wiki/Hardware-Setup A parte de software j\u00e1 temos, basta instalar s\u00f3 mais alguns pacotes.","title":"Extra - controle do JetBot por comando de voz"},{"location":"2019/Gabriel-TensorFlow/#intalar-bibliotecas-adicionais","text":"$ cd $ wget https://nvidia.box.com/shared/static/phqe92v26cbhqjohwtvxorrwnmrnfx1o.whl -O torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install numpy torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install traitlets","title":"Intalar bibliotecas adicionais"},{"location":"2019/Gabriel-TensorFlow/#instalar-biblioteca-do-jetbot","text":"$ git clone https://github.com/NVIDIA-AI-IOT/jetbot $ cd jetbot $ sudo python3 setup.py install Para transformar o c\u00f3digo anterior que temos para controlar o robo \u00e9 bem simples: Basta instanciar um objeto robot antes de todo o script, lembrando sempre de importar a biblioteca do JetBot. Eu tamb\u00e9m optei por fazer um dicion\u00e1rio de a\u00e7\u00f5es poss\u00edveis do rob\u00f4, para ser mais econ\u00f4mico nos \"ifs\". from jetbot import Robot robot = Robot () function_chooser = { 'left' : robot . left , 'right' : robot . right , 'go' : robot . forward , 'down' : robot . backward } Agora o que resta \u00e9 fazer o rob\u00f4 executar a a\u00e7\u00e3o assim que ele reconhece o comando. for node_id in top_k : human_string = labels [ node_id ] score = predictions [ node_id ] if human_string in [ 'left' , 'right' , 'go' , 'down' ]: # run robot action function_chooser [ human_string ]( velocity = 0.3 ) time . sleep ( 0.5 ) robot . stop () O c\u00f3digo inteiro do movimento do rob\u00f4 est\u00e1 no arquivo chamado robot_control.py A foto da montagem final ficou assim: Veja o v\u00eddeo da demonstra\u00e7\u00e3o:","title":"Instalar biblioteca do JetBot"},{"location":"2019/Leo-OpenCL/","text":"Leonardo Medeiros - Tutorial OpenCL \u00b6 Aluno: Leonardo Medeiros Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/Leotayner/Tutorial-OpenCL Ano: 2019 Hardware utilizado no tutorial DE10-Standard OpenCL \u00b6 OpenCL (Open Computing Language) \u00e9 uma API de baixo n\u00edvel para programa\u00e7\u00e3o de alto desempenho em ambientes computacionais heterog\u00eaneos compostos por CPUs, GPUs, e outros processadores paralelos como FPGA, permitindo desenvolver aplica\u00e7\u00f5es port\u00e1veis e eficientes. Arquitetura OpenCL \u00b6 O padr\u00e3o OpenCL prop\u00f5e uma arquitetura em que h\u00e1 um host que agrega um ou mais devices, cada device possui unidades de computa\u00e7\u00e3o que cont\u00e9m elementos de processamento. O host \u00e9 respons\u00e1vel pelo reconhecimento e inicializa\u00e7\u00e3o dos dispositivos, bem como pela transfer\u00eancia de dados e tarefas para execu\u00e7\u00e3o. O device \u00e9 respons\u00e1vel por processar todos esses dados ao executar as tarefas programadas. Na arquitetura do device, considerando o contexto de programa\u00e7\u00e3o paralela, o equivalente a uma thread \u00e9 o work-item, que representa a menor unidade de tarefa. Esses works-itens s\u00e3o agrupados em blocos denominados work-group, onde os works-itens de um mesmo bloco podem se comunicar e se sincronizar Os work-groups por sua vez s\u00e3o organizados em grids, onde dever\u00e3o ter a mesma dimens\u00e3o, podendo a grid ser unidimensional, bidimensional ou tridimensional. Figura 1 - Arquitetura OpenCL De forma geral essa estrutura possui tr\u00eas tipos de mem\u00f3rias: Private Memory Estritamente atrelada ao seu respectivo worker, apenas seu worker pode acessa-la Local memory Estritamente atrelada ao seu respectivo bloco, todos os workers dentro do bloco podem acess\u00e1-la Global Constant Memory data Cache Cache da memoria global do device, todos os blocos podem acessa-la Global Constant Memory memoria global do device Figura 1 - Arquitetura OpenCL FPGA vs CPU \u00b6 A arquitetura de funcionamento de acessos de mem\u00f3ria e configura\u00e7\u00e3o do programa na estrutura OpenCL \u00e9 um pouco diferente da estrutura geral apresentada anteriormente, a \u00fanica diferen\u00e7a \u00e9 que a mem\u00f3ria do host e do device est\u00e3o contidas no mesmo dispositivo, consequentemente o tempo de transfer\u00eancia dos dados entre Host e o device \u00e9 muito menor, nessa estrutura o ARM \u00e9 respons\u00e1vel por programar a FPGA atrav\u00e9s do barramento AxI, e transmitir dados para a mem\u00f3ria global DDR3, da qual a FPGA faz uso para executar suas tarefas como device. Ao analisar os ganhos ao utilizar o OpenCL em FPGA, al\u00e9m da vantagem do baixo tempo de transfer\u00eancia de dados citado anteriormente, tamb\u00e9m h\u00e1 as vantagens caracter\u00edsticas desse processador, como flexibilidade de hardware e sua quantidade massiva de cores. Figura 2 - Arquitetura OpenCL-FPGA Enquanto que a estrutura em CPU, possui uma quantidade reduzida de cores com unidades aritm\u00e9ticas potentes para reduzir lat\u00eancia de opera\u00e7\u00f5es. Figura 4 - Arquitetura CPU Logo a estrutura em FPGA apresenta maior desempenho comparada a CPU para programas paralelos, devido a seu grande n\u00famero de cores e baixo tempo de transfer\u00eancia de dados, enquanto a CPU apresenta maior desempenho que a fpga para programas sequenciais, devido a suas unidades aritm\u00e9ticas potentes. Tutorial OpenCL-DE-10 \u00b6 1. Requerimentos de Sistema \u00b6 Placa Terasic DE10-Standard Cart\u00e3o microSD com ao menos 4GB Leitor de cart\u00e3o microSD Cabo USB (tipo A para mini-B) Host PC com Porta USB 64-bit Windows 7 ou Linux ( este tutorial utiliza linux) 32GB de memoria \u00e9 recomendado PuTTY ou Minicom(Linux) utility Intel Quartus Prime v18.1 instalado com licen\u00e7a valida Intel OpenCL v18.1 instalado com licen\u00e7a valida Intel SoC EDS v18.1 instalado 2. Configurando a Infra Estrutura \u00b6 Essa etapa descreve como configurar o ambiente de desenvolvimento do OpenCL no Padr\u00e3o DE10-Standard. 2.1 Instala\u00e7\u00e3o de Software \u00b6 \u00c9 necess\u00e1rio instalar os seguintes softwares: Intel Quartus Standard e OpenCL SDK Intel SoC EDS DE10-Standard OpenCL Board Support Package (BSP) Ap\u00f3s a instala\u00e7\u00e3o do Quartus Prime e do OpenCL SDK, crie uma pasta com o nome terasic, a qual deve conter a pasta DE10-Standard-Opencl. A pasta criada deve estar no diret\u00f3rio board: /intelFPGA/18.1/hld/board 2.2 Instala\u00e7\u00e3o da Licensa Opencl \u00b6 \u00c9 necess\u00e1ria uma licen\u00e7a OpenCL para o Intel OpenCL SDK compilar o projeto. Em posse da licen\u00e7a \u00e9 necess\u00e1rio criar uma vari\u00e1vel de ambiente LM_LICENSE_FILE com a atribui\u00e7\u00e3o do diret\u00f3rio da licen\u00e7a. 2.3 Configurando variaveis de ambiente \u00b6 As seguintes vari\u00e1veis de ambiente devem ser configuradas para o funcionamento do projeto, isso pode ser feito adicionando as vari\u00e1veis a seguir ao arquivo .bash-rc (configura\u00e7\u00e3o permanente), ou em um arquivo.sh (configura\u00e7\u00e3o temporaria, utilizar $source arquivo.sh para ativar o ambiente). echo Opencl 18 .1 export LOCAL = /media/leonardo export QUARTUS_ROOTDIR = $LOCAL /FPGA/intelFPGA/18.1/quartus export ALTERAOCLSDKROOT = $LOCAL /FPGA/intelFPGA/18.1/hld export PATH = $PATH : $QUARTUS_ROOTDIR /bin: $LOCAL /FPGA/intelFPGA/18.1/embedded/ds-5/bin: $LOCAL /FPGA/intelFPGA/18.1/embedded/ds-5/sw/gcc/bin: $ALTERAOCLSDKROOT /bin: $ALTERAOCLSDKROOT /linux64/bin: export LD_LIBRARY_PATH = $ALTERAOCLSDKROOT /linux64/lib export AOCL_BOARD_PACKAGE_ROOT = $ALTERAOCLSDKROOT /board/terasic/de10_standard export QUARTUS_64BIT = 1 export LM_LICENSE_FILE = \"/home/leonardo/Downloads/1-R3OQLF_License.dat\" export INTELFPGAOCLSDKROOT = $LOCAL /FPGA/intelFPGA/18.1/hld 2.3 Verifica\u00e7\u00e3o do Ambiente \u00b6 Esta se\u00e7\u00e3o mostra como verificar se o ambiente OpenCL est\u00e1 configurado corretamente. Verificar Vers\u00e3o $ aocl version aocl 18.1.0.625 (Intel(R) FPGA SDK for OpenCL(TM), Version 18.1.0 Build 625 Standard Edition, Copyright (C) 2018 Intel Corporation) Verificar placa de destino $ aoc -list-boards Board list: de10_standard_sharedonly``` Board Package: /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard 3. Compilar Projeto \u00b6 Esta se\u00e7\u00e3o mostra como compilar o kernel e o programa host do OpenCL, necess\u00e1rios para executar um programa em OpenCL. Compilar Kernel $ cd /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard/test/vector_add_2 $ aoc device/vector_add.cl -o bin/vector_add.aocx --sw-dimm-partition -board=de10_standard_sharedonly -report Um arquivo .aocx ser\u00e1 gerado, este \u00e9 utilizado para a configura\u00e7\u00e3o dos kernels programados, configurando a execu\u00e7\u00e3o de tarefas e troca de informa\u00e7\u00f5es entre FPGA e sistema host. Warning A copila\u00e7\u00e3o do kernel \u00e9 muito lenta, pode levar horas. Compilar Programa Host $ cd /media/leonardo/FPGA/intelFPGA/18.1/embedded $ embedded_command_shell.sh $ cd /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard/test/vector_add_2 $ make Um arquivo host ser\u00e1 gerado, esse arquivo \u00e9 basicamente o .o usual de uma compila\u00e7\u00e3o do GCC, arquivo intermedi\u00e1rio que ser\u00e1 utilizado em est\u00e1gios de execu\u00e7\u00e3o. Se ao executar o comando make ocorrer erros de include na biblioteca Cl adicione o par\u00e2metro ../../../../../host/include/ ao INC_DIRS no arquivo makefile 4. Embarcar Kernel \u00b6 Utilizaremos uma imagem .iso j\u00e1 gerada com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux com OpenCL. Atrav\u00e9s da pasta DE10_standard_opencl extraia o arquivo de10_standard_opencl.img, esse arquivo \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg, que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: $ dmesg | tail 4789.207972] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [4789.211680] mmcblk0: mmc0:aaaa SL16G 14.8 GiB [ 4789.215857] mmcblk0: p1 p2 p3 [ 4988.443942] mmcblk0: p1 p2 p3 Agora vamos salvar a .iso no SDcard. $ sudo dd bs=1M if=de10_standard_opencl.img of=/dev/sdc conv=fsync status=progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cache escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Agora devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1 GiB: Filesystem (/) Os arquivos obtidos na compila\u00e7\u00e3o do kernel e host, respectivamente arquivo.ocx e host devem ser colocados na pasta /home/root/ da parti\u00e7\u00e3o de 1GiB, para serem executadas posteriormente na placa. 5. Ajustar a placa \u00b6 Verifique se o interruptor DIP (SW10) MSEL [4: 0] = 01010. 5. Conectar-se a placa \u00b6 Com a placa conectada ao USB do computador, para conectar-se ao kernel da sistema, deve-se utilizar o seguinte comando: $ screen /dev/ttyUSB0 115200,cs8 6. Executar o projeto \u00b6 Dentro do terminal do sistema: $ source ./init_opencl.sh $ aocl program /dev/acl0 vector_add.aocx $ ./host An\u00e1lises de Desempenho CPU vs OPENCL \u00b6 Ao comparar o tempo de execu\u00e7\u00e3o do programa vector_add , que realiza uma simples soma de vetores, entre a CPU e a FPGA foram obtidos os seguintes resultados. Size-Vector CPU FPGA 1000000 32.011 6.924 5000000 159.805 34.278 10000000 304.255 68.462 20000000 617.676 180.13 Como pode-se observar o desempenho da execu\u00e7\u00e3o na FPGA \u00e9 muito maior, embora a diferen\u00e7a num\u00e9rica seja pequena, deve-se lembrar que o arquivo de teste realiza uma simples opera\u00e7\u00e3o de soma de vetor, logo para programas mais complexos, o ganho de desempenho na FPGA seria mais expressivo. Note O teste da CPU \u00e9 single thread","title":"Leonardo Medeiros  - Tutorial OpenCL"},{"location":"2019/Leo-OpenCL/#leonardo-medeiros-tutorial-opencl","text":"Aluno: Leonardo Medeiros Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/Leotayner/Tutorial-OpenCL Ano: 2019 Hardware utilizado no tutorial DE10-Standard","title":"Leonardo Medeiros  - Tutorial OpenCL"},{"location":"2019/Leo-OpenCL/#opencl","text":"OpenCL (Open Computing Language) \u00e9 uma API de baixo n\u00edvel para programa\u00e7\u00e3o de alto desempenho em ambientes computacionais heterog\u00eaneos compostos por CPUs, GPUs, e outros processadores paralelos como FPGA, permitindo desenvolver aplica\u00e7\u00f5es port\u00e1veis e eficientes.","title":"OpenCL"},{"location":"2019/Leo-OpenCL/#arquitetura-opencl","text":"O padr\u00e3o OpenCL prop\u00f5e uma arquitetura em que h\u00e1 um host que agrega um ou mais devices, cada device possui unidades de computa\u00e7\u00e3o que cont\u00e9m elementos de processamento. O host \u00e9 respons\u00e1vel pelo reconhecimento e inicializa\u00e7\u00e3o dos dispositivos, bem como pela transfer\u00eancia de dados e tarefas para execu\u00e7\u00e3o. O device \u00e9 respons\u00e1vel por processar todos esses dados ao executar as tarefas programadas. Na arquitetura do device, considerando o contexto de programa\u00e7\u00e3o paralela, o equivalente a uma thread \u00e9 o work-item, que representa a menor unidade de tarefa. Esses works-itens s\u00e3o agrupados em blocos denominados work-group, onde os works-itens de um mesmo bloco podem se comunicar e se sincronizar Os work-groups por sua vez s\u00e3o organizados em grids, onde dever\u00e3o ter a mesma dimens\u00e3o, podendo a grid ser unidimensional, bidimensional ou tridimensional. Figura 1 - Arquitetura OpenCL De forma geral essa estrutura possui tr\u00eas tipos de mem\u00f3rias: Private Memory Estritamente atrelada ao seu respectivo worker, apenas seu worker pode acessa-la Local memory Estritamente atrelada ao seu respectivo bloco, todos os workers dentro do bloco podem acess\u00e1-la Global Constant Memory data Cache Cache da memoria global do device, todos os blocos podem acessa-la Global Constant Memory memoria global do device Figura 1 - Arquitetura OpenCL","title":"Arquitetura OpenCL"},{"location":"2019/Leo-OpenCL/#fpga-vs-cpu","text":"A arquitetura de funcionamento de acessos de mem\u00f3ria e configura\u00e7\u00e3o do programa na estrutura OpenCL \u00e9 um pouco diferente da estrutura geral apresentada anteriormente, a \u00fanica diferen\u00e7a \u00e9 que a mem\u00f3ria do host e do device est\u00e3o contidas no mesmo dispositivo, consequentemente o tempo de transfer\u00eancia dos dados entre Host e o device \u00e9 muito menor, nessa estrutura o ARM \u00e9 respons\u00e1vel por programar a FPGA atrav\u00e9s do barramento AxI, e transmitir dados para a mem\u00f3ria global DDR3, da qual a FPGA faz uso para executar suas tarefas como device. Ao analisar os ganhos ao utilizar o OpenCL em FPGA, al\u00e9m da vantagem do baixo tempo de transfer\u00eancia de dados citado anteriormente, tamb\u00e9m h\u00e1 as vantagens caracter\u00edsticas desse processador, como flexibilidade de hardware e sua quantidade massiva de cores. Figura 2 - Arquitetura OpenCL-FPGA Enquanto que a estrutura em CPU, possui uma quantidade reduzida de cores com unidades aritm\u00e9ticas potentes para reduzir lat\u00eancia de opera\u00e7\u00f5es. Figura 4 - Arquitetura CPU Logo a estrutura em FPGA apresenta maior desempenho comparada a CPU para programas paralelos, devido a seu grande n\u00famero de cores e baixo tempo de transfer\u00eancia de dados, enquanto a CPU apresenta maior desempenho que a fpga para programas sequenciais, devido a suas unidades aritm\u00e9ticas potentes.","title":"FPGA vs CPU"},{"location":"2019/Leo-OpenCL/#tutorial-opencl-de-10","text":"","title":"Tutorial OpenCL-DE-10"},{"location":"2019/Leo-OpenCL/#1-requerimentos-de-sistema","text":"Placa Terasic DE10-Standard Cart\u00e3o microSD com ao menos 4GB Leitor de cart\u00e3o microSD Cabo USB (tipo A para mini-B) Host PC com Porta USB 64-bit Windows 7 ou Linux ( este tutorial utiliza linux) 32GB de memoria \u00e9 recomendado PuTTY ou Minicom(Linux) utility Intel Quartus Prime v18.1 instalado com licen\u00e7a valida Intel OpenCL v18.1 instalado com licen\u00e7a valida Intel SoC EDS v18.1 instalado","title":"1. Requerimentos de Sistema"},{"location":"2019/Leo-OpenCL/#2-configurando-a-infra-estrutura","text":"Essa etapa descreve como configurar o ambiente de desenvolvimento do OpenCL no Padr\u00e3o DE10-Standard.","title":"2. Configurando a Infra Estrutura"},{"location":"2019/Leo-OpenCL/#21-instalacao-de-software","text":"\u00c9 necess\u00e1rio instalar os seguintes softwares: Intel Quartus Standard e OpenCL SDK Intel SoC EDS DE10-Standard OpenCL Board Support Package (BSP) Ap\u00f3s a instala\u00e7\u00e3o do Quartus Prime e do OpenCL SDK, crie uma pasta com o nome terasic, a qual deve conter a pasta DE10-Standard-Opencl. A pasta criada deve estar no diret\u00f3rio board: /intelFPGA/18.1/hld/board","title":"2.1 Instala\u00e7\u00e3o de Software"},{"location":"2019/Leo-OpenCL/#22-instalacao-da-licensa-opencl","text":"\u00c9 necess\u00e1ria uma licen\u00e7a OpenCL para o Intel OpenCL SDK compilar o projeto. Em posse da licen\u00e7a \u00e9 necess\u00e1rio criar uma vari\u00e1vel de ambiente LM_LICENSE_FILE com a atribui\u00e7\u00e3o do diret\u00f3rio da licen\u00e7a.","title":"2.2 Instala\u00e7\u00e3o da Licensa Opencl"},{"location":"2019/Leo-OpenCL/#23-configurando-variaveis-de-ambiente","text":"As seguintes vari\u00e1veis de ambiente devem ser configuradas para o funcionamento do projeto, isso pode ser feito adicionando as vari\u00e1veis a seguir ao arquivo .bash-rc (configura\u00e7\u00e3o permanente), ou em um arquivo.sh (configura\u00e7\u00e3o temporaria, utilizar $source arquivo.sh para ativar o ambiente). echo Opencl 18 .1 export LOCAL = /media/leonardo export QUARTUS_ROOTDIR = $LOCAL /FPGA/intelFPGA/18.1/quartus export ALTERAOCLSDKROOT = $LOCAL /FPGA/intelFPGA/18.1/hld export PATH = $PATH : $QUARTUS_ROOTDIR /bin: $LOCAL /FPGA/intelFPGA/18.1/embedded/ds-5/bin: $LOCAL /FPGA/intelFPGA/18.1/embedded/ds-5/sw/gcc/bin: $ALTERAOCLSDKROOT /bin: $ALTERAOCLSDKROOT /linux64/bin: export LD_LIBRARY_PATH = $ALTERAOCLSDKROOT /linux64/lib export AOCL_BOARD_PACKAGE_ROOT = $ALTERAOCLSDKROOT /board/terasic/de10_standard export QUARTUS_64BIT = 1 export LM_LICENSE_FILE = \"/home/leonardo/Downloads/1-R3OQLF_License.dat\" export INTELFPGAOCLSDKROOT = $LOCAL /FPGA/intelFPGA/18.1/hld","title":"2.3 Configurando variaveis de ambiente"},{"location":"2019/Leo-OpenCL/#23-verificacao-do-ambiente","text":"Esta se\u00e7\u00e3o mostra como verificar se o ambiente OpenCL est\u00e1 configurado corretamente. Verificar Vers\u00e3o $ aocl version aocl 18.1.0.625 (Intel(R) FPGA SDK for OpenCL(TM), Version 18.1.0 Build 625 Standard Edition, Copyright (C) 2018 Intel Corporation) Verificar placa de destino $ aoc -list-boards Board list: de10_standard_sharedonly``` Board Package: /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard","title":"2.3 Verifica\u00e7\u00e3o do Ambiente"},{"location":"2019/Leo-OpenCL/#3-compilar-projeto","text":"Esta se\u00e7\u00e3o mostra como compilar o kernel e o programa host do OpenCL, necess\u00e1rios para executar um programa em OpenCL. Compilar Kernel $ cd /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard/test/vector_add_2 $ aoc device/vector_add.cl -o bin/vector_add.aocx --sw-dimm-partition -board=de10_standard_sharedonly -report Um arquivo .aocx ser\u00e1 gerado, este \u00e9 utilizado para a configura\u00e7\u00e3o dos kernels programados, configurando a execu\u00e7\u00e3o de tarefas e troca de informa\u00e7\u00f5es entre FPGA e sistema host. Warning A copila\u00e7\u00e3o do kernel \u00e9 muito lenta, pode levar horas. Compilar Programa Host $ cd /media/leonardo/FPGA/intelFPGA/18.1/embedded $ embedded_command_shell.sh $ cd /media/leonardo/FPGA/intelFPGA/18.1/hld/board/terasic/de10_standard/test/vector_add_2 $ make Um arquivo host ser\u00e1 gerado, esse arquivo \u00e9 basicamente o .o usual de uma compila\u00e7\u00e3o do GCC, arquivo intermedi\u00e1rio que ser\u00e1 utilizado em est\u00e1gios de execu\u00e7\u00e3o. Se ao executar o comando make ocorrer erros de include na biblioteca Cl adicione o par\u00e2metro ../../../../../host/include/ ao INC_DIRS no arquivo makefile","title":"3. Compilar Projeto"},{"location":"2019/Leo-OpenCL/#4-embarcar-kernel","text":"Utilizaremos uma imagem .iso j\u00e1 gerada com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux com OpenCL. Atrav\u00e9s da pasta DE10_standard_opencl extraia o arquivo de10_standard_opencl.img, esse arquivo \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg, que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: $ dmesg | tail 4789.207972] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [4789.211680] mmcblk0: mmc0:aaaa SL16G 14.8 GiB [ 4789.215857] mmcblk0: p1 p2 p3 [ 4988.443942] mmcblk0: p1 p2 p3 Agora vamos salvar a .iso no SDcard. $ sudo dd bs=1M if=de10_standard_opencl.img of=/dev/sdc conv=fsync status=progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cache escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Agora devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1 GiB: Filesystem (/) Os arquivos obtidos na compila\u00e7\u00e3o do kernel e host, respectivamente arquivo.ocx e host devem ser colocados na pasta /home/root/ da parti\u00e7\u00e3o de 1GiB, para serem executadas posteriormente na placa.","title":"4. Embarcar Kernel"},{"location":"2019/Leo-OpenCL/#5-ajustar-a-placa","text":"Verifique se o interruptor DIP (SW10) MSEL [4: 0] = 01010.","title":"5. Ajustar a placa"},{"location":"2019/Leo-OpenCL/#5-conectar-se-a-placa","text":"Com a placa conectada ao USB do computador, para conectar-se ao kernel da sistema, deve-se utilizar o seguinte comando: $ screen /dev/ttyUSB0 115200,cs8","title":"5. Conectar-se a placa"},{"location":"2019/Leo-OpenCL/#6-executar-o-projeto","text":"Dentro do terminal do sistema: $ source ./init_opencl.sh $ aocl program /dev/acl0 vector_add.aocx $ ./host","title":"6. Executar o projeto"},{"location":"2019/Leo-OpenCL/#analises-de-desempenho-cpu-vs-opencl","text":"Ao comparar o tempo de execu\u00e7\u00e3o do programa vector_add , que realiza uma simples soma de vetores, entre a CPU e a FPGA foram obtidos os seguintes resultados. Size-Vector CPU FPGA 1000000 32.011 6.924 5000000 159.805 34.278 10000000 304.255 68.462 20000000 617.676 180.13 Como pode-se observar o desempenho da execu\u00e7\u00e3o na FPGA \u00e9 muito maior, embora a diferen\u00e7a num\u00e9rica seja pequena, deve-se lembrar que o arquivo de teste realiza uma simples opera\u00e7\u00e3o de soma de vetor, logo para programas mais complexos, o ganho de desempenho na FPGA seria mais expressivo. Note O teste da CPU \u00e9 single thread","title":"An\u00e1lises de Desempenho CPU vs OPENCL"},{"location":"2019/Martim-F1/","text":"Martim F. Jos\u00e9 - FPGA na AWS \u00b6 Aluno: Martim Ferreira Jos\u00e9 Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: Ano: 2019 Hardware utilizado no tutorial Inst\u00e2ncia F1 na AWS Introdu\u00e7\u00e3o \u00b6 A AWS disp\u00f5em de inst\u00e2ncias F1, que s\u00e3o m\u00e1quinas de alta performance que cont\u00e9m uma FPGA no barramento PCI, permitindo a execu\u00e7\u00e3o de programas acelerados por meio de hardware personalizado. Para executar um programa em uma FPGA na nuvem, \u00e9 preciso primeiro desenvolver, simular, depurar e compilar o c\u00f3digo. Tudo isso \u00e9 feito em uma inst\u00e2ncia de desenvolvimento, predefinida por uma AMI (Amazon Machine Image) fornecida pela AWS. Na inst\u00e2ncia de desenvolvedor, o programa \u00e9 compilado e \u00e9 gerada uma imagem para a FPGA Xilinx presente na inst\u00e2ncia F1. O programa a ser implementado na FPGA pode ser desenvolvido utilizando tr\u00eas ambientes de desenvolvimento diferentes, documentados a seguir: Development Environment Description Accelerator Language Software Defined Accelerator Development - SDAccel Development experience leverages an optimized compiler to allow easy new accelerator development or migration of existing C/C++/openCL, Verilog/VHDL to AWS FPGA instances C/C++/OpenCL, Verilog/VHDL (RTL) Hardware Accelerator Development - HDK Fully custom hardware development experience provides hardware developers with the tools required for developing AFIs for AWS FPGA instances Verilog/VHDL IP Integrator or High Level Synthesis (HLx) Graphical interface development experience for integrating IP and high level synthesis development Verilog/VHDL/C Pela facilidade e maior conhecimento de C++, opta-se pela escolha do ambiente SDAccel. Portando, o programa a ser implementado \u00e9 programado em sua maioria em C++ utilizando a arquitetura OpenCL, que \u00e9 amplamente utilizada na programa\u00e7\u00e3o de alto desempenho em diversas plataformas. Este tutorial faz a implementa\u00e7\u00e3o do exemplo Hello World, que consiste na adi\u00e7\u00e3o de dois vetores. O c\u00f3digo deste exemplo pode ser examinado a fundo no seguinte reposit\u00f3rio: https://github.com/Xilinx/SDAccel_Examples/tree/a41b58921188ad90ace2d34a22a2513d8f74b549/getting_started/host/helloworld_ocl No reposit\u00f3rio h\u00e1 dois arquivos na pasta src : host.cpp e vector_addition.cl , que correspondem ao programa da m\u00e1quina e ao kernel da FPGA, respectivamente. O arquivo host consiste em um programa C++ em que: S\u00e3o definidos tr\u00eas vetores: A, B e results. A placa Xilinx \u00e9 selecionada e adicionada para o contexto da execu\u00e7\u00e3o. O bin\u00e1rio do kernel \u00e9 carregado e adicionado para um programa Para migrar os dados entre host e device, s\u00e3o criados dois buffers de leitura referenciando A e B; E um buffer de escrita referenciando result. Os dados armazenados nos buffers de leitura s\u00e3o transferidos da mem\u00f3ria da m\u00e1quina para mem\u00f3ria da FPGA. O kernel \u00e9 extra\u00eddo do programa, os argumentos s\u00e3o determinados (result, A, B, tamanho) e ele \u00e9 lan\u00e7ado. Os resultados s\u00e3o requisitados da FPGA e armazenados no buffer de escrita. E por fim, o resultado recebido \u00e9 comparados com o resultado esperado. O arquivo do kernel consiste em uma fun\u00e7\u00e3o em OpenCL que: Recebe quatro argumentos (result, A, B, tamanho) Define os arrays A e B Percorre os arrays recebidos como argumento, populando os arrays declarados Percorre o tamanho das arrays escrevendo no buffer de escrita (result) a soma de A e B em cada \u00edndice. Aplica\u00e7\u00f5es \u00b6 As inst\u00e2ncias com FPGA s\u00e3o amplamente utilizadas em situa\u00e7\u00f5es em que h\u00e1 uma grande quantidade de dados e o processamento precisa ser feito com rapidez. O desenvolvimento de um hardware personalizado para executar um programa fornece um custo de computa\u00e7\u00e3o 30x melhor comparado com inst\u00e2ncias de CPU. Entre essas aplica\u00e7\u00f5es pode-se citar o encoding de video em tempo real e an\u00e1lise de risco financeiro. Custos \u00b6 A inst\u00e2ncia de desenvolvimento m5.xlarge custa US 0.1920 por hora. E a inst\u00e2ncia f1.2xlarge custa US 0.1920 por hora. E a inst\u00e2ncia f1.2xlarge custa US 1.65 por hora. A implementa\u00e7\u00e3o deste exemplo \u00e9 estimada consumir por volta de 3hrs da inst\u00e2ncia de desenvolvimento e meia hora da inst\u00e2ncia F1. Totalizando US$1.5. Passo a passo \u00b6 Refer\u00eancias \u00b6 https://aws.amazon.com/pt/ec2/instance-types/f1/ https://github.com/aws/aws-fpga/blob/master/SDAccel/README.md#overview https://github.com/Xilinx/SDAccel_Examples/tree/a41b58921188ad90ace2d34a22a2513d8f74b549/getting_started/host/helloworld_ocl/src Pr\u00e9-requisitos \u00b6 Pr\u00e9-requisitos: Ter uma conta na AWS com acesso ao EC2 e S3. Configurando a AWS \u00b6 Em seu computador, baixe a CLI da AWS configure suas credenciais: $ aws configure Inst\u00e2ncia de desenvolvedor \u00b6 Para criar a inst\u00e2ncia de desenvolvimento, clique em Launch Instance e: - Utilize a AMI chamada \u201cFPGA Developer AMI\u201d. - Utilize o flavor m5.xlarge ou m5.2xlarge (quanto mais n\u00facleos e mem\u00f3ria, mais r\u00e1pido ser\u00e1 a compilac\u00e3o). - Crie e salve sua Keypair. Bucket setup \u00b6 Para utilizar a imagem compilada da F1, \u00e9 necess\u00e1rio salv\u00e1-la em um bucket, permitindo o seu acesso pelo servi\u00e7o EC2. O bucket e suas pastas podem ser criados manualmente pela dashboard ou pela CLI: $ aws s3 mb s3://embarcados-f1-tutorial --region us-east-1 $ touch FILES_GO_HERE.txt $ aws s3 cp FILES_GO_HERE.txt s3://embarcados-f1-tutorial/files/ $ touch LOGS_FILES_GO_HERE.txt $ aws s3 cp LOGS_FILES_GO_HERE.txt s3://embarcados-f1-tutorial/logs/ Setting up the dev house \u00b6 Acesse a inst\u00e2ncia de desenvolvimento: ssh -i \"<sua-keypair>.pem\" <ip-da-m\u00e1quina> Dentro da inst\u00e2ncia, clone o reposit\u00f3rio, instale os drivers e bibliotecas necess\u00e1rias e determine a plataforma de desenvolvimento: $ git clone https://github.com/aws/aws-fpga.git $AWS_FPGA_REPO_DIR $ cd $AWS_FPGA_REPO_DIR $ source sdaccel_setup.sh $ export AWS_PLATFORM = $AWS_PLATFORM_DYNAMIC_5_0 Acesse a pasta do exemplo no diret\u00f3rio: $ cd $SDACCEL_DIR/examples/xilinx/getting_started/host/helloworld_ocl/ Hora de compilar? N\u00c3O Check up \u00b6 A compila\u00e7\u00e3o do programa demora 2h06min. J\u00e1 imaginou desenvolver algo e cada vez que quiser testar ter que esperar 2h? E por isso que existem o emulador de software, que realiza uma r\u00e1pida compila\u00e7\u00e3o e executa nos ciclos da CPU. E o emulador de hardware, que invoca o simulador de hardware do ambiente SDAccel e testa a funcionalidade do c\u00f3digo a ser executado na FPGA. Para emular o software: $ make clean $ make check TARGETS = sw_emu DEVICES = $AWS_PLATFORM all Para emular o hardware: $ make clean $ make check TARGETS = hw_emu DEVICES = $AWS_PLATFORM all Compilando! \u00b6 O ambiente SDAccel tamb\u00e9m permite que o desenvolvedor compile tanto o bin\u00e1rio da placa FPGA, quanto a aplica\u00e7\u00e3o host. Isso \u00e9 feito por meio do mesmo Makefile: $ make clean $ make TARGETS = hw DEVICES = $AWS_PLATFORM all A compila\u00e7\u00e3o gera o arquivo bin\u00e1rio para a FPGA Xilinx (*.xclbin) e o execut\u00e1vel do programa host (exe), no nosso caso: helloworld . Cria\u00e7\u00e3o da Amazon FPGA Image (AFI) \u00b6 Agora, \u00e9 preciso gerar uma imagem FPGA que ser\u00e1 inserida na placa presente na PCI da inst\u00e2ncia. O script abaixo salva o kernel da FPGA no bucket, cria a AMI no servidor da AWS e salva um arquivo de metadados com informa\u00e7\u00f5es da imagem ( *.awsxclbin ), que tamb\u00e9m pode ser vistas no arquivo *_afi_id.txt . $ $SDACCEL_DIR /tools/create_sdaccel_afi.sh -xclbin = xclbin/vector_addition.hw.xilinx_aws-vu9p-f1-04261818_dynamic_5_0.xclbin -o = vector_addition.hw.xilinx_aws-vu9p-f1-04261818_dynamic_5_0 \\ -s3_bucket = embarcados-f1-tutorial -s3_dcp_key = files -s3_logs_key = logs A cria\u00e7\u00e3o da imagem n\u00e3o \u00e9 imediata, seu processo demora e pode ser acompanhado pela CLI da AWS: aws ec2 describe-fpga-images --fpga-image-ids <AFI ID ( eg: afi-06d0ffc989feeea2a ) > Quando a cria\u00e7\u00e3o da imagem for conclu\u00edda, o output dever\u00e1 ser: ... \"State\": { \"Code\": \"available\" }, ... Caso o c\u00f3digo do status retorne como \"failed\", procure os logs em: s3://embarcados-f1-tutorial/logs/ Exportando o programa \u00b6 Os arquivos necess\u00e1rios para executar o exemplo na FPGA s\u00e3o: <nome-do-arquivo>.awsxclbin helloworld Portanto, copie-os para o bucket: $ aws s3 cp <nome-do-arquivo>.awsxclbin s3://embarcados-f1-tutorial/files/ $ aws s3 cp helloworld s3://embarcados-f1-tutorial/files/ Criando a inst\u00e2ncia F1 \u00b6 Para criar a inst\u00e2ncia F1, clique em Launch Instance e: Utilize a AMI chamada \u201cFPGA Developer AMI\u201d. Utilize o flavor f1.2xlarge. Crie e salve sua Keypair. Executando \u00b6 Acesse a inst\u00e2ncia F1 Repita o passo Setting up the dev house Acesse o diret\u00f3rio do reposit\u00f3rio cd $AWS_FPGA_REPO_DIR Copie os arquivos salvos no bucket: $ aws s3 cp s3://embarcados-f1-tutorial/files/<nome-do-arquivo>.awsxclbin ./ $ aws s3 cp s3://embarcados-f1-tutorial/files/helloworld ./ Certifique-se que todos os arquivos possam ser achados na raiz do resposit\u00f3rio $ sudo -E /bin/bash $ source $AWS_FPGA_REPO_DIR/sdaccel_runtime_setup.sh chmod +x helloworld ./helloworld Pronto! O programa host importou a imagem da FPGA do servi\u00e7o AMI da AWS, criou os buffers para fazer a transfer\u00eancia de dados, determinou os argumentos e inseriu todo o kernel na placa. Notes Adicionar log do resultado","title":"Martim F. Jos\u00e9 - FPGA na AWS"},{"location":"2019/Martim-F1/#martim-f-jose-fpga-na-aws","text":"Aluno: Martim Ferreira Jos\u00e9 Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: Ano: 2019 Hardware utilizado no tutorial Inst\u00e2ncia F1 na AWS","title":"Martim F. Jos\u00e9 - FPGA na AWS"},{"location":"2019/Martim-F1/#introducao","text":"A AWS disp\u00f5em de inst\u00e2ncias F1, que s\u00e3o m\u00e1quinas de alta performance que cont\u00e9m uma FPGA no barramento PCI, permitindo a execu\u00e7\u00e3o de programas acelerados por meio de hardware personalizado. Para executar um programa em uma FPGA na nuvem, \u00e9 preciso primeiro desenvolver, simular, depurar e compilar o c\u00f3digo. Tudo isso \u00e9 feito em uma inst\u00e2ncia de desenvolvimento, predefinida por uma AMI (Amazon Machine Image) fornecida pela AWS. Na inst\u00e2ncia de desenvolvedor, o programa \u00e9 compilado e \u00e9 gerada uma imagem para a FPGA Xilinx presente na inst\u00e2ncia F1. O programa a ser implementado na FPGA pode ser desenvolvido utilizando tr\u00eas ambientes de desenvolvimento diferentes, documentados a seguir: Development Environment Description Accelerator Language Software Defined Accelerator Development - SDAccel Development experience leverages an optimized compiler to allow easy new accelerator development or migration of existing C/C++/openCL, Verilog/VHDL to AWS FPGA instances C/C++/OpenCL, Verilog/VHDL (RTL) Hardware Accelerator Development - HDK Fully custom hardware development experience provides hardware developers with the tools required for developing AFIs for AWS FPGA instances Verilog/VHDL IP Integrator or High Level Synthesis (HLx) Graphical interface development experience for integrating IP and high level synthesis development Verilog/VHDL/C Pela facilidade e maior conhecimento de C++, opta-se pela escolha do ambiente SDAccel. Portando, o programa a ser implementado \u00e9 programado em sua maioria em C++ utilizando a arquitetura OpenCL, que \u00e9 amplamente utilizada na programa\u00e7\u00e3o de alto desempenho em diversas plataformas. Este tutorial faz a implementa\u00e7\u00e3o do exemplo Hello World, que consiste na adi\u00e7\u00e3o de dois vetores. O c\u00f3digo deste exemplo pode ser examinado a fundo no seguinte reposit\u00f3rio: https://github.com/Xilinx/SDAccel_Examples/tree/a41b58921188ad90ace2d34a22a2513d8f74b549/getting_started/host/helloworld_ocl No reposit\u00f3rio h\u00e1 dois arquivos na pasta src : host.cpp e vector_addition.cl , que correspondem ao programa da m\u00e1quina e ao kernel da FPGA, respectivamente. O arquivo host consiste em um programa C++ em que: S\u00e3o definidos tr\u00eas vetores: A, B e results. A placa Xilinx \u00e9 selecionada e adicionada para o contexto da execu\u00e7\u00e3o. O bin\u00e1rio do kernel \u00e9 carregado e adicionado para um programa Para migrar os dados entre host e device, s\u00e3o criados dois buffers de leitura referenciando A e B; E um buffer de escrita referenciando result. Os dados armazenados nos buffers de leitura s\u00e3o transferidos da mem\u00f3ria da m\u00e1quina para mem\u00f3ria da FPGA. O kernel \u00e9 extra\u00eddo do programa, os argumentos s\u00e3o determinados (result, A, B, tamanho) e ele \u00e9 lan\u00e7ado. Os resultados s\u00e3o requisitados da FPGA e armazenados no buffer de escrita. E por fim, o resultado recebido \u00e9 comparados com o resultado esperado. O arquivo do kernel consiste em uma fun\u00e7\u00e3o em OpenCL que: Recebe quatro argumentos (result, A, B, tamanho) Define os arrays A e B Percorre os arrays recebidos como argumento, populando os arrays declarados Percorre o tamanho das arrays escrevendo no buffer de escrita (result) a soma de A e B em cada \u00edndice.","title":"Introdu\u00e7\u00e3o"},{"location":"2019/Martim-F1/#aplicacoes","text":"As inst\u00e2ncias com FPGA s\u00e3o amplamente utilizadas em situa\u00e7\u00f5es em que h\u00e1 uma grande quantidade de dados e o processamento precisa ser feito com rapidez. O desenvolvimento de um hardware personalizado para executar um programa fornece um custo de computa\u00e7\u00e3o 30x melhor comparado com inst\u00e2ncias de CPU. Entre essas aplica\u00e7\u00f5es pode-se citar o encoding de video em tempo real e an\u00e1lise de risco financeiro.","title":"Aplica\u00e7\u00f5es"},{"location":"2019/Martim-F1/#custos","text":"A inst\u00e2ncia de desenvolvimento m5.xlarge custa US 0.1920 por hora. E a inst\u00e2ncia f1.2xlarge custa US 0.1920 por hora. E a inst\u00e2ncia f1.2xlarge custa US 1.65 por hora. A implementa\u00e7\u00e3o deste exemplo \u00e9 estimada consumir por volta de 3hrs da inst\u00e2ncia de desenvolvimento e meia hora da inst\u00e2ncia F1. Totalizando US$1.5.","title":"Custos"},{"location":"2019/Martim-F1/#passo-a-passo","text":"","title":"Passo a passo"},{"location":"2019/Martim-F1/#referencias","text":"https://aws.amazon.com/pt/ec2/instance-types/f1/ https://github.com/aws/aws-fpga/blob/master/SDAccel/README.md#overview https://github.com/Xilinx/SDAccel_Examples/tree/a41b58921188ad90ace2d34a22a2513d8f74b549/getting_started/host/helloworld_ocl/src","title":"Refer\u00eancias"},{"location":"2019/Martim-F1/#pre-requisitos","text":"Pr\u00e9-requisitos: Ter uma conta na AWS com acesso ao EC2 e S3.","title":"Pr\u00e9-requisitos"},{"location":"2019/Martim-F1/#configurando-a-aws","text":"Em seu computador, baixe a CLI da AWS configure suas credenciais: $ aws configure","title":"Configurando a AWS"},{"location":"2019/Martim-F1/#instancia-de-desenvolvedor","text":"Para criar a inst\u00e2ncia de desenvolvimento, clique em Launch Instance e: - Utilize a AMI chamada \u201cFPGA Developer AMI\u201d. - Utilize o flavor m5.xlarge ou m5.2xlarge (quanto mais n\u00facleos e mem\u00f3ria, mais r\u00e1pido ser\u00e1 a compilac\u00e3o). - Crie e salve sua Keypair.","title":"Inst\u00e2ncia de desenvolvedor"},{"location":"2019/Martim-F1/#bucket-setup","text":"Para utilizar a imagem compilada da F1, \u00e9 necess\u00e1rio salv\u00e1-la em um bucket, permitindo o seu acesso pelo servi\u00e7o EC2. O bucket e suas pastas podem ser criados manualmente pela dashboard ou pela CLI: $ aws s3 mb s3://embarcados-f1-tutorial --region us-east-1 $ touch FILES_GO_HERE.txt $ aws s3 cp FILES_GO_HERE.txt s3://embarcados-f1-tutorial/files/ $ touch LOGS_FILES_GO_HERE.txt $ aws s3 cp LOGS_FILES_GO_HERE.txt s3://embarcados-f1-tutorial/logs/","title":"Bucket setup"},{"location":"2019/Martim-F1/#setting-up-the-dev-house","text":"Acesse a inst\u00e2ncia de desenvolvimento: ssh -i \"<sua-keypair>.pem\" <ip-da-m\u00e1quina> Dentro da inst\u00e2ncia, clone o reposit\u00f3rio, instale os drivers e bibliotecas necess\u00e1rias e determine a plataforma de desenvolvimento: $ git clone https://github.com/aws/aws-fpga.git $AWS_FPGA_REPO_DIR $ cd $AWS_FPGA_REPO_DIR $ source sdaccel_setup.sh $ export AWS_PLATFORM = $AWS_PLATFORM_DYNAMIC_5_0 Acesse a pasta do exemplo no diret\u00f3rio: $ cd $SDACCEL_DIR/examples/xilinx/getting_started/host/helloworld_ocl/ Hora de compilar? N\u00c3O","title":"Setting up the dev house"},{"location":"2019/Martim-F1/#check-up","text":"A compila\u00e7\u00e3o do programa demora 2h06min. J\u00e1 imaginou desenvolver algo e cada vez que quiser testar ter que esperar 2h? E por isso que existem o emulador de software, que realiza uma r\u00e1pida compila\u00e7\u00e3o e executa nos ciclos da CPU. E o emulador de hardware, que invoca o simulador de hardware do ambiente SDAccel e testa a funcionalidade do c\u00f3digo a ser executado na FPGA. Para emular o software: $ make clean $ make check TARGETS = sw_emu DEVICES = $AWS_PLATFORM all Para emular o hardware: $ make clean $ make check TARGETS = hw_emu DEVICES = $AWS_PLATFORM all","title":"Check up"},{"location":"2019/Martim-F1/#compilando","text":"O ambiente SDAccel tamb\u00e9m permite que o desenvolvedor compile tanto o bin\u00e1rio da placa FPGA, quanto a aplica\u00e7\u00e3o host. Isso \u00e9 feito por meio do mesmo Makefile: $ make clean $ make TARGETS = hw DEVICES = $AWS_PLATFORM all A compila\u00e7\u00e3o gera o arquivo bin\u00e1rio para a FPGA Xilinx (*.xclbin) e o execut\u00e1vel do programa host (exe), no nosso caso: helloworld .","title":"Compilando!"},{"location":"2019/Martim-F1/#criacao-da-amazon-fpga-image-afi","text":"Agora, \u00e9 preciso gerar uma imagem FPGA que ser\u00e1 inserida na placa presente na PCI da inst\u00e2ncia. O script abaixo salva o kernel da FPGA no bucket, cria a AMI no servidor da AWS e salva um arquivo de metadados com informa\u00e7\u00f5es da imagem ( *.awsxclbin ), que tamb\u00e9m pode ser vistas no arquivo *_afi_id.txt . $ $SDACCEL_DIR /tools/create_sdaccel_afi.sh -xclbin = xclbin/vector_addition.hw.xilinx_aws-vu9p-f1-04261818_dynamic_5_0.xclbin -o = vector_addition.hw.xilinx_aws-vu9p-f1-04261818_dynamic_5_0 \\ -s3_bucket = embarcados-f1-tutorial -s3_dcp_key = files -s3_logs_key = logs A cria\u00e7\u00e3o da imagem n\u00e3o \u00e9 imediata, seu processo demora e pode ser acompanhado pela CLI da AWS: aws ec2 describe-fpga-images --fpga-image-ids <AFI ID ( eg: afi-06d0ffc989feeea2a ) > Quando a cria\u00e7\u00e3o da imagem for conclu\u00edda, o output dever\u00e1 ser: ... \"State\": { \"Code\": \"available\" }, ... Caso o c\u00f3digo do status retorne como \"failed\", procure os logs em: s3://embarcados-f1-tutorial/logs/","title":"Cria\u00e7\u00e3o da Amazon FPGA Image (AFI)"},{"location":"2019/Martim-F1/#exportando-o-programa","text":"Os arquivos necess\u00e1rios para executar o exemplo na FPGA s\u00e3o: <nome-do-arquivo>.awsxclbin helloworld Portanto, copie-os para o bucket: $ aws s3 cp <nome-do-arquivo>.awsxclbin s3://embarcados-f1-tutorial/files/ $ aws s3 cp helloworld s3://embarcados-f1-tutorial/files/","title":"Exportando o programa"},{"location":"2019/Martim-F1/#criando-a-instancia-f1","text":"Para criar a inst\u00e2ncia F1, clique em Launch Instance e: Utilize a AMI chamada \u201cFPGA Developer AMI\u201d. Utilize o flavor f1.2xlarge. Crie e salve sua Keypair.","title":"Criando a inst\u00e2ncia F1"},{"location":"2019/Martim-F1/#executando","text":"Acesse a inst\u00e2ncia F1 Repita o passo Setting up the dev house Acesse o diret\u00f3rio do reposit\u00f3rio cd $AWS_FPGA_REPO_DIR Copie os arquivos salvos no bucket: $ aws s3 cp s3://embarcados-f1-tutorial/files/<nome-do-arquivo>.awsxclbin ./ $ aws s3 cp s3://embarcados-f1-tutorial/files/helloworld ./ Certifique-se que todos os arquivos possam ser achados na raiz do resposit\u00f3rio $ sudo -E /bin/bash $ source $AWS_FPGA_REPO_DIR/sdaccel_runtime_setup.sh chmod +x helloworld ./helloworld Pronto! O programa host importou a imagem da FPGA do servi\u00e7o AMI da AWS, criou os buffers para fazer a transfer\u00eancia de dados, determinou os argumentos e inseriu todo o kernel na placa. Notes Adicionar log do resultado","title":"Executando"},{"location":"2019/Pedro-OpenCV/","text":"Pedro de la Pen\u00e3 - Jetson Nano GPU \u00b6 Aluno: Pedro de la Pen\u00e3 Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/pedrodelapena/TutorialEmbarcados Ano: 2019 Hardware utilizado no tutorial Jetson Nano C\u00e2mera raspberry pi Neste projeto iremos utilizar uma placa Jetson Nano para comparar a diferen\u00e7a no desempenho de um c\u00f3digo sendo executado em CPU VS GPU. Pr\u00e9 Requisitos \u00b6 Para seguir este tutorial, \u00e9 necess\u00e1rio: - Conex\u00e3o com a internet ; - Hardware : Jetson Nano; - Hardware : SD Card 16 GB OU 32 GB (prefer\u00edvel); - Hardware : Teclado e Mouse USB; - Hardware : Monitor com entrada HDMI; - Hardware : C\u00e2mera Raspberry Pi 2.1 OU C\u00e2mera USB; - Software : Baixar imagem https://developer.nvidia.com/jetson-nano-sd-card-image-r3221 Arquitetura da placa Jetson Nano \u00b6 A placa Jetson Nano possui uma GPU integrada al\u00e9m de sua CPU ARM Cortex-A57 Quad-Core, o que a faz ser muito utilizada em aplica\u00e7\u00f5es de processamento de imagens e tamb\u00e9m em Machine Learning com o uso de redes neurais. A lista completa de seus componentes e especifica\u00e7\u00f5es est\u00e1 a seguir: NVIDIA Tegra X1 SoC (GPU) \u00b6 A Jetson Nano possui um System On a Chip (SoC) Tegra X1 Maxell, frequentemente encontrado em tablets que s\u00e3o baseados no sistema Android. Este SoC possibilita o uso softwares como OpenGL, CUDA e tamb\u00e9m DirectX. Com um clock m\u00e1ximo de at\u00e9 1000 MHz, a GPU oferece 256 shader-cores e \u00e9 capaz de codificar v\u00eddeos em 30fps e decodificar em 60fps. Gravando um SDCard e inicializando o Linux \u00b6 Configurando o sistema operacional no SD card \u00b6 Ap\u00f3s realizar o download da imagem, conecte o SD card em um adaptador e ent\u00e3o no seu computador. Agora \u00e9 preciso extrair a imagem e copi\u00e1-la para o driver de maneira que o sistema operacional funcione. Para realizar o processo utilizando utilizando uma interface gr\u00e1fica, fa\u00e7a o dowload do Etcher . O processo de flashing \u00e9 um pouco demorado, levando cerca de 10-15 minutos. Voc\u00ea pode meditar um pouco ou ent\u00e3o pode ir dar uma volta e tomar um caf\u00e9! Caso voc\u00ea prefira realizar o processo de forma mais raiz , voc\u00ea tamb\u00e9m o pode fazer pela linha de comando. Para isto, descubra o nome e localiza\u00e7\u00e3o do seu flash drive com dmesg | tail . Ap\u00f3s encontrar o drive, extraia o arquivo para o SD card com o comando: $ /usr/bin/unzip -p ~/ [ LOCAL_DE_DOWNLOAD ] /jetson_nano_devkit_sd_card.zip $ sudo /bin/dd of = /dev/sd [ NOME_DO_DRIVE ] bs = 1M status = progress Ap\u00f3s finalizado o processo, remova o drive de seu computador. Inserindo o SD card na placa Jetson Nano \u00b6 A entrada do cart\u00e3o de mem\u00f3ria n\u00e3o \u00e9 muito vis\u00edvel para aqueles que est\u00e3o tendo o primeiro contato com a placa. Aqui h\u00e1 uma imagem para auxilia-lo(a) a encontrar a entrada do cart\u00e3o: Primeiro boot \u00b6 Com o cart\u00e3o de mem\u00f3ria j\u00e1 inserido, \u00e9 preciso conectar os cabos na placa. N\u00e3o h\u00e1 \"bot\u00e3o de ligar ou desligar\" na placa, e o boot come\u00e7a automaticamente quando o cabo de alimenta\u00e7\u00e3o (supply de 5V (USB) OU fonte) estiver conectado. Al\u00e9m disso, lembre-se que ser\u00e1 preciso conex\u00e3o com a internet para os pr\u00f3ximos passos . Ap\u00f3s inserir as configura\u00e7\u00f5es de formato de teclado, regi\u00e3o e informa\u00e7\u00f5es 'pessoais' do ambiente Linux, a placa reiniciar\u00e1 e ent\u00e3o estar\u00e1 pronta para uso. Para maior comodidade, recomenda-se que a suspens\u00e3o autom\u00e1tica e screen lock sejam desativadas em All Settings -> Brightness & Lock , dado que alguns downloads e instala\u00e7\u00f5es possam demorar um pouco . Atualizando libs e packages \u00b6 J\u00e1 que acabamos de configurar o sistema operacional, \u00e9 necess\u00e1rio executar os comandos sudo apt-get update e sudo apt-get upgrade . Configurando o ambiente Python \u00b6 Para instalar bibliotecas adicionais, \u00e9 preciso instalar o pip. Para isto, execude os comandos a seguir: $ wget https://bootstrap.pypa.io/get-pip.py $ sudo python3 get-pip.py Configurando o ambiente CUDA \u00b6 $ wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run $ sudo sh cuda_10.2.89_440.33.01_linux.run Configurando o Ambiente OpenCV \u00b6 Note Esse aqui demora... E MUITO! (~4 horas) Warning IMPORTANTE! Conecte um cooler \u00e0 placa e fa\u00e7a quest\u00e3o de utilizar a fonte de alimenta\u00e7\u00e3o normal em rela\u00e7\u00e3o \u00e0 USB para este processo, j\u00e1 que ele demanda MUITA pot\u00eancia e a placa atingir altas temperaturas, o que pode levar ao seu superaquecimento. Com o cooler instalado, rode as seguintes linhas de comando para instalar e compilar o OpenCV. E lembrando, \u00e9 uma looooooonga espera. $ wget https://github.com/AastaNV/JEP/blob/master/script/install_opencv4.1.1_Jetson.sh $ sudo sh install_opencv4.1.1_Jetson.sh $ export PYTHONPATH=/usr/local/python Ap\u00f3s realizada a build, abra um terminal python3 e rode o seguinte c\u00f3digo para testar o OpenCV: import cv2 print ( cv2 . getBuildInformation ()) A partir deste comando, \u00e9 possivel visualizar se o CUDA OpenCV est\u00e1 configurado, no campo NVIDIA CUDA Instala\u00e7\u00e3o Pytorch \u00b6 A biblioteca Pytorch possui fun\u00e7\u00f5es que tornam poss\u00edvel a utiliza\u00e7\u00e3o da GPU no ambiente Python. Esta biblioteca ser\u00e1 utilizada para fazer alguns testes e compara\u00e7\u00f5es mais para frente no tutorial. $ wget https://nvidia.box.com/shared/static/phqe92v26cbhqjohwtvxorrwnmrnfx1o.whl -O torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install numpy torch-1.3.0-cp36-cp36m-linux_aarch64.whl Caso algum erro de depend\u00eancia relacionado ao numpy ocorra, reinstale-o. $ sudo pip uninstall numpy $ pip3 install numpy --user CPU vs GPU \u00b6 A diferen\u00e7a no desempenho de certos c\u00f3digos executados em CPU ou GPU \u00e9 dada pela quantidade de c\u00e1lculos em paralelo que cada um dos hardwares consegue realizar. Dependendo da arquitetura dos hardwares, uma GPU pode executar centenas - ou at\u00e9 milhares - de vezes mais instru\u00e7\u00f5es por clock em rela\u00e7\u00e3o \u00e0 CPU. Por conta disto, GPUs s\u00e3o largamente utilizadas em processos que podem ser amplamente divididos e paralelizados em blocos, como \u00e9 o caso da multiplica\u00e7\u00e3o de matrizes com muitas linhas e colunas. O simples exemplo a seguir deixa evidente a diferen\u00e7a no desempenho. C\u00f3digo em CPU: import numpy as np import time x = np . random . rand ( 7000 , 16 ) y = np . random . rand ( 16 , 7000 ) start = time . time () z = np . matmul ( x , y ) end = time . time () print ( z ) print ( \" \\n Elapsed time CPU:\" , end - start , \"seconds\" ) C\u00f3digo em GPU: import torch import time x = torch . randn ( 7000 , 16 ) y = torch . randn ( 16 , 7000 ) start = time . time () z = torch . matmul ( x , y ) end = time . time () print ( z ) print ( \" \\n Elapsed time GPU:\" , end - start , \"seconds\" ) CUDA OpenCV \u00b6 A GPU tamb\u00e9m \u00e9 de fundamental uso em outras aplica\u00e7\u00f5es como a rederiza\u00e7\u00e3o de v\u00eddeos e imagens e tamb\u00e9m no treinamento de modelos de Machine Learning e redes neurais. Desta forma,a biblioteca OpenCV pode ser utilizada para realizar tais tarefas na GPU. Instala\u00e7\u00e3o da C\u00e2mera \u00b6 Caso esteja utilizando uma c\u00e2mera USB, pule esta etapa. Com a Jetson Nano desligada de todas as fontes de energia e com a c\u00e2mera Raspberry Pi 2.1 (1.3 n\u00e3o funciona), levante a trava localzada em um dos cantos da placa, for\u00e7ando-a para cima. Em seguida, insira o conector da c\u00e2mera (com \"a parte azul voltada para fora\") e ent\u00e3o pressione a trava novamente para baixo. Testando a C\u00e2mera Raspberry Pi \u00b6 Ap\u00f3s conectada, teste a c\u00e2mera para checar se ela realmente est\u00e1 funcional com a seguinte linha de c\u00f3digo no terminal. $ gst-launch-1.0 nvarguscamerasrc ! 'video/x-raw(memory:NVMM),width=3820, height=2464, framerate=21/1, format=NV12' ! nvvidconv flip-method = 0 ! 'video/x-raw,width=960, height=616' ! nvvidconv ! nvegltransform ! nveglglessink -e Exemplo e compara\u00e7\u00e3o OpenCV vs OpenCV CUDA \u00b6 O c\u00f3digo \u00e0 seguir foi adaptado do Jetson Nano Hacks, sendo que o original pode ser encontrado neste link . Neste c\u00f3digo \u00e9 testada a diferen\u00e7a de desempenho da CPU em rela\u00e7\u00e3o \u00e0 GPU. import cv2 import time def gstreamer_pipeline ( capture_width = 640 , capture_height = 360 , display_width = 640 , display_height = 360 , framerate = 60 , flip_method = 0 , ): return ( \"nvarguscamerasrc ! \" \"video/x-raw(memory:NVMM), \" \"width=(int) %d , height=(int) %d , \" \"format=(string)NV12, framerate=(fraction) %d /1 ! \" \"nvvidconv flip-method= %d ! \" \"video/x-raw, width=(int) %d , height=(int) %d , format=(string)BGRx ! \" \"videoconvert ! \" \"video/x-raw, format=(string)BGR ! appsink\" % ( capture_width , capture_height , framerate , flip_method , display_width , display_height , ) ) def show_camera (): # To flip the image, modify the flip_method parameter (0 and 2 are the most common) print ( gstreamer_pipeline ( flip_method = 0 )) cap = cv2 . VideoCapture ( gstreamer_pipeline ( flip_method = 0 ), cv2 . CAP_GSTREAMER ) if cap . isOpened (): window_handle = cv2 . namedWindow ( \"CSI Camera\" , cv2 . WINDOW_AUTOSIZE ) # Window while cv2 . getWindowProperty ( \"CSI Camera\" , 0 ) >= 0 : ret_val , img = cap . read (); start = time . time () #Alterar aqui para \"c2.cuda.flip()\" ou \"cv2.flip()\" img2 = cv2 . cuda . flip ( img , 1 ) end = time . time () print ( \"Elapsed time\" , end - start ) cv2 . imshow ( \"CSI Camera\" , img2 ) keyCode = cv2 . waitKey ( 30 ) & 0xFF # Stop the program on the ESC key if keyCode == 27 : break cap . release () cv2 . destroyAllWindows () else : print ( \"Unable to open camera\" ) if __name__ == \"__main__\" : show_camera () Neste caso, devido ao fato de ser uma simples altera\u00e7\u00e3o na imagem como um flip , o programa demora mais para enviar a imagem para a GPU que realizar todo o processo na CPU. Contudo, com mais processos e opera\u00e7\u00f5es, o ganho de desempenho da GPU fica evidente. Al\u00e9m disso, para descobrir todas as fun\u00e7\u00f5es do m\u00f3dulo CUDA, abra um terminal Python3 e insira a linha dir(cv2.cuda) .","title":"Pedro de la Pen\u00e3 - Jetson Nano GPU"},{"location":"2019/Pedro-OpenCV/#pedro-de-la-pena-jetson-nano-gpu","text":"Aluno: Pedro de la Pen\u00e3 Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 9 Contato: Link tutorial oficial: https://github.com/pedrodelapena/TutorialEmbarcados Ano: 2019 Hardware utilizado no tutorial Jetson Nano C\u00e2mera raspberry pi Neste projeto iremos utilizar uma placa Jetson Nano para comparar a diferen\u00e7a no desempenho de um c\u00f3digo sendo executado em CPU VS GPU.","title":"Pedro de la Pen\u00e3 - Jetson Nano GPU"},{"location":"2019/Pedro-OpenCV/#pre-requisitos","text":"Para seguir este tutorial, \u00e9 necess\u00e1rio: - Conex\u00e3o com a internet ; - Hardware : Jetson Nano; - Hardware : SD Card 16 GB OU 32 GB (prefer\u00edvel); - Hardware : Teclado e Mouse USB; - Hardware : Monitor com entrada HDMI; - Hardware : C\u00e2mera Raspberry Pi 2.1 OU C\u00e2mera USB; - Software : Baixar imagem https://developer.nvidia.com/jetson-nano-sd-card-image-r3221","title":"Pr\u00e9 Requisitos"},{"location":"2019/Pedro-OpenCV/#arquitetura-da-placa-jetson-nano","text":"A placa Jetson Nano possui uma GPU integrada al\u00e9m de sua CPU ARM Cortex-A57 Quad-Core, o que a faz ser muito utilizada em aplica\u00e7\u00f5es de processamento de imagens e tamb\u00e9m em Machine Learning com o uso de redes neurais. A lista completa de seus componentes e especifica\u00e7\u00f5es est\u00e1 a seguir:","title":"Arquitetura da placa Jetson Nano"},{"location":"2019/Pedro-OpenCV/#nvidia-tegra-x1-soc-gpu","text":"A Jetson Nano possui um System On a Chip (SoC) Tegra X1 Maxell, frequentemente encontrado em tablets que s\u00e3o baseados no sistema Android. Este SoC possibilita o uso softwares como OpenGL, CUDA e tamb\u00e9m DirectX. Com um clock m\u00e1ximo de at\u00e9 1000 MHz, a GPU oferece 256 shader-cores e \u00e9 capaz de codificar v\u00eddeos em 30fps e decodificar em 60fps.","title":"NVIDIA Tegra X1 SoC (GPU)"},{"location":"2019/Pedro-OpenCV/#gravando-um-sdcard-e-inicializando-o-linux","text":"","title":"Gravando um SDCard e inicializando o Linux"},{"location":"2019/Pedro-OpenCV/#configurando-o-sistema-operacional-no-sd-card","text":"Ap\u00f3s realizar o download da imagem, conecte o SD card em um adaptador e ent\u00e3o no seu computador. Agora \u00e9 preciso extrair a imagem e copi\u00e1-la para o driver de maneira que o sistema operacional funcione. Para realizar o processo utilizando utilizando uma interface gr\u00e1fica, fa\u00e7a o dowload do Etcher . O processo de flashing \u00e9 um pouco demorado, levando cerca de 10-15 minutos. Voc\u00ea pode meditar um pouco ou ent\u00e3o pode ir dar uma volta e tomar um caf\u00e9! Caso voc\u00ea prefira realizar o processo de forma mais raiz , voc\u00ea tamb\u00e9m o pode fazer pela linha de comando. Para isto, descubra o nome e localiza\u00e7\u00e3o do seu flash drive com dmesg | tail . Ap\u00f3s encontrar o drive, extraia o arquivo para o SD card com o comando: $ /usr/bin/unzip -p ~/ [ LOCAL_DE_DOWNLOAD ] /jetson_nano_devkit_sd_card.zip $ sudo /bin/dd of = /dev/sd [ NOME_DO_DRIVE ] bs = 1M status = progress Ap\u00f3s finalizado o processo, remova o drive de seu computador.","title":"Configurando o sistema operacional no SD card"},{"location":"2019/Pedro-OpenCV/#inserindo-o-sd-card-na-placa-jetson-nano","text":"A entrada do cart\u00e3o de mem\u00f3ria n\u00e3o \u00e9 muito vis\u00edvel para aqueles que est\u00e3o tendo o primeiro contato com a placa. Aqui h\u00e1 uma imagem para auxilia-lo(a) a encontrar a entrada do cart\u00e3o:","title":"Inserindo o SD card na placa Jetson Nano"},{"location":"2019/Pedro-OpenCV/#primeiro-boot","text":"Com o cart\u00e3o de mem\u00f3ria j\u00e1 inserido, \u00e9 preciso conectar os cabos na placa. N\u00e3o h\u00e1 \"bot\u00e3o de ligar ou desligar\" na placa, e o boot come\u00e7a automaticamente quando o cabo de alimenta\u00e7\u00e3o (supply de 5V (USB) OU fonte) estiver conectado. Al\u00e9m disso, lembre-se que ser\u00e1 preciso conex\u00e3o com a internet para os pr\u00f3ximos passos . Ap\u00f3s inserir as configura\u00e7\u00f5es de formato de teclado, regi\u00e3o e informa\u00e7\u00f5es 'pessoais' do ambiente Linux, a placa reiniciar\u00e1 e ent\u00e3o estar\u00e1 pronta para uso. Para maior comodidade, recomenda-se que a suspens\u00e3o autom\u00e1tica e screen lock sejam desativadas em All Settings -> Brightness & Lock , dado que alguns downloads e instala\u00e7\u00f5es possam demorar um pouco .","title":"Primeiro boot"},{"location":"2019/Pedro-OpenCV/#atualizando-libs-e-packages","text":"J\u00e1 que acabamos de configurar o sistema operacional, \u00e9 necess\u00e1rio executar os comandos sudo apt-get update e sudo apt-get upgrade .","title":"Atualizando libs e packages"},{"location":"2019/Pedro-OpenCV/#configurando-o-ambiente-python","text":"Para instalar bibliotecas adicionais, \u00e9 preciso instalar o pip. Para isto, execude os comandos a seguir: $ wget https://bootstrap.pypa.io/get-pip.py $ sudo python3 get-pip.py","title":"Configurando o ambiente Python"},{"location":"2019/Pedro-OpenCV/#configurando-o-ambiente-cuda","text":"$ wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run $ sudo sh cuda_10.2.89_440.33.01_linux.run","title":"Configurando o ambiente CUDA"},{"location":"2019/Pedro-OpenCV/#configurando-o-ambiente-opencv","text":"Note Esse aqui demora... E MUITO! (~4 horas) Warning IMPORTANTE! Conecte um cooler \u00e0 placa e fa\u00e7a quest\u00e3o de utilizar a fonte de alimenta\u00e7\u00e3o normal em rela\u00e7\u00e3o \u00e0 USB para este processo, j\u00e1 que ele demanda MUITA pot\u00eancia e a placa atingir altas temperaturas, o que pode levar ao seu superaquecimento. Com o cooler instalado, rode as seguintes linhas de comando para instalar e compilar o OpenCV. E lembrando, \u00e9 uma looooooonga espera. $ wget https://github.com/AastaNV/JEP/blob/master/script/install_opencv4.1.1_Jetson.sh $ sudo sh install_opencv4.1.1_Jetson.sh $ export PYTHONPATH=/usr/local/python Ap\u00f3s realizada a build, abra um terminal python3 e rode o seguinte c\u00f3digo para testar o OpenCV: import cv2 print ( cv2 . getBuildInformation ()) A partir deste comando, \u00e9 possivel visualizar se o CUDA OpenCV est\u00e1 configurado, no campo NVIDIA CUDA","title":"Configurando o Ambiente OpenCV"},{"location":"2019/Pedro-OpenCV/#instalacao-pytorch","text":"A biblioteca Pytorch possui fun\u00e7\u00f5es que tornam poss\u00edvel a utiliza\u00e7\u00e3o da GPU no ambiente Python. Esta biblioteca ser\u00e1 utilizada para fazer alguns testes e compara\u00e7\u00f5es mais para frente no tutorial. $ wget https://nvidia.box.com/shared/static/phqe92v26cbhqjohwtvxorrwnmrnfx1o.whl -O torch-1.3.0-cp36-cp36m-linux_aarch64.whl $ pip3 install numpy torch-1.3.0-cp36-cp36m-linux_aarch64.whl Caso algum erro de depend\u00eancia relacionado ao numpy ocorra, reinstale-o. $ sudo pip uninstall numpy $ pip3 install numpy --user","title":"Instala\u00e7\u00e3o Pytorch"},{"location":"2019/Pedro-OpenCV/#cpu-vs-gpu","text":"A diferen\u00e7a no desempenho de certos c\u00f3digos executados em CPU ou GPU \u00e9 dada pela quantidade de c\u00e1lculos em paralelo que cada um dos hardwares consegue realizar. Dependendo da arquitetura dos hardwares, uma GPU pode executar centenas - ou at\u00e9 milhares - de vezes mais instru\u00e7\u00f5es por clock em rela\u00e7\u00e3o \u00e0 CPU. Por conta disto, GPUs s\u00e3o largamente utilizadas em processos que podem ser amplamente divididos e paralelizados em blocos, como \u00e9 o caso da multiplica\u00e7\u00e3o de matrizes com muitas linhas e colunas. O simples exemplo a seguir deixa evidente a diferen\u00e7a no desempenho. C\u00f3digo em CPU: import numpy as np import time x = np . random . rand ( 7000 , 16 ) y = np . random . rand ( 16 , 7000 ) start = time . time () z = np . matmul ( x , y ) end = time . time () print ( z ) print ( \" \\n Elapsed time CPU:\" , end - start , \"seconds\" ) C\u00f3digo em GPU: import torch import time x = torch . randn ( 7000 , 16 ) y = torch . randn ( 16 , 7000 ) start = time . time () z = torch . matmul ( x , y ) end = time . time () print ( z ) print ( \" \\n Elapsed time GPU:\" , end - start , \"seconds\" )","title":"CPU vs GPU"},{"location":"2019/Pedro-OpenCV/#cuda-opencv","text":"A GPU tamb\u00e9m \u00e9 de fundamental uso em outras aplica\u00e7\u00f5es como a rederiza\u00e7\u00e3o de v\u00eddeos e imagens e tamb\u00e9m no treinamento de modelos de Machine Learning e redes neurais. Desta forma,a biblioteca OpenCV pode ser utilizada para realizar tais tarefas na GPU.","title":"CUDA OpenCV"},{"location":"2019/Pedro-OpenCV/#instalacao-da-camera","text":"Caso esteja utilizando uma c\u00e2mera USB, pule esta etapa. Com a Jetson Nano desligada de todas as fontes de energia e com a c\u00e2mera Raspberry Pi 2.1 (1.3 n\u00e3o funciona), levante a trava localzada em um dos cantos da placa, for\u00e7ando-a para cima. Em seguida, insira o conector da c\u00e2mera (com \"a parte azul voltada para fora\") e ent\u00e3o pressione a trava novamente para baixo.","title":"Instala\u00e7\u00e3o da C\u00e2mera"},{"location":"2019/Pedro-OpenCV/#testando-a-camera-raspberry-pi","text":"Ap\u00f3s conectada, teste a c\u00e2mera para checar se ela realmente est\u00e1 funcional com a seguinte linha de c\u00f3digo no terminal. $ gst-launch-1.0 nvarguscamerasrc ! 'video/x-raw(memory:NVMM),width=3820, height=2464, framerate=21/1, format=NV12' ! nvvidconv flip-method = 0 ! 'video/x-raw,width=960, height=616' ! nvvidconv ! nvegltransform ! nveglglessink -e","title":"Testando a C\u00e2mera Raspberry Pi"},{"location":"2019/Pedro-OpenCV/#exemplo-e-comparacao-opencv-vs-opencv-cuda","text":"O c\u00f3digo \u00e0 seguir foi adaptado do Jetson Nano Hacks, sendo que o original pode ser encontrado neste link . Neste c\u00f3digo \u00e9 testada a diferen\u00e7a de desempenho da CPU em rela\u00e7\u00e3o \u00e0 GPU. import cv2 import time def gstreamer_pipeline ( capture_width = 640 , capture_height = 360 , display_width = 640 , display_height = 360 , framerate = 60 , flip_method = 0 , ): return ( \"nvarguscamerasrc ! \" \"video/x-raw(memory:NVMM), \" \"width=(int) %d , height=(int) %d , \" \"format=(string)NV12, framerate=(fraction) %d /1 ! \" \"nvvidconv flip-method= %d ! \" \"video/x-raw, width=(int) %d , height=(int) %d , format=(string)BGRx ! \" \"videoconvert ! \" \"video/x-raw, format=(string)BGR ! appsink\" % ( capture_width , capture_height , framerate , flip_method , display_width , display_height , ) ) def show_camera (): # To flip the image, modify the flip_method parameter (0 and 2 are the most common) print ( gstreamer_pipeline ( flip_method = 0 )) cap = cv2 . VideoCapture ( gstreamer_pipeline ( flip_method = 0 ), cv2 . CAP_GSTREAMER ) if cap . isOpened (): window_handle = cv2 . namedWindow ( \"CSI Camera\" , cv2 . WINDOW_AUTOSIZE ) # Window while cv2 . getWindowProperty ( \"CSI Camera\" , 0 ) >= 0 : ret_val , img = cap . read (); start = time . time () #Alterar aqui para \"c2.cuda.flip()\" ou \"cv2.flip()\" img2 = cv2 . cuda . flip ( img , 1 ) end = time . time () print ( \"Elapsed time\" , end - start ) cv2 . imshow ( \"CSI Camera\" , img2 ) keyCode = cv2 . waitKey ( 30 ) & 0xFF # Stop the program on the ESC key if keyCode == 27 : break cap . release () cv2 . destroyAllWindows () else : print ( \"Unable to open camera\" ) if __name__ == \"__main__\" : show_camera () Neste caso, devido ao fato de ser uma simples altera\u00e7\u00e3o na imagem como um flip , o programa demora mais para enviar a imagem para a GPU que realizar todo o processo na CPU. Contudo, com mais processos e opera\u00e7\u00f5es, o ganho de desempenho da GPU fica evidente. Al\u00e9m disso, para descobrir todas as fun\u00e7\u00f5es do m\u00f3dulo CUDA, abra um terminal Python3 e insira a linha dir(cv2.cuda) .","title":"Exemplo e compara\u00e7\u00e3o OpenCV vs OpenCV CUDA"},{"location":"2019/Toranja-DevDriver/","text":"Bruno Toranja - Linux Device Driver \u00b6 Aluno: Bruno Toranja Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 7 Contato: Link tutorial oficial: https://github.com/brunoartc/virtual_com_driver Ano: 2019 Hardware utilizado no tutorial ? Introdu\u00e7\u00e3o \u00b6 Um driver de linux \u00e9 um programa que facilita a comunica\u00e7\u00e3o dos programas com a parte fisica do nosso dispositivo 1. Kernel space e user space \u00b6 Para entendermos como isso funciona primeiro temos que entender o que significam os programas e o kernel Os programas rodam em uma parte especial da nossa memoria chamada de espa\u00e7o de usuario, como por exemplo o python ou ate mesmo um bash, esses programas normalmente n\u00e3o precisam acessar itens de mais baixo nivel como por exemplo acesso direto a memoria ou portas UBS por exemplo. Essas tarefas sao executadas pelo kernel space que sabe lidar com o nosso hardware de uma maneira eficiente disponibilizando um tipo \"API\" para o user space lidar isso , e esse \u00e9 o trabalho dos drivers, a parte da tradu\u00e7\u00e3o dos comandos de usuario para que o kernel execute. 2. Como o driver conversa com o computador \u00b6 Os programas localizados no user space tem um momento especifico para pedir coisas para o kernel sobre o hardware como eh o caso de exploradores de arquivos e comunica\u00e7\u00e3o serial, caso algum desses programas queira se comunicar com um acessorio que n\u00e3o tenha seu proprio driver, temos um problema pois esse n\u00e3o conseguira ser comunicado Entao temos outra op\u00e7\u00e3o para isso, desenvolver nosso proprio driver, para ser compilado juntamente com o kernel e vir juntamente com ele, ou um simples modulo que \u00e9 compilado a parte e depois carregado no linux a partir do user space que ensinaremos nesse tutorial 3. cria\u00e7\u00e3o do modulo basico \u00b6 O nosso modulo precisa ser criado em alguma linguagem que o kernel do linux entenda, por isso utilizaremos o C a. Estrutura\u00e7\u00e3o de um modulo \u00b6 Primeiramente precisamo incluir a biblioteca de modulos do linux, para faremos um novo arquivo chamado de tcom.c touch tcom.c precisamos adicionar os headers no nosso arquivo tambem nano tcom.c dentro do arquivo temos que adicionar as duas linhas de bibliotecas para que possamos usar as fun\u00e7\u00f5es que conversam com o kernel alem de poder usar seus macros #include <linux/init.h> #include <linux/module.h> Com as bibliotecas importadas podemos come\u00e7ar o nosso codigo como por exemplo fazer dizer o que nosso driver far\u00e1 ao ser carregado e descarregado. Essas fun\u00e7\u00f5es tem um padr\u00e3o para se seguir em que a fun\u00e7\u00e3o de inicializa\u00e7\u00e3o retorna um inteiro e o exit nao retorna nada como mostrado acima referencia no linux static int init_com ( void ) { return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); essas duas funcoes podem ser chamadas pelas macros module_init e module_exit, que vao ser chamados no momento de inicio do modulo e saida do modulo referencia no linux tem tambem muitas outra op\u00e7\u00f5es para definir o autor do m\u00f3dulo e ate mesmo a licensa dele, mas nao entraremos em muitos detalhes b. Funcionalidades do modulo \u00b6 Podemos por exemplo fazer um driver que simplesmente mande um Hello World para o kernel quando ele \u00e9 inicializado para isso semelhante a um programa em C utilizaremos uma fun\u00e7\u00e3o print precisamos importar mais uma biblioteca para que essa fun\u00e7\u00e3o fique disponivel #include <linux/kernel.h> com essa func\u00e3o importada temos acesso ao printk uma fun\u00e7\u00e3o que printa ao log do kernel Ate agora temos um programa assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> static int init_com ( void ) { printk ( \" \\n Hello World \\n \" ); return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); c. Compilando o modulo \u00b6 podemos entao compilar o nosso programa usando uma Makefile contendo obj-m := tcom.o usamos tambem por padrao o lib modules do nosso sistema que esta localizado em /lib/modules/$(uname -r)/build se for testar no seu linux deixe /lib/modules/$(uname -r)/build ou podemos gerar nosso proprio com um kernel do linux make modules_install INSTALL_MOD_PATH = /some/root/folder ou simplesmente dentro da sua pasta do linux make modules usando make -C /path/para/source/linux M = ` pwd ` modules para compilar ou use Makefile no repo d. Carregando o modulo e verificando \u00b6 com isso teremos um arquivo .ko que para todos os fins \u00e9 o nosso driver, este pode ser carregado e descarregado usando insmod e rmmod respectivamente como uma simples demosntra\u00e7\u00e3o podemos abrir um terminal e observar os logs do linux tail -f /var/log/kern.log enquanto em outro terminal compilamos o modulo e carregamos ele make -C /path/para/source/linux M = ` pwd ` modules sudo insmod ./tcom.ko sudo rmmod ./tcom.ko depois de executar esses comandos no linux voltamos ao nosso terminal que esta acompanhando o log do kernel e vemos que com sucesso obtivemos a mensagem kernel: [666.1337] Hello World Com isso temos a nossa primeira implementacao de um driver que simplesmesnte sobe uma mensagem para o kernel 4. cria\u00e7\u00e3o do modulo com funcionalidade (comunica\u00e7\u00e3o char) \u00b6 a. Adicionar novas funcionalidades \u00b6 Agora precisamos dar alguma funcionalidade para o nosso driver, como por exemplo interfacear com o hardware para simplesmente receber mensagens Como tudo no linux precisamos abrir um arquivo para fazer a comunicacao com o kernel space e este fazer a comunicacao com o hardware, para isso precisamos importar mais algumas bibliotecas /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ /* acessar o user space */ #include <asm/uaccess.h> com esses includes novos podemos trabalhar com algumas funcoes mais avancadas da criacao de drivers e dar mais um passo ao nosso vriver que interpreta mensagens do hardware fisico mas ainda preisamos fazer as funcoes que permitem que nosso driver funcione, no caso para excrever e ler apenas um char. b. Adicionar a rela\u00e7\u00e3o do driver com o hardware \u00b6 comecaremos declarando qual a regiao de memoria que iremos acessar com o numero de identifica\u00e7\u00e3o do driver para ele acessar os perifericos que utilizam desse driver /* o numero da versao do nosso driver */ int memory_major = 60 ; /* onde nossa memoria vai ser salva*/ char * memory_buffer ; c. Fun\u00e7\u00f5es de inicializa\u00e7\u00e3o de memoria \u00b6 temos tambem que mudar nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o para que quando o driver se inicialize ele aloque um espa\u00e7o de memoria que ser\u00e1 usado, assim como um programa em C, sua libera\u00e7\u00e3o tambem deve ser criada, nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o e saida deve ser mais ou menos assim int memory_init ( void ) { int result ; /* Registrar o nosso driver para os hardwares certos */ result = register_chrdev ( memory_major , \"memory\" , & memory_fops ); /* Alocar o espa\u00e7o de memoria para o programa*/ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; memory_exit (); return result ; } memset ( memory_buffer , 0 , 1 ); printk ( \"<1>Driver simples de memoria inicializado \\n \" ); return 0 ; } void memory_exit ( void ) { /* Liberando o numero de registro no sistema*/ unregister_chrdev ( memory_major , \"memory\" ); /* Liberando o espa\u00e7o de memoria */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Liberando memorias e descarregando modulo \\n \" ); } d. Fun\u00e7\u00f5es para manipula\u00e7\u00e3o de memoria \u00b6 temos agora uma parte do nosso programa para iniciar e liberar espa\u00e7os de memoria que podemos trabalhar, mas nosso driver ainda nao executa nenhuma fun\u00e7\u00e3o para isso faremos uma funcao que abre o nosso \"arquivo\" e uma que deixa nosso arquivo disponivel para outros programas apos a execu\u00e7\u00e3o da primeira int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } agora tambem precisamos que apos abrir o local de memoria do nosso driver nos possamos ler e escrever nele podemos fazer isso com uma fun\u00e7\u00e3o que copia do buffer para a nossa memoria e vice-versa ssize_t memory_read ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { /* Transfering data to user space */ copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } ssize_t memory_write ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count - 1 ; copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } ate agora fizemos um modulo para o nosso proprio linux mas podemos tambem fazer a compila\u00e7\u00e3o de um modulo para um dispositivo ARM embarcado simplesmente mudando algumas linhas do nosso Makefile export CROSS_COMPILE = export ARCH = x86_64 por export CROSS_COMPILE = gcc-arm-linux-gnueabi- export ARCH = arm agora que temos um driver simples que consegue compreender o que escrevemos e passar para um hardware virtual nosso podemos passar para coisas um pouco mais uteis e complexas como por exemplo controlar um led da placa, e \u00e9 isso que faremos nessa sess\u00e3o 5. driver que controla GPIO do raspberry \u00b6 primeiramente utilizaremos o outro codigo de esqueleto ele tem que estar mais ou menos assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> #include <asm/uaccess.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ int memory_major = 60 ; /* Buffer para guardar os dados */ char * memory_buffer ; static void finish_com ( void ) { /* liberando o numero de versao */ unregister_chrdev ( memory_major , \"memory\" ); /* liberando a memoria para outro programa */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Removing memory module \\n \" ); } int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } static ssize_t memory_read ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { /* Copia para o user space */ raw_copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } static ssize_t memory_write ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count - 1 ; raw_copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } static struct file_operations tcom_fops = { . owner = THIS_MODULE , . read = memory_read , . write = memory_write , . open = memory_open , . release = memory_release }; static int init_com ( void ) { int result ; /* registrando o driver */ register_chrdev ( memory_major , \"memory\" , & tcom_fops ); //TODO FIX NULL with pointer to file_operands /* alocar a memoria para o driver */ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; finish_com (); return result ; } memset ( memory_buffer , 0 , 1 ); return 0 ; } MODULE_LICENSE ( \"Dual BSD/GPL\" ); module_init ( init_com ); module_exit ( finish_com ); com esse codigo que fizemos na sessao anterior temos apensar que criar uma fun\u00e7\u00e3o que receba de input os nossos enderecos de memorias do pino e definir como os bits que precisam estar ligados como por exemplo vamos usar como base um raspbery e seus GPIOs ( https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf ) definimos primeiro a estrutura de um GPIO da rapberry como o exmplo abaixo struct GpioRegisters { uint32_t GPFSEL[6]; uint32_t Reserved1; uint32_t GPSET[2]; uint32_t Reserved2; uint32_t GPCLR[2]; }; struct GpioRegisters *s_pGpioRegisters; ent\u00e3o precisamos agora definir as funcoes para podermos fazer alguma coisa quando tivermos os registradores do raspberry para isso podemos utilizar das seguintes funcoes static void definirFuncaoDoGPIO ( int GPIO , int functionCode ) { int IndexRegistrador = GPIO / 10 ; int bit = ( GPIO % 10 ) * 3 ; unsigned oldValue = s_pGpioRegisters -> GPFSEL [ IndexRegistrador ]; unsigned mask = 0 b111 << bit ; s_pGpioRegisters -> GPFSEL [ IndexRegistrador ] = ( oldValue & ~ mask ) | (( functionCode << bit ) & mask ); } static void SetGPIOOutputValue ( int GPIO , bool outputValue ) { if ( outputValue ) s_pGpioRegisters -> GPSET [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); else s_pGpioRegisters -> GPCLR [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); } com essas funcoes para a manipula\u00e7\u00e3o das GPIOs do nosso raspberry podemos criar um timer que aciona elas em momentos distintos para deixar o pino escolhido como alto ou baixo e verificar com o nosso led Poderiamos usar timer mas por questoes de tempo so deixaremos um pino no estado alto e veremos o seu efeito e logo em seguida ao descarregarmos o driver ele voltara ao seu estado normal de input caso alguem queria tentera depois com a biblioteca de timers tambem deixo o codigo fonte da biblioteca para ser estudado aqui static int __init LedBlinkModule_init ( void ) { int result ; s_pGpioRegisters = ( struct GpioRegisters * ) __io_address ( GPIO_BASE ); SetGPIOFunction ( LedGpioPin , 0 b001 ); //Output SetGPIOOutputValue ( LedGpioPin , 1 ) } static void __exit LedBlinkModule_exit ( void ) { SetGPIOFunction ( LedGpioPin , 0 ); //Configure the pin as input del_timer ( & s_BlinkTimer ); } podedmos passar para algo mais avan\u00e7ado como \u00e9 o caso das interrup\u00e7\u00f5es, como ja temos um conhecimento geral de como sao feitos os drivers de linux podemos pular as etapas sobre a inicializa\u00e7\u00e3o e saida dos drivers bem como o Makefile e suas dependencias","title":"Bruno Toranja - Linux Device Driver"},{"location":"2019/Toranja-DevDriver/#bruno-toranja-linux-device-driver","text":"Aluno: Bruno Toranja Curso: Engenharia da Computa\u00e7\u00e3o Semestre: 7 Contato: Link tutorial oficial: https://github.com/brunoartc/virtual_com_driver Ano: 2019 Hardware utilizado no tutorial ?","title":"Bruno Toranja - Linux Device Driver"},{"location":"2019/Toranja-DevDriver/#introducao","text":"Um driver de linux \u00e9 um programa que facilita a comunica\u00e7\u00e3o dos programas com a parte fisica do nosso dispositivo","title":"Introdu\u00e7\u00e3o"},{"location":"2019/Toranja-DevDriver/#1-kernel-space-e-user-space","text":"Para entendermos como isso funciona primeiro temos que entender o que significam os programas e o kernel Os programas rodam em uma parte especial da nossa memoria chamada de espa\u00e7o de usuario, como por exemplo o python ou ate mesmo um bash, esses programas normalmente n\u00e3o precisam acessar itens de mais baixo nivel como por exemplo acesso direto a memoria ou portas UBS por exemplo. Essas tarefas sao executadas pelo kernel space que sabe lidar com o nosso hardware de uma maneira eficiente disponibilizando um tipo \"API\" para o user space lidar isso , e esse \u00e9 o trabalho dos drivers, a parte da tradu\u00e7\u00e3o dos comandos de usuario para que o kernel execute.","title":"1. Kernel space e user space"},{"location":"2019/Toranja-DevDriver/#2-como-o-driver-conversa-com-o-computador","text":"Os programas localizados no user space tem um momento especifico para pedir coisas para o kernel sobre o hardware como eh o caso de exploradores de arquivos e comunica\u00e7\u00e3o serial, caso algum desses programas queira se comunicar com um acessorio que n\u00e3o tenha seu proprio driver, temos um problema pois esse n\u00e3o conseguira ser comunicado Entao temos outra op\u00e7\u00e3o para isso, desenvolver nosso proprio driver, para ser compilado juntamente com o kernel e vir juntamente com ele, ou um simples modulo que \u00e9 compilado a parte e depois carregado no linux a partir do user space que ensinaremos nesse tutorial","title":"2. Como o driver conversa com o computador"},{"location":"2019/Toranja-DevDriver/#3-criacao-do-modulo-basico","text":"O nosso modulo precisa ser criado em alguma linguagem que o kernel do linux entenda, por isso utilizaremos o C","title":"3. cria\u00e7\u00e3o do modulo basico"},{"location":"2019/Toranja-DevDriver/#a-estruturacao-de-um-modulo","text":"Primeiramente precisamo incluir a biblioteca de modulos do linux, para faremos um novo arquivo chamado de tcom.c touch tcom.c precisamos adicionar os headers no nosso arquivo tambem nano tcom.c dentro do arquivo temos que adicionar as duas linhas de bibliotecas para que possamos usar as fun\u00e7\u00f5es que conversam com o kernel alem de poder usar seus macros #include <linux/init.h> #include <linux/module.h> Com as bibliotecas importadas podemos come\u00e7ar o nosso codigo como por exemplo fazer dizer o que nosso driver far\u00e1 ao ser carregado e descarregado. Essas fun\u00e7\u00f5es tem um padr\u00e3o para se seguir em que a fun\u00e7\u00e3o de inicializa\u00e7\u00e3o retorna um inteiro e o exit nao retorna nada como mostrado acima referencia no linux static int init_com ( void ) { return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); essas duas funcoes podem ser chamadas pelas macros module_init e module_exit, que vao ser chamados no momento de inicio do modulo e saida do modulo referencia no linux tem tambem muitas outra op\u00e7\u00f5es para definir o autor do m\u00f3dulo e ate mesmo a licensa dele, mas nao entraremos em muitos detalhes","title":"a. Estrutura\u00e7\u00e3o de um modulo"},{"location":"2019/Toranja-DevDriver/#b-funcionalidades-do-modulo","text":"Podemos por exemplo fazer um driver que simplesmente mande um Hello World para o kernel quando ele \u00e9 inicializado para isso semelhante a um programa em C utilizaremos uma fun\u00e7\u00e3o print precisamos importar mais uma biblioteca para que essa fun\u00e7\u00e3o fique disponivel #include <linux/kernel.h> com essa func\u00e3o importada temos acesso ao printk uma fun\u00e7\u00e3o que printa ao log do kernel Ate agora temos um programa assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> static int init_com ( void ) { printk ( \" \\n Hello World \\n \" ); return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com );","title":"b. Funcionalidades do modulo"},{"location":"2019/Toranja-DevDriver/#c-compilando-o-modulo","text":"podemos entao compilar o nosso programa usando uma Makefile contendo obj-m := tcom.o usamos tambem por padrao o lib modules do nosso sistema que esta localizado em /lib/modules/$(uname -r)/build se for testar no seu linux deixe /lib/modules/$(uname -r)/build ou podemos gerar nosso proprio com um kernel do linux make modules_install INSTALL_MOD_PATH = /some/root/folder ou simplesmente dentro da sua pasta do linux make modules usando make -C /path/para/source/linux M = ` pwd ` modules para compilar ou use Makefile no repo","title":"c. Compilando o modulo"},{"location":"2019/Toranja-DevDriver/#d-carregando-o-modulo-e-verificando","text":"com isso teremos um arquivo .ko que para todos os fins \u00e9 o nosso driver, este pode ser carregado e descarregado usando insmod e rmmod respectivamente como uma simples demosntra\u00e7\u00e3o podemos abrir um terminal e observar os logs do linux tail -f /var/log/kern.log enquanto em outro terminal compilamos o modulo e carregamos ele make -C /path/para/source/linux M = ` pwd ` modules sudo insmod ./tcom.ko sudo rmmod ./tcom.ko depois de executar esses comandos no linux voltamos ao nosso terminal que esta acompanhando o log do kernel e vemos que com sucesso obtivemos a mensagem kernel: [666.1337] Hello World Com isso temos a nossa primeira implementacao de um driver que simplesmesnte sobe uma mensagem para o kernel","title":"d. Carregando o modulo e verificando"},{"location":"2019/Toranja-DevDriver/#4-criacao-do-modulo-com-funcionalidade-comunicacao-char","text":"","title":"4. cria\u00e7\u00e3o do modulo com funcionalidade (comunica\u00e7\u00e3o char)"},{"location":"2019/Toranja-DevDriver/#a-adicionar-novas-funcionalidades","text":"Agora precisamos dar alguma funcionalidade para o nosso driver, como por exemplo interfacear com o hardware para simplesmente receber mensagens Como tudo no linux precisamos abrir um arquivo para fazer a comunicacao com o kernel space e este fazer a comunicacao com o hardware, para isso precisamos importar mais algumas bibliotecas /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ /* acessar o user space */ #include <asm/uaccess.h> com esses includes novos podemos trabalhar com algumas funcoes mais avancadas da criacao de drivers e dar mais um passo ao nosso vriver que interpreta mensagens do hardware fisico mas ainda preisamos fazer as funcoes que permitem que nosso driver funcione, no caso para excrever e ler apenas um char.","title":"a. Adicionar novas funcionalidades"},{"location":"2019/Toranja-DevDriver/#b-adicionar-a-relacao-do-driver-com-o-hardware","text":"comecaremos declarando qual a regiao de memoria que iremos acessar com o numero de identifica\u00e7\u00e3o do driver para ele acessar os perifericos que utilizam desse driver /* o numero da versao do nosso driver */ int memory_major = 60 ; /* onde nossa memoria vai ser salva*/ char * memory_buffer ;","title":"b. Adicionar a rela\u00e7\u00e3o do driver com o hardware"},{"location":"2019/Toranja-DevDriver/#c-funcoes-de-inicializacao-de-memoria","text":"temos tambem que mudar nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o para que quando o driver se inicialize ele aloque um espa\u00e7o de memoria que ser\u00e1 usado, assim como um programa em C, sua libera\u00e7\u00e3o tambem deve ser criada, nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o e saida deve ser mais ou menos assim int memory_init ( void ) { int result ; /* Registrar o nosso driver para os hardwares certos */ result = register_chrdev ( memory_major , \"memory\" , & memory_fops ); /* Alocar o espa\u00e7o de memoria para o programa*/ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; memory_exit (); return result ; } memset ( memory_buffer , 0 , 1 ); printk ( \"<1>Driver simples de memoria inicializado \\n \" ); return 0 ; } void memory_exit ( void ) { /* Liberando o numero de registro no sistema*/ unregister_chrdev ( memory_major , \"memory\" ); /* Liberando o espa\u00e7o de memoria */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Liberando memorias e descarregando modulo \\n \" ); }","title":"c. Fun\u00e7\u00f5es de inicializa\u00e7\u00e3o de memoria"},{"location":"2019/Toranja-DevDriver/#d-funcoes-para-manipulacao-de-memoria","text":"temos agora uma parte do nosso programa para iniciar e liberar espa\u00e7os de memoria que podemos trabalhar, mas nosso driver ainda nao executa nenhuma fun\u00e7\u00e3o para isso faremos uma funcao que abre o nosso \"arquivo\" e uma que deixa nosso arquivo disponivel para outros programas apos a execu\u00e7\u00e3o da primeira int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } agora tambem precisamos que apos abrir o local de memoria do nosso driver nos possamos ler e escrever nele podemos fazer isso com uma fun\u00e7\u00e3o que copia do buffer para a nossa memoria e vice-versa ssize_t memory_read ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { /* Transfering data to user space */ copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } ssize_t memory_write ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count - 1 ; copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } ate agora fizemos um modulo para o nosso proprio linux mas podemos tambem fazer a compila\u00e7\u00e3o de um modulo para um dispositivo ARM embarcado simplesmente mudando algumas linhas do nosso Makefile export CROSS_COMPILE = export ARCH = x86_64 por export CROSS_COMPILE = gcc-arm-linux-gnueabi- export ARCH = arm agora que temos um driver simples que consegue compreender o que escrevemos e passar para um hardware virtual nosso podemos passar para coisas um pouco mais uteis e complexas como por exemplo controlar um led da placa, e \u00e9 isso que faremos nessa sess\u00e3o","title":"d. Fun\u00e7\u00f5es para manipula\u00e7\u00e3o de memoria"},{"location":"2019/Toranja-DevDriver/#5-driver-que-controla-gpio-do-raspberry","text":"primeiramente utilizaremos o outro codigo de esqueleto ele tem que estar mais ou menos assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> #include <asm/uaccess.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ int memory_major = 60 ; /* Buffer para guardar os dados */ char * memory_buffer ; static void finish_com ( void ) { /* liberando o numero de versao */ unregister_chrdev ( memory_major , \"memory\" ); /* liberando a memoria para outro programa */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Removing memory module \\n \" ); } int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } static ssize_t memory_read ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { /* Copia para o user space */ raw_copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } static ssize_t memory_write ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count - 1 ; raw_copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } static struct file_operations tcom_fops = { . owner = THIS_MODULE , . read = memory_read , . write = memory_write , . open = memory_open , . release = memory_release }; static int init_com ( void ) { int result ; /* registrando o driver */ register_chrdev ( memory_major , \"memory\" , & tcom_fops ); //TODO FIX NULL with pointer to file_operands /* alocar a memoria para o driver */ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; finish_com (); return result ; } memset ( memory_buffer , 0 , 1 ); return 0 ; } MODULE_LICENSE ( \"Dual BSD/GPL\" ); module_init ( init_com ); module_exit ( finish_com ); com esse codigo que fizemos na sessao anterior temos apensar que criar uma fun\u00e7\u00e3o que receba de input os nossos enderecos de memorias do pino e definir como os bits que precisam estar ligados como por exemplo vamos usar como base um raspbery e seus GPIOs ( https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf ) definimos primeiro a estrutura de um GPIO da rapberry como o exmplo abaixo struct GpioRegisters { uint32_t GPFSEL[6]; uint32_t Reserved1; uint32_t GPSET[2]; uint32_t Reserved2; uint32_t GPCLR[2]; }; struct GpioRegisters *s_pGpioRegisters; ent\u00e3o precisamos agora definir as funcoes para podermos fazer alguma coisa quando tivermos os registradores do raspberry para isso podemos utilizar das seguintes funcoes static void definirFuncaoDoGPIO ( int GPIO , int functionCode ) { int IndexRegistrador = GPIO / 10 ; int bit = ( GPIO % 10 ) * 3 ; unsigned oldValue = s_pGpioRegisters -> GPFSEL [ IndexRegistrador ]; unsigned mask = 0 b111 << bit ; s_pGpioRegisters -> GPFSEL [ IndexRegistrador ] = ( oldValue & ~ mask ) | (( functionCode << bit ) & mask ); } static void SetGPIOOutputValue ( int GPIO , bool outputValue ) { if ( outputValue ) s_pGpioRegisters -> GPSET [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); else s_pGpioRegisters -> GPCLR [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); } com essas funcoes para a manipula\u00e7\u00e3o das GPIOs do nosso raspberry podemos criar um timer que aciona elas em momentos distintos para deixar o pino escolhido como alto ou baixo e verificar com o nosso led Poderiamos usar timer mas por questoes de tempo so deixaremos um pino no estado alto e veremos o seu efeito e logo em seguida ao descarregarmos o driver ele voltara ao seu estado normal de input caso alguem queria tentera depois com a biblioteca de timers tambem deixo o codigo fonte da biblioteca para ser estudado aqui static int __init LedBlinkModule_init ( void ) { int result ; s_pGpioRegisters = ( struct GpioRegisters * ) __io_address ( GPIO_BASE ); SetGPIOFunction ( LedGpioPin , 0 b001 ); //Output SetGPIOOutputValue ( LedGpioPin , 1 ) } static void __exit LedBlinkModule_exit ( void ) { SetGPIOFunction ( LedGpioPin , 0 ); //Configure the pin as input del_timer ( & s_BlinkTimer ); } podedmos passar para algo mais avan\u00e7ado como \u00e9 o caso das interrup\u00e7\u00f5es, como ja temos um conhecimento geral de como sao feitos os drivers de linux podemos pular as etapas sobre a inicializa\u00e7\u00e3o e saida dos drivers bem como o Makefile e suas dependencias","title":"5. driver que controla GPIO do raspberry"},{"location":"2019/Tutoriais/","text":"Tutoriais 2019 \u00b6 Tutoriais desenvolvidos pelos alunos da eletiva de Embarcados Avan\u00e7ados.","title":"Tutoriais 2019"},{"location":"2019/Tutoriais/#tutoriais-2019","text":"Tutoriais desenvolvidos pelos alunos da eletiva de Embarcados Avan\u00e7ados.","title":"Tutoriais 2019"},{"location":"2019/virtual_com_driver/","text":"Introdu\u00e7\u00e3o \u00b6 Um driver de linux \u00e9 um programa que facilita a comunica\u00e7\u00e3o dos programas com a parte fisica do nosso dispositivo 1. Kernel space e user space \u00b6 Para entendermos como isso funciona primeiro temos que entender o que significam os programas e o kernel Os programas rodam em uma parte especial da nossa memoria chamada de espa\u00e7o de usuario, como por exemplo o python ou ate mesmo um bash, esses programas normalmente n\u00e3o precisam acessar itens de mais baixo nivel como por exemplo acesso direto a memoria ou portas UBS por exemplo. Essas tarefas sao executadas pelo kernel space que sabe lidar com o nosso hardware de uma maneira eficiente disponibilizando um tipo \"API\" para o user space lidar isso , e esse \u00e9 o trabalho dos drivers, a parte da tradu\u00e7\u00e3o dos comandos de usuario para que o kernel execute. 2. Como o driver conversa com o computador \u00b6 Os programas localizados no user space tem um momento especifico para pedir coisas para o kernel sobre o hardware como eh o caso de exploradores de arquivos e comunica\u00e7\u00e3o serial, caso algum desses programas queira se comunicar com um acessorio que n\u00e3o tenha seu proprio driver, temos um problema pois esse n\u00e3o conseguira ser comunicado Entao temos outra op\u00e7\u00e3o para isso, desenvolver nosso proprio driver, para ser compilado juntamente com o kernel e vir juntamente com ele, ou um simples modulo que \u00e9 compilado a parte e depois carregado no linux a partir do user space que ensinaremos nesse tutorial 3. cria\u00e7\u00e3o do modulo basico \u00b6 O nosso modulo precisa ser criado em alguma linguagem que o kernel do linux entenda, por isso utilizaremos o C a. Estrutura\u00e7\u00e3o de um modulo \u00b6 Primeiramente precisamo incluir a biblioteca de modulos do linux, para faremos um novo arquivo chamado de tcom.c touch tcom.c precisamos adicionar os headers no nosso arquivo tambem nano tcom.c dentro do arquivo temos que adicionar as duas linhas de bibliotecas para que possamos usar as fun\u00e7\u00f5es que conversam com o kernel alem de poder usar seus macros #include <linux/init.h> #include <linux/module.h> com as bibliotecas importadas podemos come\u00e7ar o nosso codigo como por exemplo fazer dizer o que nosso driver far\u00e1 ao ser carregado e descarregado. essas fun\u00e7\u00f5es tem um padr\u00e3o para se seguir em que a fun\u00e7\u00e3o de inicializa\u00e7\u00e3o retorna um inteiro e o exit nao retorna nada como mostrado acima referencia no linux static int init_com ( void ) { return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); essas duas funcoes podem ser chamadas pelas macros module_init e module_exit, que vao ser chamados no momento de inicio do modulo e saida do modulo referencia no linux tem tambem muitas outra op\u00e7\u00f5es para definir o autor do m\u00f3dulo e ate mesmo a licensa dele, mas nao entraremos em muitos detalhes b. Funcionalidades do modulo \u00b6 Podemos por exemplo fazer um driver que simplesmente mande um Hello World para o kernel quando ele \u00e9 inicializado para isso semelhante a um programa em C utilizaremos uma fun\u00e7\u00e3o print precisamos importar mais uma biblioteca para que essa fun\u00e7\u00e3o fique disponivel #include <linux/kernel.h> com essa func\u00e3o importada temos acesso ao printk uma fun\u00e7\u00e3o que printa ao log do kernel Ate agora temos um programa assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> static int init_com ( void ) { printk ( \" \\n Hello World \\n \" ); return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); c. Compilando o modulo \u00b6 podemos entao compilar o nosso programa usando uma Makefile contendo obj-m := tcom.o usamos tambem por padrao o lib modules do nosso sistema que esta localizado em /lib/modules/$(uname -r)/build se for testar no seu linux deixe /lib/modules/$(uname -r)/build ou podemos gerar nosso proprio com um kernel do linux make modules_install INSTALL_MOD_PATH = /some/root/folder ou simplesmente dentro da sua pasta do linux make modules usando make -C /path/para/source/linux M = ` pwd ` modules para compilar ou use Makefile no repo d. Carregando o modulo e verificando \u00b6 com isso teremos um arquivo .ko que para todos os fins \u00e9 o nosso driver, este pode ser carregado e descarregado usando insmod e rmmod respectivamente como uma simples demosntra\u00e7\u00e3o podemos abrir um terminal e observar os logs do linux tail -f /var/log/kern.log enquanto em outro terminal compilamos o modulo e carregamos ele make -C /path/para/source/linux M = ` pwd ` modules sudo insmod ./tcom.ko sudo rmmod ./tcom.ko depois de executar esses comandos no linux voltamos ao nosso terminal que esta acompanhando o log do kernel e vemos que com sucesso obtivemos a mensagem kernel: [666.1337] Hello World Com isso temos a nossa primeira implementacao de um driver que simplesmesnte sobe uma mensagem para o kernel 4. cria\u00e7\u00e3o do modulo com funcionalidade (comunica\u00e7\u00e3o char) \u00b6 a. Adicionar novas funcionalidades \u00b6 Agora precisamos dar alguma funcionalidade para o nosso driver, como por exemplo interfacear com o hardware para simplesmente receber mensagens Como tudo no linux precisamos abrir um arquivo para fazer a comunicacao com o kernel space e este fazer a comunicacao com o hardware, para isso precisamos importar mais algumas bibliotecas /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ /* acessar o user space */ #include <asm/uaccess.h> com esses includes novos podemos trabalhar com algumas funcoes mais avancadas da criacao de drivers e dar mais um passo ao nosso vriver que interpreta mensagens do hardware fisico mas ainda preisamos fazer as funcoes que permitem que nosso driver funcione, no caso para excrever e ler apenas um char. b. Adicionar a rela\u00e7\u00e3o do driver com o hardware \u00b6 comecaremos declarando qual a regiao de memoria que iremos acessar com o numero de identifica\u00e7\u00e3o do driver para ele acessar os perifericos que utilizam desse driver /* o numero da versao do nosso driver */ int memory_major = 60 ; /* onde nossa memoria vai ser salva*/ char * memory_buffer ; c. Fun\u00e7\u00f5es de inicializa\u00e7\u00e3o de memoria \u00b6 temos tambem que mudar nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o para que quando o driver se inicialize ele aloque um espa\u00e7o de memoria que ser\u00e1 usado, assim como um programa em C, sua libera\u00e7\u00e3o tambem deve ser criada, nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o e saida deve ser mais ou menos assim int memory_init ( void ) { int result ; /* Registrar o nosso driver para os hardwares certos */ result = register_chrdev ( memory_major , \"memory\" , & memory_fops ); /* Alocar o espa\u00e7o de memoria para o programa*/ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; memory_exit (); return result ; } memset ( memory_buffer , 0 , 1 ); printk ( \"<1>Driver simples de memoria inicializado \\n \" ); return 0 ; } void memory_exit ( void ) { /* Liberando o numero de registro no sistema*/ unregister_chrdev ( memory_major , \"memory\" ); /* Liberando o espa\u00e7o de memoria */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Liberando memorias e descarregando modulo \\n \" ); } d. Fun\u00e7\u00f5es para manipula\u00e7\u00e3o de memoria \u00b6 temos agora uma parte do nosso programa para iniciar e liberar espa\u00e7os de memoria que podemos trabalhar, mas nosso driver ainda nao executa nenhuma fun\u00e7\u00e3o para isso faremos uma funcao que abre o nosso \"arquivo\" e uma que deixa nosso arquivo disponivel para outros programas apos a execu\u00e7\u00e3o da primeira int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } agora tambem precisamos que apos abrir o local de memoria do nosso driver nos possamos ler e escrever nele podemos fazer isso com uma fun\u00e7\u00e3o que copia do buffer para a nossa memoria e vice-versa ssize_t memory_read ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { /* Transfering data to user space */ copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } ssize_t memory_write ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count - 1 ; copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } ate agora fizemos um modulo para o nosso proprio linux mas podemos tambem fazer a compila\u00e7\u00e3o de um modulo para um dispositivo ARM embarcado simplesmente mudando algumas linhas do nosso Makefile export CROSS_COMPILE = export ARCH = x86_64 por export CROSS_COMPILE = gcc-arm-linux-gnueabi- export ARCH = arm agora que temos um driver simples que consegue compreender o que escrevemos e passar para um hardware virtual nosso podemos passar para coisas um pouco mais uteis e complexas como por exemplo controlar um led da placa, e \u00e9 isso que faremos nessa sess\u00e3o 5. driver que controla GPIO do raspberry \u00b6 primeiramente utilizaremos o outro codigo de esqueleto ele tem que estar mais ou menos assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> #include <asm/uaccess.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ int memory_major = 60 ; /* Buffer para guardar os dados */ char * memory_buffer ; static void finish_com ( void ) { /* liberando o numero de versao */ unregister_chrdev ( memory_major , \"memory\" ); /* liberando a memoria para outro programa */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Removing memory module \\n \" ); } int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } static ssize_t memory_read ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { /* Copia para o user space */ raw_copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } static ssize_t memory_write ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count - 1 ; raw_copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } static struct file_operations tcom_fops = { . owner = THIS_MODULE , . read = memory_read , . write = memory_write , . open = memory_open , . release = memory_release }; static int init_com ( void ) { int result ; /* registrando o driver */ register_chrdev ( memory_major , \"memory\" , & tcom_fops ); //TODO FIX NULL with pointer to file_operands /* alocar a memoria para o driver */ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; finish_com (); return result ; } memset ( memory_buffer , 0 , 1 ); return 0 ; } MODULE_LICENSE ( \"Dual BSD/GPL\" ); module_init ( init_com ); module_exit ( finish_com ); com esse codigo que fizemos na sessao anterior temos apensar que criar uma fun\u00e7\u00e3o que receba de input os nossos enderecos de memorias do pino e definir como os bits que precisam estar ligados como por exemplo vamos usar como base um raspbery e seus GPIOs ( https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf ) definimos primeiro a estrutura de um GPIO da rapberry como o exmplo abaixo struct GpioRegisters { uint32_t GPFSEL[6]; uint32_t Reserved1; uint32_t GPSET[2]; uint32_t Reserved2; uint32_t GPCLR[2]; }; struct GpioRegisters *s_pGpioRegisters; ent\u00e3o precisamos agora definir as funcoes para podermos fazer alguma coisa quando tivermos os registradores do raspberry para isso podemos utilizar das seguintes funcoes static void definirFuncaoDoGPIO ( int GPIO , int functionCode ) { int IndexRegistrador = GPIO / 10 ; int bit = ( GPIO % 10 ) * 3 ; unsigned oldValue = s_pGpioRegisters -> GPFSEL [ IndexRegistrador ]; unsigned mask = 0 b111 << bit ; s_pGpioRegisters -> GPFSEL [ IndexRegistrador ] = ( oldValue & ~ mask ) | (( functionCode << bit ) & mask ); } static void SetGPIOOutputValue ( int GPIO , bool outputValue ) { if ( outputValue ) s_pGpioRegisters -> GPSET [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); else s_pGpioRegisters -> GPCLR [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); } com essas funcoes para a manipula\u00e7\u00e3o das GPIOs do nosso raspberry podemos criar um timer que aciona elas em momentos distintos para deixar o pino escolhido como alto ou baixo e verificar com o nosso led Poderiamos usar timer mas por questoes de tempo so deixaremos um pino no estado alto e veremos o seu efeito e logo em seguida ao descarregarmos o driver ele voltara ao seu estado normal de input caso alguem queria tentera depois com a biblioteca de timers tambem deixo o codigo fonte da biblioteca para ser estudado aqui static int __init LedBlinkModule_init ( void ) { int result ; s_pGpioRegisters = ( struct GpioRegisters * ) __io_address ( GPIO_BASE ); SetGPIOFunction ( LedGpioPin , 0 b001 ); //Output SetGPIOOutputValue ( LedGpioPin , 1 ) } static void __exit LedBlinkModule_exit ( void ) { SetGPIOFunction ( LedGpioPin , 0 ); //Configure the pin as input del_timer ( & s_BlinkTimer ); } podedmos passar para algo mais avan\u00e7ado como \u00e9 o caso das interrup\u00e7\u00f5es, como ja temos um conhecimento geral de como sao feitos os drivers de linux podemos pular as etapas sobre a inicializa\u00e7\u00e3o e saida dos drivers bem como o Makefile e suas dependencias","title":"Home"},{"location":"2019/virtual_com_driver/#introducao","text":"Um driver de linux \u00e9 um programa que facilita a comunica\u00e7\u00e3o dos programas com a parte fisica do nosso dispositivo","title":"Introdu\u00e7\u00e3o"},{"location":"2019/virtual_com_driver/#1-kernel-space-e-user-space","text":"Para entendermos como isso funciona primeiro temos que entender o que significam os programas e o kernel Os programas rodam em uma parte especial da nossa memoria chamada de espa\u00e7o de usuario, como por exemplo o python ou ate mesmo um bash, esses programas normalmente n\u00e3o precisam acessar itens de mais baixo nivel como por exemplo acesso direto a memoria ou portas UBS por exemplo. Essas tarefas sao executadas pelo kernel space que sabe lidar com o nosso hardware de uma maneira eficiente disponibilizando um tipo \"API\" para o user space lidar isso , e esse \u00e9 o trabalho dos drivers, a parte da tradu\u00e7\u00e3o dos comandos de usuario para que o kernel execute.","title":"1. Kernel space e user space"},{"location":"2019/virtual_com_driver/#2-como-o-driver-conversa-com-o-computador","text":"Os programas localizados no user space tem um momento especifico para pedir coisas para o kernel sobre o hardware como eh o caso de exploradores de arquivos e comunica\u00e7\u00e3o serial, caso algum desses programas queira se comunicar com um acessorio que n\u00e3o tenha seu proprio driver, temos um problema pois esse n\u00e3o conseguira ser comunicado Entao temos outra op\u00e7\u00e3o para isso, desenvolver nosso proprio driver, para ser compilado juntamente com o kernel e vir juntamente com ele, ou um simples modulo que \u00e9 compilado a parte e depois carregado no linux a partir do user space que ensinaremos nesse tutorial","title":"2. Como o driver conversa com o computador"},{"location":"2019/virtual_com_driver/#3-criacao-do-modulo-basico","text":"O nosso modulo precisa ser criado em alguma linguagem que o kernel do linux entenda, por isso utilizaremos o C","title":"3. cria\u00e7\u00e3o do modulo basico"},{"location":"2019/virtual_com_driver/#a-estruturacao-de-um-modulo","text":"Primeiramente precisamo incluir a biblioteca de modulos do linux, para faremos um novo arquivo chamado de tcom.c touch tcom.c precisamos adicionar os headers no nosso arquivo tambem nano tcom.c dentro do arquivo temos que adicionar as duas linhas de bibliotecas para que possamos usar as fun\u00e7\u00f5es que conversam com o kernel alem de poder usar seus macros #include <linux/init.h> #include <linux/module.h> com as bibliotecas importadas podemos come\u00e7ar o nosso codigo como por exemplo fazer dizer o que nosso driver far\u00e1 ao ser carregado e descarregado. essas fun\u00e7\u00f5es tem um padr\u00e3o para se seguir em que a fun\u00e7\u00e3o de inicializa\u00e7\u00e3o retorna um inteiro e o exit nao retorna nada como mostrado acima referencia no linux static int init_com ( void ) { return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com ); essas duas funcoes podem ser chamadas pelas macros module_init e module_exit, que vao ser chamados no momento de inicio do modulo e saida do modulo referencia no linux tem tambem muitas outra op\u00e7\u00f5es para definir o autor do m\u00f3dulo e ate mesmo a licensa dele, mas nao entraremos em muitos detalhes","title":"a. Estrutura\u00e7\u00e3o de um modulo"},{"location":"2019/virtual_com_driver/#b-funcionalidades-do-modulo","text":"Podemos por exemplo fazer um driver que simplesmente mande um Hello World para o kernel quando ele \u00e9 inicializado para isso semelhante a um programa em C utilizaremos uma fun\u00e7\u00e3o print precisamos importar mais uma biblioteca para que essa fun\u00e7\u00e3o fique disponivel #include <linux/kernel.h> com essa func\u00e3o importada temos acesso ao printk uma fun\u00e7\u00e3o que printa ao log do kernel Ate agora temos um programa assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> static int init_com ( void ) { printk ( \" \\n Hello World \\n \" ); return 0 ; } static void finish_com ( void ) { return ; } module_init ( init_com ); module_exit ( finish_com );","title":"b. Funcionalidades do modulo"},{"location":"2019/virtual_com_driver/#c-compilando-o-modulo","text":"podemos entao compilar o nosso programa usando uma Makefile contendo obj-m := tcom.o usamos tambem por padrao o lib modules do nosso sistema que esta localizado em /lib/modules/$(uname -r)/build se for testar no seu linux deixe /lib/modules/$(uname -r)/build ou podemos gerar nosso proprio com um kernel do linux make modules_install INSTALL_MOD_PATH = /some/root/folder ou simplesmente dentro da sua pasta do linux make modules usando make -C /path/para/source/linux M = ` pwd ` modules para compilar ou use Makefile no repo","title":"c. Compilando o modulo"},{"location":"2019/virtual_com_driver/#d-carregando-o-modulo-e-verificando","text":"com isso teremos um arquivo .ko que para todos os fins \u00e9 o nosso driver, este pode ser carregado e descarregado usando insmod e rmmod respectivamente como uma simples demosntra\u00e7\u00e3o podemos abrir um terminal e observar os logs do linux tail -f /var/log/kern.log enquanto em outro terminal compilamos o modulo e carregamos ele make -C /path/para/source/linux M = ` pwd ` modules sudo insmod ./tcom.ko sudo rmmod ./tcom.ko depois de executar esses comandos no linux voltamos ao nosso terminal que esta acompanhando o log do kernel e vemos que com sucesso obtivemos a mensagem kernel: [666.1337] Hello World Com isso temos a nossa primeira implementacao de um driver que simplesmesnte sobe uma mensagem para o kernel","title":"d. Carregando o modulo e verificando"},{"location":"2019/virtual_com_driver/#4-criacao-do-modulo-com-funcionalidade-comunicacao-char","text":"","title":"4. cria\u00e7\u00e3o do modulo com funcionalidade (comunica\u00e7\u00e3o char)"},{"location":"2019/virtual_com_driver/#a-adicionar-novas-funcionalidades","text":"Agora precisamos dar alguma funcionalidade para o nosso driver, como por exemplo interfacear com o hardware para simplesmente receber mensagens Como tudo no linux precisamos abrir um arquivo para fazer a comunicacao com o kernel space e este fazer a comunicacao com o hardware, para isso precisamos importar mais algumas bibliotecas /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ /* acessar o user space */ #include <asm/uaccess.h> com esses includes novos podemos trabalhar com algumas funcoes mais avancadas da criacao de drivers e dar mais um passo ao nosso vriver que interpreta mensagens do hardware fisico mas ainda preisamos fazer as funcoes que permitem que nosso driver funcione, no caso para excrever e ler apenas um char.","title":"a. Adicionar novas funcionalidades"},{"location":"2019/virtual_com_driver/#b-adicionar-a-relacao-do-driver-com-o-hardware","text":"comecaremos declarando qual a regiao de memoria que iremos acessar com o numero de identifica\u00e7\u00e3o do driver para ele acessar os perifericos que utilizam desse driver /* o numero da versao do nosso driver */ int memory_major = 60 ; /* onde nossa memoria vai ser salva*/ char * memory_buffer ;","title":"b. Adicionar a rela\u00e7\u00e3o do driver com o hardware"},{"location":"2019/virtual_com_driver/#c-funcoes-de-inicializacao-de-memoria","text":"temos tambem que mudar nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o para que quando o driver se inicialize ele aloque um espa\u00e7o de memoria que ser\u00e1 usado, assim como um programa em C, sua libera\u00e7\u00e3o tambem deve ser criada, nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o e saida deve ser mais ou menos assim int memory_init ( void ) { int result ; /* Registrar o nosso driver para os hardwares certos */ result = register_chrdev ( memory_major , \"memory\" , & memory_fops ); /* Alocar o espa\u00e7o de memoria para o programa*/ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; memory_exit (); return result ; } memset ( memory_buffer , 0 , 1 ); printk ( \"<1>Driver simples de memoria inicializado \\n \" ); return 0 ; } void memory_exit ( void ) { /* Liberando o numero de registro no sistema*/ unregister_chrdev ( memory_major , \"memory\" ); /* Liberando o espa\u00e7o de memoria */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Liberando memorias e descarregando modulo \\n \" ); }","title":"c. Fun\u00e7\u00f5es de inicializa\u00e7\u00e3o de memoria"},{"location":"2019/virtual_com_driver/#d-funcoes-para-manipulacao-de-memoria","text":"temos agora uma parte do nosso programa para iniciar e liberar espa\u00e7os de memoria que podemos trabalhar, mas nosso driver ainda nao executa nenhuma fun\u00e7\u00e3o para isso faremos uma funcao que abre o nosso \"arquivo\" e uma que deixa nosso arquivo disponivel para outros programas apos a execu\u00e7\u00e3o da primeira int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } agora tambem precisamos que apos abrir o local de memoria do nosso driver nos possamos ler e escrever nele podemos fazer isso com uma fun\u00e7\u00e3o que copia do buffer para a nossa memoria e vice-versa ssize_t memory_read ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { /* Transfering data to user space */ copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } ssize_t memory_write ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count - 1 ; copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } ate agora fizemos um modulo para o nosso proprio linux mas podemos tambem fazer a compila\u00e7\u00e3o de um modulo para um dispositivo ARM embarcado simplesmente mudando algumas linhas do nosso Makefile export CROSS_COMPILE = export ARCH = x86_64 por export CROSS_COMPILE = gcc-arm-linux-gnueabi- export ARCH = arm agora que temos um driver simples que consegue compreender o que escrevemos e passar para um hardware virtual nosso podemos passar para coisas um pouco mais uteis e complexas como por exemplo controlar um led da placa, e \u00e9 isso que faremos nessa sess\u00e3o","title":"d. Fun\u00e7\u00f5es para manipula\u00e7\u00e3o de memoria"},{"location":"2019/virtual_com_driver/#5-driver-que-controla-gpio-do-raspberry","text":"primeiramente utilizaremos o outro codigo de esqueleto ele tem que estar mais ou menos assim #include <linux/kernel.h> #include <linux/init.h> #include <linux/module.h> /* para os codigos de erros que ser\u00e3o utilizados daqui para a frente */ #include <linux/errno.h> /* controlar o sistema de arquivos */ #include <linux/fs.h> #include <linux/proc_fs.h> #include <asm/uaccess.h> /* alocar memoria no kernel space */ #include <linux/slab.h> /* medir o tamanho das variaveis usado no kmalloc */ #include <linux/types.h> #include <linux/fcntl.h> /* O_ACCMODE */ int memory_major = 60 ; /* Buffer para guardar os dados */ char * memory_buffer ; static void finish_com ( void ) { /* liberando o numero de versao */ unregister_chrdev ( memory_major , \"memory\" ); /* liberando a memoria para outro programa */ if ( memory_buffer ) { kfree ( memory_buffer ); } printk ( \"<1>Removing memory module \\n \" ); } int memory_open ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } int memory_release ( struct inode * inode , struct file * filp ) { /* Success */ return 0 ; } static ssize_t memory_read ( struct file * filp , char * buf , size_t count , loff_t * f_pos ) { /* Copia para o user space */ raw_copy_to_user ( buf , memory_buffer , 1 ); /* Changing reading position as best suits */ if ( * f_pos == 0 ) { * f_pos += 1 ; return 1 ; } else { return 0 ; } } static ssize_t memory_write ( struct file * filp , const char * buf , size_t count , loff_t * f_pos ) { char * tmp ; tmp = buf + count - 1 ; raw_copy_from_user ( memory_buffer , tmp , 1 ); return 1 ; } static struct file_operations tcom_fops = { . owner = THIS_MODULE , . read = memory_read , . write = memory_write , . open = memory_open , . release = memory_release }; static int init_com ( void ) { int result ; /* registrando o driver */ register_chrdev ( memory_major , \"memory\" , & tcom_fops ); //TODO FIX NULL with pointer to file_operands /* alocar a memoria para o driver */ memory_buffer = kmalloc ( 1 , GFP_KERNEL ); if ( ! memory_buffer ) { result = - ENOMEM ; finish_com (); return result ; } memset ( memory_buffer , 0 , 1 ); return 0 ; } MODULE_LICENSE ( \"Dual BSD/GPL\" ); module_init ( init_com ); module_exit ( finish_com ); com esse codigo que fizemos na sessao anterior temos apensar que criar uma fun\u00e7\u00e3o que receba de input os nossos enderecos de memorias do pino e definir como os bits que precisam estar ligados como por exemplo vamos usar como base um raspbery e seus GPIOs ( https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf ) definimos primeiro a estrutura de um GPIO da rapberry como o exmplo abaixo struct GpioRegisters { uint32_t GPFSEL[6]; uint32_t Reserved1; uint32_t GPSET[2]; uint32_t Reserved2; uint32_t GPCLR[2]; }; struct GpioRegisters *s_pGpioRegisters; ent\u00e3o precisamos agora definir as funcoes para podermos fazer alguma coisa quando tivermos os registradores do raspberry para isso podemos utilizar das seguintes funcoes static void definirFuncaoDoGPIO ( int GPIO , int functionCode ) { int IndexRegistrador = GPIO / 10 ; int bit = ( GPIO % 10 ) * 3 ; unsigned oldValue = s_pGpioRegisters -> GPFSEL [ IndexRegistrador ]; unsigned mask = 0 b111 << bit ; s_pGpioRegisters -> GPFSEL [ IndexRegistrador ] = ( oldValue & ~ mask ) | (( functionCode << bit ) & mask ); } static void SetGPIOOutputValue ( int GPIO , bool outputValue ) { if ( outputValue ) s_pGpioRegisters -> GPSET [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); else s_pGpioRegisters -> GPCLR [ GPIO / 32 ] = ( 1 << ( GPIO % 32 )); } com essas funcoes para a manipula\u00e7\u00e3o das GPIOs do nosso raspberry podemos criar um timer que aciona elas em momentos distintos para deixar o pino escolhido como alto ou baixo e verificar com o nosso led Poderiamos usar timer mas por questoes de tempo so deixaremos um pino no estado alto e veremos o seu efeito e logo em seguida ao descarregarmos o driver ele voltara ao seu estado normal de input caso alguem queria tentera depois com a biblioteca de timers tambem deixo o codigo fonte da biblioteca para ser estudado aqui static int __init LedBlinkModule_init ( void ) { int result ; s_pGpioRegisters = ( struct GpioRegisters * ) __io_address ( GPIO_BASE ); SetGPIOFunction ( LedGpioPin , 0 b001 ); //Output SetGPIOOutputValue ( LedGpioPin , 1 ) } static void __exit LedBlinkModule_exit ( void ) { SetGPIOFunction ( LedGpioPin , 0 ); //Configure the pin as input del_timer ( & s_BlinkTimer ); } podedmos passar para algo mais avan\u00e7ado como \u00e9 o caso das interrup\u00e7\u00f5es, como ja temos um conhecimento geral de como sao feitos os drivers de linux podemos pular as etapas sobre a inicializa\u00e7\u00e3o e saida dos drivers bem como o Makefile e suas dependencias","title":"5. driver que controla GPIO do raspberry"}]}