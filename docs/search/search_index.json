{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo a Eletica - Embarcados Avan\u00e7ados! \u00b6 Disciplina eletiva da Engenharia da Computa\u00e7\u00e3o Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/insper/Embarcados-Avancados Local: Laborat\u00f3rio de Arquitetura de Computadores OBJETIVOS: \u00b6 Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na wiki do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final. Infraestrutura \u00b6 Vamos precisar dos softwares listados aqui . Iremos ao longo do curso trabalhar com uma FPGA Intel, o kit \u00e9 o DE10-Standard . Geral \u00b6 Sobre FPGA e Softwares VHDL Projeto Final \u00b6 Overview Entrega 1 Din\u00e2mica \u00b6 A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado. Bibliografia \u00b6 B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008. Motiva\u00e7\u00e3o \u00b6 O que \u00e9 um System On Chip (SoC) ? Qual a vantagem/desvantagem do uso de um SoC? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e Hard-Processor? NIOS x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / apple 2 / microsoft / amazon Come\u00e7ando a disciplina \u00b6 Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Home"},{"location":"#bem-vindo-a-eletica-embarcados-avancados","text":"Disciplina eletiva da Engenharia da Computa\u00e7\u00e3o Insper - 2019-2. Prof. Rafael Corsi / rafael.corsi@insper.edu.br Reposit\u00f3rio: http:/github.com/insper/Embarcados-Avancados Local: Laborat\u00f3rio de Arquitetura de Computadores","title":"Bem vindo a Eletica - Embarcados Avan\u00e7ados!"},{"location":"#objetivos","text":"Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"OBJETIVOS:"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o \u00e9 composta de entregas ao longo do semestre (a cada s\u00e9rie de tutoriais existe uma entrega com nota) e de um tutorial que deve ser criado ao longo da disciplina e integrado na wiki do curso. O tutorial \u00e9 de tema livre dentro dos objetivos da disciplina e possui algumas entregas intermedi\u00e1rias que ir\u00e3o compor a nota final.","title":"Avalia\u00e7\u00e3o"},{"location":"#infraestrutura","text":"Vamos precisar dos softwares listados aqui . Iremos ao longo do curso trabalhar com uma FPGA Intel, o kit \u00e9 o DE10-Standard .","title":"Infraestrutura"},{"location":"#geral","text":"Sobre FPGA e Softwares VHDL","title":"Geral"},{"location":"#projeto-final","text":"Overview Entrega 1","title":"Projeto Final"},{"location":"#dinamica","text":"A disciplina \u00e9 baseada em uma s\u00e9rie de tutoriais (com entregas ao final) que come\u00e7a a partir de um simples hardware na FPGA para controlar LEDs da placa e chega at\u00e9 a execu\u00e7\u00e3o de um sistema Linux com interface gr\u00e1fica e co-processamento em um sistema embarcado.","title":"Din\u00e2mica"},{"location":"#bibliografia","text":"B\u00e1sica [HALLINAN, 2007] HALLINAN, C. Embedded Linux primer: a practical, real-world approach. Pearson Education India, 2007. [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. Complementar [SASS, 2010] SASS, R., SCHMIDT, A.G.; Embedded Systems Design with Platform FPGAs: Principles and Practices. Elsevier, 2010. [BOVET, 2005] Bovet, Daniel P., and Marco Cesati. Understanding the Linux Kernel: from I/O ports to process management. \" O'Reilly Media, Inc.\", 2005. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. [KOOPMAN, 2010] Koopman, Philip. Better Embedded System Software. Drumnadrochit Education, 2010. [VENKATESWARAN, 2008] Venkateswaran, Sreekrishnan. Essential Linux device drivers. Prentice Hall Press, 2008.","title":"Bibliografia"},{"location":"#motivacao","text":"O que \u00e9 um System On Chip (SoC) ? Qual a vantagem/desvantagem do uso de um SoC? Quem s\u00e3o os principal fabricantes de SoC? Samsung / Qualcomm / Xilinx / Intel FPGA \u00c1reas / Aplica\u00e7\u00f5es: macbook pro / aws f1 / Intel 1 / Intel 2 / xilinx Qual a diferen\u00e7a entre Soft-Processor e Hard-Processor? NIOS x86 + FPGA ? Empregos? A qual desses voc\u00ea se aplicaria ? facebook / google / apple / apple 2 / microsoft / amazon","title":"Motiva\u00e7\u00e3o"},{"location":"#comecando-a-disciplina","text":"Trazer os softwares instalados Criar um reposit\u00f3rio no github Pensar um pouco sobre um tema que gostaria de se aprofundar (para o tutorial) Dicas Leitura: https://www.intel.com/content/www/us/en/products/programmable/fpga/new-to-fpgas/resource-center/overview.html [CHU, 2011, cap. 1], [KOOPMAN, 2010, cap. 2] Nunca mexeu com FPGA? VHDL introdu\u00e7\u00e3o v\u00eddeo livro fpgas for dummie","title":"Come\u00e7ando a disciplina"},{"location":"Entrega-1/","text":"\ud83d\udc41 Entrega 1 \u00b6 Entrega: Pasta Entrega-1 no git Demonstra\u00e7\u00e3o em sala A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e com o Quartus e que tamb\u00e9m relembrem como desenvolver um projeto de forma hier\u00e1rquica. A partir do tutorial, voc\u00eas devem modificar o projeto para que o controle do LED seja feito por um componente (chamado de LED_peripheral ). Esse componente deve variar a frequ\u00eancia na qual os LEDs piscam com base um vetor de 4 bits, que ser\u00e1 ao final atribuido as chaves SW. E tamb\u00e9m deve possuir um sinal de enable (EN), que s\u00f3 deve funcionar caso positivo. Esse sinal de EN ser\u00e1 atribuido a bot\u00e3o KEY0. Depois de criarem esse novo componente, voc\u00eas devem o utilizar no topLevel para controlar efetivamente os pinos. Rubrica \u00b6 A Entregue um testbench capaz de testar o projeto. A Entregue um testbench capaz de testar o projeto. B O componente faz uso de generics para configura\u00e7\u00e3o interna. C Criou um componente em VHDL que \u00e9 respons\u00e1vel pelo controle do LED Esse componente possui um sinal de entrada de 4 bits que controla a frequ\u00eancia do LEDs, mapeado para as chaves SW. Esse componente possui um sinal de EN, mapeado para o bot\u00e3o KEY0 D Entregou o tutorial I N\u00e3o entregou nada Pr\u00f3ximo passo \u00b6 Siga para o tutorial Tutorial FPGA NIOS","title":"\ud83d\udc41 Entrega 1"},{"location":"Entrega-1/#entrega-1","text":"Entrega: Pasta Entrega-1 no git Demonstra\u00e7\u00e3o em sala A ideia dessa entrega \u00e9 que voc\u00eas trabalhem um pouco mais com o VHDL e com o Quartus e que tamb\u00e9m relembrem como desenvolver um projeto de forma hier\u00e1rquica. A partir do tutorial, voc\u00eas devem modificar o projeto para que o controle do LED seja feito por um componente (chamado de LED_peripheral ). Esse componente deve variar a frequ\u00eancia na qual os LEDs piscam com base um vetor de 4 bits, que ser\u00e1 ao final atribuido as chaves SW. E tamb\u00e9m deve possuir um sinal de enable (EN), que s\u00f3 deve funcionar caso positivo. Esse sinal de EN ser\u00e1 atribuido a bot\u00e3o KEY0. Depois de criarem esse novo componente, voc\u00eas devem o utilizar no topLevel para controlar efetivamente os pinos.","title":"\ud83d\udc41 Entrega 1"},{"location":"Entrega-1/#rubrica","text":"A Entregue um testbench capaz de testar o projeto. A Entregue um testbench capaz de testar o projeto. B O componente faz uso de generics para configura\u00e7\u00e3o interna. C Criou um componente em VHDL que \u00e9 respons\u00e1vel pelo controle do LED Esse componente possui um sinal de entrada de 4 bits que controla a frequ\u00eancia do LEDs, mapeado para as chaves SW. Esse componente possui um sinal de EN, mapeado para o bot\u00e3o KEY0 D Entregou o tutorial I N\u00e3o entregou nada","title":"Rubrica"},{"location":"Entrega-1/#proximo-passo","text":"Siga para o tutorial Tutorial FPGA NIOS","title":"Pr\u00f3ximo passo"},{"location":"Entrega-2/","text":"\ud83d\udc41 Entrega 2 \u00b6 O que deve ser entregue? - Pasta Entrega-1 no git - Demonstra\u00e7\u00e3o em sala Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com os LEDs e bot\u00f5es sendo acionados e lidos pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf Rubrica: \u00b6 I N\u00e3o entregou nada D Entregou somente tutorial C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx e KEYx) Adicione um novo PIO para ler o valor dos bot\u00f5es Interrup\u00e7\u00e3o na leitura do bot\u00e3o B Crie um driver para controlar os LEDs e Ler as chaves (criar uma biblioteca com arquivos .c e .h separados e fun\u00e7\u00f5es), ou : Adicione e fa\u00e7a uso de um timer (Platform Design) A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o","title":"\ud83d\udc41 Entrega 2"},{"location":"Entrega-2/#entrega-2","text":"O que deve ser entregue? - Pasta Entrega-1 no git - Demonstra\u00e7\u00e3o em sala Nessa entrega iremos ter a mesma funcionalidade que a Entrega 1 por\u00e9m com os LEDs e bot\u00f5es sendo acionados e lidos pelo NIOS (soft processor). Para isso ser\u00e1 necess\u00e1rio modificar o projeto criado no tutorial para possuir ao menos mais um perif\u00e9rico PIO (que ser\u00e1 respons\u00e1vel por ler os bot\u00f5es). Al\u00e9m de adicionar esse novo perif\u00e9rico, nessa entrega iremos aprimorar nosso sistema com: Perif\u00e9rico JTAG deve gerar interrup\u00e7\u00e3o Perif\u00e9rico PIO que lida com o bot\u00e3o deve gerar interrup\u00e7\u00e3o Mem\u00f3ria de programa separada da de dados Uma vez que o JTAG come\u00e7a a gerar interrup\u00e7\u00f5es n\u00e3o ser\u00e1 mais necess\u00e1rio usar o small driver do JTAG, lembre de alterar isso no bsp . Comece por ler os bot\u00f5es sem interrup\u00e7\u00e3o, uma vez que estiver funcionando, utilize os sites a seguir como refer\u00eancia para implementar interrup\u00e7\u00e3o no NIOS: Dicas: http://www.johnloomis.org/NiosII/interrupts/interrupt/interrupt.html https://www.altera.com/en_US/pdfs/literature/hb/nios2/n2sw_nii52006.pdf","title":"\ud83d\udc41 Entrega 2"},{"location":"Entrega-2/#rubrica","text":"I N\u00e3o entregou nada D Entregou somente tutorial C Mem\u00f3ria de dados separada da de programa JTAG gerando interrup\u00e7\u00e3o. PIO dedicado a ler bot\u00f5es (SWx e KEYx) Adicione um novo PIO para ler o valor dos bot\u00f5es Interrup\u00e7\u00e3o na leitura do bot\u00e3o B Crie um driver para controlar os LEDs e Ler as chaves (criar uma biblioteca com arquivos .c e .h separados e fun\u00e7\u00f5es), ou : Adicione e fa\u00e7a uso de um timer (Platform Design) A Insira um RTOS no NIOS para fazer o controle da aplica\u00e7\u00e3o","title":"Rubrica:"},{"location":"Entrega-3/","text":"\ud83d\udc41 Entrega 3 \u00b6 Nessa entrega iremos encapsular um perif\u00e9rico que \u00e9 respons\u00e1vel pela leitura de um mouse pela interface PS/2 no Plataform Designer (criando um perif\u00e9rico mapeado em mem\u00f3ria). Utilizaremos como c\u00f3digo padr\u00e3o o exemplo fornecido pela terasic para essa placa, dispon\u00edvel no CD do kit: Demonstration/FPGA/DE10_Standard_PS2/ . Rubrica: \u00b6 I N\u00e3o entregou nada D Entregou somente tutorial C PS2 mapeado em mem\u00f3ria lendo X,Y e click Left Fun\u00e7\u00f5es: PS2_init() / PS2_halt() / ps_read_clickLeft() B Aprimorado fun\u00e7\u00f5es do PS2 + ps2.c e ps2.h A PS2 gera interrup\u00e7\u00e3o Hardware \u00b6 O diagrama a seguir \u00e9 uma vis\u00e3o geral do que deve ser feito, nessa concep\u00e7\u00e3o iremos \"encapsular\" o IP da Terasic em um \"perif\u00e9rico mapeado em mem\u00f3ria\" ( PS2-MM ), para isso ser\u00e1 necess\u00e1rio adicionar uma l\u00f3gica extra, normalmente chamada de Glue Logic que realiza a interface entre o barramento e o IP. Perif\u00e9rico Terasic: PS2-Terasic \u00b6 O perif\u00e9rico da Terasic est\u00e1 pode ser encontrado no link a seguir: https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/blob/master/Demonstration/FPGA/DE10_Standard_PS2/v/ps2.v O exemplo que \u00e9 fornecido pela Terasic est\u00e1 em Verilog! mas n\u00e3o \u00e9 preciso desespero, podemos usar no nosso projeto em VHDL, basta declarar o componente e usar normalmente: component ps2 is port ( iSTART : in std_logic ; -- press the button for tranxrdb -merge .Xdefaultssmitting instrucions to device; iRST_n : in std_logic ; -- FSM reset signal; iCLK_50 : in std_logic ; -- clock source; PS2_CLK : inout std_logic ; -- ps2_clock signal inout; PS2_DAT : inout std_logic ; -- ps2_data signal inout; oLEFBUT : out std_logic ; -- left button press display; oRIGBUT : out std_logic ; -- right button press display; oMIDBUT : out std_logic ; -- middle button press display; oX : out std_logic_vector ( 7 downto 0 ); -- X axis. oY : out std_logic_vector ( 7 downto 0 ) -- Y axis. ); end component ps2 ; Esse exemplo est\u00e1 tamb\u00e9m documentando no manual do usu\u00e1rio: DE10-Standard_User_manual.pdf sec\u00e7\u00e3o: 3.6.12. Sec\u00e7\u00e3o: 3.6.12: Manual do usu\u00e1rio: Glue Logic \u00b6 A l\u00f3gica de controle deve interfacear com o perif\u00e9rico da Terasic em todos os sinais de controle (todos menos PS2_CLK / PS2_DATA / iCLK_50 / 'iRST_n') de maneira abstrair o acesso mapeado em mem\u00f3ria para o perif\u00e9rico. A maneira mais f\u00e1cil de fazer isso \u00e9 definindo funcionalidades a endere\u00e7os do perif\u00e9rico, por exemplo: Offset Funcionalidade Tipo 0 Controle R/W 1 ox R 2 oy R 3 oLEFTBUT R ... ... A tabela anterior mapeia para cada endere\u00e7o do perif\u00e9rico uma funcionalidade diferente, nesse exemplo, se o usu\u00e1rio deseja ler a informa\u00e7\u00e3o do deslocamento y: oy , deve fazer a leitura no endere\u00e7o 2 desse perif\u00e9rico. A implementa\u00e7\u00e3o disso pode ser feita por um simples mux . O endere\u00e7o de controle, pode ser usado por exemplo, para inicializar a leitura no perif\u00e9rico da terasic (via o sinal iSTART ). Note que alguns endere\u00e7os s\u00e3o Read Only e outros Read/Write (tipo), isso se d\u00e1 porque n\u00e3o tem sentido (nem \u00e9 poss\u00edvel fisicamente) escrever me alguns endere\u00e7os. (rubrica C) Software \u00b6 Al\u00e9m da parte de HW, iremos desenvolver uma biblioteca em C que ir\u00e1 abstrair a interface com esse perif\u00e9rico. O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: // Para rubrica C int PS2_init ( ..... ); // Inicializa o perif\u00e9rico int PS2_halt ( ..... ); // Desativa o perif\u00e9rico int PS2_read_clickLeft ( ..... ); // retorna se houve algum click (rubrica B) Software (melhorando) \u00b6 Adicionar as seguintes fun\u00e7\u00f5es: // Para rubrica B/A int PS2_read_x ( ..... ); // retorna o valor do movimento X int PS2_read_y ( ..... ); // retorna o valor do movimento y (rubrica A) IRQ \u00b6 Pode-se adicionar um sinal de interrup\u00e7\u00e3o ao perif\u00e9rico PS2-MM que servir\u00e1 para alertar o uC (NIOS) de um evento novo. Ser\u00e1 necess\u00e1rio adicionar as seguintes fun\u00e7\u00f5es: int PS2_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int PS2_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o Esse driver deve estar distribu\u00eddo em dois arquivos: PS2-MM.c e PS2-MM.h . Dicas \u00b6 \u00c9 sugerido os seguintes passos de execu\u00e7\u00e3o da entrega: Executar o exemplo PS2 da Terasic, e ver funcionar Entender os sinais do toplevel desse exemplo Desenhar um diagrama um pouco mais detalhado do PS2-MM, indicando quais sinais (nomes) ser\u00e3o conectados ao Glue Logic e quais dever\u00e3o ser conectados aos pinos da FPGA (conduit no PD) Implementar o 'PS2-MM', usando como base o perif\u00e9rico criado no tutorial. Crie uma nova pasta para o componente dentro da pasta atual IP (exe: PS2-MM) Copie o IP da terasic para essa pasta Crie seu componente dentro dessa pasta","title":"\ud83d\udc41 Entrega 3"},{"location":"Entrega-3/#entrega-3","text":"Nessa entrega iremos encapsular um perif\u00e9rico que \u00e9 respons\u00e1vel pela leitura de um mouse pela interface PS/2 no Plataform Designer (criando um perif\u00e9rico mapeado em mem\u00f3ria). Utilizaremos como c\u00f3digo padr\u00e3o o exemplo fornecido pela terasic para essa placa, dispon\u00edvel no CD do kit: Demonstration/FPGA/DE10_Standard_PS2/ .","title":"\ud83d\udc41 Entrega 3"},{"location":"Entrega-3/#rubrica","text":"I N\u00e3o entregou nada D Entregou somente tutorial C PS2 mapeado em mem\u00f3ria lendo X,Y e click Left Fun\u00e7\u00f5es: PS2_init() / PS2_halt() / ps_read_clickLeft() B Aprimorado fun\u00e7\u00f5es do PS2 + ps2.c e ps2.h A PS2 gera interrup\u00e7\u00e3o","title":"Rubrica:"},{"location":"Entrega-3/#hardware","text":"O diagrama a seguir \u00e9 uma vis\u00e3o geral do que deve ser feito, nessa concep\u00e7\u00e3o iremos \"encapsular\" o IP da Terasic em um \"perif\u00e9rico mapeado em mem\u00f3ria\" ( PS2-MM ), para isso ser\u00e1 necess\u00e1rio adicionar uma l\u00f3gica extra, normalmente chamada de Glue Logic que realiza a interface entre o barramento e o IP.","title":"Hardware"},{"location":"Entrega-3/#periferico-terasic-ps2-terasic","text":"O perif\u00e9rico da Terasic est\u00e1 pode ser encontrado no link a seguir: https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/blob/master/Demonstration/FPGA/DE10_Standard_PS2/v/ps2.v O exemplo que \u00e9 fornecido pela Terasic est\u00e1 em Verilog! mas n\u00e3o \u00e9 preciso desespero, podemos usar no nosso projeto em VHDL, basta declarar o componente e usar normalmente: component ps2 is port ( iSTART : in std_logic ; -- press the button for tranxrdb -merge .Xdefaultssmitting instrucions to device; iRST_n : in std_logic ; -- FSM reset signal; iCLK_50 : in std_logic ; -- clock source; PS2_CLK : inout std_logic ; -- ps2_clock signal inout; PS2_DAT : inout std_logic ; -- ps2_data signal inout; oLEFBUT : out std_logic ; -- left button press display; oRIGBUT : out std_logic ; -- right button press display; oMIDBUT : out std_logic ; -- middle button press display; oX : out std_logic_vector ( 7 downto 0 ); -- X axis. oY : out std_logic_vector ( 7 downto 0 ) -- Y axis. ); end component ps2 ; Esse exemplo est\u00e1 tamb\u00e9m documentando no manual do usu\u00e1rio: DE10-Standard_User_manual.pdf sec\u00e7\u00e3o: 3.6.12. Sec\u00e7\u00e3o: 3.6.12: Manual do usu\u00e1rio:","title":"Perif\u00e9rico Terasic: PS2-Terasic"},{"location":"Entrega-3/#glue-logic","text":"A l\u00f3gica de controle deve interfacear com o perif\u00e9rico da Terasic em todos os sinais de controle (todos menos PS2_CLK / PS2_DATA / iCLK_50 / 'iRST_n') de maneira abstrair o acesso mapeado em mem\u00f3ria para o perif\u00e9rico. A maneira mais f\u00e1cil de fazer isso \u00e9 definindo funcionalidades a endere\u00e7os do perif\u00e9rico, por exemplo: Offset Funcionalidade Tipo 0 Controle R/W 1 ox R 2 oy R 3 oLEFTBUT R ... ... A tabela anterior mapeia para cada endere\u00e7o do perif\u00e9rico uma funcionalidade diferente, nesse exemplo, se o usu\u00e1rio deseja ler a informa\u00e7\u00e3o do deslocamento y: oy , deve fazer a leitura no endere\u00e7o 2 desse perif\u00e9rico. A implementa\u00e7\u00e3o disso pode ser feita por um simples mux . O endere\u00e7o de controle, pode ser usado por exemplo, para inicializar a leitura no perif\u00e9rico da terasic (via o sinal iSTART ). Note que alguns endere\u00e7os s\u00e3o Read Only e outros Read/Write (tipo), isso se d\u00e1 porque n\u00e3o tem sentido (nem \u00e9 poss\u00edvel fisicamente) escrever me alguns endere\u00e7os.","title":"Glue Logic"},{"location":"Entrega-3/#rubrica-c-software","text":"Al\u00e9m da parte de HW, iremos desenvolver uma biblioteca em C que ir\u00e1 abstrair a interface com esse perif\u00e9rico. O perif\u00e9rico deve possuir um driver capaz de interagir com o perif\u00e9rico. Iremos padronizar algumas fun\u00e7\u00f5es a fim de definirmos um padr\u00e3o de interface: // Para rubrica C int PS2_init ( ..... ); // Inicializa o perif\u00e9rico int PS2_halt ( ..... ); // Desativa o perif\u00e9rico int PS2_read_clickLeft ( ..... ); // retorna se houve algum click","title":"(rubrica C) Software"},{"location":"Entrega-3/#rubrica-b-software-melhorando","text":"Adicionar as seguintes fun\u00e7\u00f5es: // Para rubrica B/A int PS2_read_x ( ..... ); // retorna o valor do movimento X int PS2_read_y ( ..... ); // retorna o valor do movimento y","title":"(rubrica B) Software (melhorando)"},{"location":"Entrega-3/#rubrica-a-irq","text":"Pode-se adicionar um sinal de interrup\u00e7\u00e3o ao perif\u00e9rico PS2-MM que servir\u00e1 para alertar o uC (NIOS) de um evento novo. Ser\u00e1 necess\u00e1rio adicionar as seguintes fun\u00e7\u00f5es: int PS2_en_irq ( ..... ); // Habilita interrup\u00e7\u00e3o int PS2_disable_irq ( ..... ); // Desabilita interrup\u00e7\u00e3o Esse driver deve estar distribu\u00eddo em dois arquivos: PS2-MM.c e PS2-MM.h .","title":"(rubrica A) IRQ"},{"location":"Entrega-3/#dicas","text":"\u00c9 sugerido os seguintes passos de execu\u00e7\u00e3o da entrega: Executar o exemplo PS2 da Terasic, e ver funcionar Entender os sinais do toplevel desse exemplo Desenhar um diagrama um pouco mais detalhado do PS2-MM, indicando quais sinais (nomes) ser\u00e3o conectados ao Glue Logic e quais dever\u00e3o ser conectados aos pinos da FPGA (conduit no PD) Implementar o 'PS2-MM', usando como base o perif\u00e9rico criado no tutorial. Crie uma nova pasta para o componente dentro da pasta atual IP (exe: PS2-MM) Copie o IP da terasic para essa pasta Crie seu componente dentro dessa pasta","title":"Dicas"},{"location":"Entrega-4/","text":"\ud83d\udc41 Entrega 4 \u00b6 O objetivo dessa entrega \u00e9 automatizarmos a compila\u00e7\u00e3o e deploy de novos programas para o target . Para isso, teremos que criar um Makefile que deve ser capaz de compilar e fazer o deploy do programa. Para isso temos diversas op\u00e7\u00f5es, sendo alguma delas: Transfer\u00eancia de arquivo via ssh: scp Montar do pasta do target no host remota via ssh: sshfs Via gdb server executa no target um gdb server que possibilita ao host transferir e debugar um bin\u00e1rio. Note que todas as solu\u00e7\u00f5es demandam de conex\u00e3o com a internet, para isso, siga o roteiro: Info HPS Ethernet . Rubrica: \u00b6 A Debuga um programar no target (via gdbserver) B Via Makefile consegue executar o bin\u00e1rio no target make run / make deploy C Criou um Makefile que compila o c\u00f3digo e faz o deploy para o target de um programa make deploy D Entregou somente tutorial I N\u00e3o entregou nada","title":"\ud83d\udc41 Entrega 4"},{"location":"Entrega-4/#entrega-4","text":"O objetivo dessa entrega \u00e9 automatizarmos a compila\u00e7\u00e3o e deploy de novos programas para o target . Para isso, teremos que criar um Makefile que deve ser capaz de compilar e fazer o deploy do programa. Para isso temos diversas op\u00e7\u00f5es, sendo alguma delas: Transfer\u00eancia de arquivo via ssh: scp Montar do pasta do target no host remota via ssh: sshfs Via gdb server executa no target um gdb server que possibilita ao host transferir e debugar um bin\u00e1rio. Note que todas as solu\u00e7\u00f5es demandam de conex\u00e3o com a internet, para isso, siga o roteiro: Info HPS Ethernet .","title":"\ud83d\udc41 Entrega 4"},{"location":"Entrega-4/#rubrica","text":"A Debuga um programar no target (via gdbserver) B Via Makefile consegue executar o bin\u00e1rio no target make run / make deploy C Criou um Makefile que compila o c\u00f3digo e faz o deploy para o target de um programa make deploy D Entregou somente tutorial I N\u00e3o entregou nada","title":"Rubrica:"},{"location":"Entrega-5/","text":"\ud83d\udc41 Entrega 5 \u00b6 Nessa entrega iremos criar um webserver no target que exibir\u00e1 uma imagem capturada por uma c\u00e2mera USB conectada ao SoC. Para isso ser\u00e1 necess\u00e1rio configurar o kernel para possuir o driver USB que lida com a c\u00e2mera USB, o buildroot para ter os programas que ser\u00e3o usados para criar o server e ler a imagem e um programa para orquestrar tudo isso. Dicas Driver webcam Plug no seu PC com linux e verifique qual driver ele utiliza. Acrescente o mesmo no target Aquisi\u00e7\u00e3o de imagens opencv v4l2grab Servidor web python flask apache node A entrega deve conter os arquivos de configura\u00e7\u00e3o (.config) do kernel e do buildroot assim como o programa do webserver. Rubrica: \u00b6 A Detecta movimento na imagem e acende o LED do SoC B Exibe a imagem em tempo real (v\u00eddeo) C Exibe a imagem est\u00e1tica (foto) D Entregou somente tutorial I N\u00e3o entregou nada \ud83d\udc41 Entrega 6 \u00b6 Desenhe um diagrama de blocos que explica o tutorial anterior (HPS+FPGA)! Nele deve conter: SDCARD ARM DDR3 FPGA perif\u00e9rico PIO","title":"\ud83d\udc41 Entrega 5"},{"location":"Entrega-5/#entrega-5","text":"Nessa entrega iremos criar um webserver no target que exibir\u00e1 uma imagem capturada por uma c\u00e2mera USB conectada ao SoC. Para isso ser\u00e1 necess\u00e1rio configurar o kernel para possuir o driver USB que lida com a c\u00e2mera USB, o buildroot para ter os programas que ser\u00e3o usados para criar o server e ler a imagem e um programa para orquestrar tudo isso. Dicas Driver webcam Plug no seu PC com linux e verifique qual driver ele utiliza. Acrescente o mesmo no target Aquisi\u00e7\u00e3o de imagens opencv v4l2grab Servidor web python flask apache node A entrega deve conter os arquivos de configura\u00e7\u00e3o (.config) do kernel e do buildroot assim como o programa do webserver.","title":"\ud83d\udc41 Entrega 5"},{"location":"Entrega-5/#rubrica","text":"A Detecta movimento na imagem e acende o LED do SoC B Exibe a imagem em tempo real (v\u00eddeo) C Exibe a imagem est\u00e1tica (foto) D Entregou somente tutorial I N\u00e3o entregou nada","title":"Rubrica:"},{"location":"Entrega-5/#entrega-6","text":"Desenhe um diagrama de blocos que explica o tutorial anterior (HPS+FPGA)! Nele deve conter: SDCARD ARM DDR3 FPGA perif\u00e9rico PIO","title":"\ud83d\udc41 Entrega 6"},{"location":"Entrega-6/","text":"\ud83d\udc41 Entrega 6 \u00b6 Desenhe um diagrama de blocos que explica o tutorial anterior (HPS+FPGA)! Nele deve conter: SDCARD ARM DDR3 FPGA perif\u00e9rico PIO","title":"\ud83d\udc41 Entrega 6"},{"location":"Entrega-6/#entrega-6","text":"Desenhe um diagrama de blocos que explica o tutorial anterior (HPS+FPGA)! Nele deve conter: SDCARD ARM DDR3 FPGA perif\u00e9rico PIO","title":"\ud83d\udc41 Entrega 6"},{"location":"Entrega-Extra-1/","text":"\ud83d\udc41 Entrega Opcional 1 \u00b6 Agora que vimos como faz para interfacear ARM com FPGA, que tal voc\u00ea adicionar o perif\u00e9rico que criou na entrega 2 (o peripheral_led ) e controlar os LEDs da FPGA via Linux com o seu pr\u00f3prio perif\u00e9rico? Modifique o platform designer adicionando o seu IP Anote o endere\u00e7o Compile o projeto, gere o .rbf e .dtb (copie para o SDcard) Modifique o main.c para acessar o seu perif\u00e9rico Teste Nota: \u00b6 Essa entrega extra entra como uma nota a mais na m\u00e9dia de valor A (ou seja, quem fez \u00e9 beneficiado e quem n\u00e3o quer fazer, tudo bem!)","title":"\ud83d\udc41 Entrega Opcional 1"},{"location":"Entrega-Extra-1/#entrega-opcional-1","text":"Agora que vimos como faz para interfacear ARM com FPGA, que tal voc\u00ea adicionar o perif\u00e9rico que criou na entrega 2 (o peripheral_led ) e controlar os LEDs da FPGA via Linux com o seu pr\u00f3prio perif\u00e9rico? Modifique o platform designer adicionando o seu IP Anote o endere\u00e7o Compile o projeto, gere o .rbf e .dtb (copie para o SDcard) Modifique o main.c para acessar o seu perif\u00e9rico Teste","title":"\ud83d\udc41 Entrega Opcional 1"},{"location":"Entrega-Extra-1/#nota","text":"Essa entrega extra entra como uma nota a mais na m\u00e9dia de valor A (ou seja, quem fez \u00e9 beneficiado e quem n\u00e3o quer fazer, tudo bem!)","title":"Nota:"},{"location":"Projeto-Entrega-1/","text":"Nessa primeira entrega voc\u00ea deve ter uma sugest\u00e3o de t\u00f3picos que gostaria de atacar e ter em mente qual hardware seria necess\u00e1rio para a execu\u00e7\u00e3o do mesmo, de onde voc\u00ea quer sair e onde quer chegar... Tecnologia Hardware Ponto de partida / Ponto de chegada Exemplos/ sites/ manuais que leu e achou que pode servir como refer\u00eancia","title":"Projeto Entrega 1"},{"location":"Projeto-Overview/","text":"O projeto final da disciplina deve ser um tutorial com alguma rela\u00e7\u00e3o aos objetivos de aprendizagem da mat\u00e9ria: Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Alguns exemplos de \u00e1reas que podem ser atacadas: Acelera\u00e7\u00e3o/ implementa\u00e7\u00e3o de algum algor\u00edtimo em hardware processamento de dados, FFT, compress\u00e3o, criptografia, ... HLD/ HLS/ OpenCL/ FPGA Amazon Compara\u00e7\u00e3o de performance entre diferentes tecnologias SoC vs GPU vs FPGA vs uC Sistema operacional Escalonador real time kernel linux, Android, RTOS embarcado Tecnologias/ Ferramentas \u00b6 A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) \ud83d\udc4d OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL .... Hardwares \u00b6 Temos os seguintes kits de desenvolvimento dispon\u00edvel: A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados com ele Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x Exemplos de temas/ coisas legais \u00b6 \u203c\ufe0f: demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c\ufe0f Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c\ufe0f Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux Rubrica \u00b6 O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Projeto Overview"},{"location":"Projeto-Overview/#tecnologias-ferramentas","text":"A seguir uma lista de tecnologias que podem ser estudadas no tutorial: HDL (VHDL/Verilog) Adicionar uma instru\u00e7\u00e3o customizada ao NIOS Platform designer Criar um sistema para controlar um dos rob\u00f4s de rob\u00f3tica Criar um perif\u00e9rico para interfacear com o mundo externo (ler teclado/ motor/ fita de Led/ ...) High Level Synthesis (HLS) Criar um perif\u00e9rico que acelera uma fun\u00e7\u00e3o ( example ) \ud83d\udc4d OpenCL Criar um hardware que acelera uma fun\u00e7\u00e3o Terasic Manual ( example ) Linux real time / otimiza\u00e7\u00e3o energ\u00e9tica / \ud83d\udc4d boot time / aplica\u00e7\u00f5es / \ud83d\udc4d Android / openCL ....","title":"Tecnologias/ Ferramentas"},{"location":"Projeto-Overview/#hardwares","text":"Temos os seguintes kits de desenvolvimento dispon\u00edvel: A seguir, eu tentei resumir os hardwares dispon\u00edveis no Insper e as respectivas tecnologias que podem ser utilizados com ele Kit Empresa Tecnologia vhdl HLS OpenCL Linux OpenCV Cuda Arria 10 SoC Intel FPGA + ARM x x x x x DE10-Standard Intel FPGA + ARM x x x x x DE10-nano-soc Intel FPGA + ARM x x x x x Terasic SoC SoM Intel FPGA + ARM x x x x x DE5a-NET-DDR4 Intel FPGA x x x x ZedBoard Xilinx FPGA + ARM x x x x x inst\u00e2ncia F1 AWS FPGA x Jetson TK2 NVIDIa ARM + GPU x x x","title":"Hardwares"},{"location":"Projeto-Overview/#exemplos-de-temas-coisas-legais","text":"\u203c\ufe0f: demanda uma dedica\u00e7\u00e3o maior Criando um SoftProcessor e API para controlar um Drone OpenCV acelerado com OpenCL - ZedBoard \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com HLS/OpenCL que acelera uma fun\u00e7\u00e3o na FPGA Processamento de imagem/ compress\u00e3o de dados/ criptografia/ fft/ ... \u203c\ufe0f Criar uma aplica\u00e7\u00e3o com OpenCL na AWS Embarcando ROS no SoC-FPGA (primeiro passo para controlarmos os rob\u00f4s de rob\u00f3tica com a FPGA) \u203c\ufe0f Usar o LCD LT24 com o Linux (Comunica\u00e7\u00e3o ARM-FPGA) Real Time kernel \u00e9 realmente tempo real? Estudo de lat\u00eancia... Otimizando o boot time do linux Executando Android na DE10-Standard Interface gr\u00e1ficas em sistemas embarcados (exe: criar um totem de pagamento) Device driver: Criar um driver no linux para algum sensor de dist\u00e2ncia \u203c\ufe0f Criar um perif\u00e9rico para controlar a fita de LED RGB e criar um driver para o Linux controlar BanchMark entre os diferentes kits de desenvolvimento Usando o yocto como alternativa ao buildroot para gerar o Linux","title":"Exemplos de temas/ coisas legais"},{"location":"Projeto-Overview/#rubrica","text":"O tutorial deve ser de autoria do aluno e auto contido, publicado na wiki da disciplina. A rubrica \u00e9 incremental, para tirar A precisa ter alcan\u00e7ado o B antes... Tutoriais em ingl\u00eas s\u00e3o acrescidos de \u00bd conceito. A \u00c9 um tutorial de um tema novo Possui um guia ao final do tutorial em como se aprofundar no tema Possui claro quais s\u00e3o os pontos cr\u00edticos, e o que fazer em caso de erro B O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais por\u00e9m avan\u00e7a a onde os outros n\u00e3o foram O tutorial mescla teoria e pr\u00e1tica de maneira aprofundada, mas sem travar o fluxo do mesmo C O tutorial \u00e9 uma jun\u00e7\u00e3o de outros tutoriais ou deriva\u00e7\u00e3o de um exemplo j\u00e1 existente Tutorial \u00e9 reproduz\u00edvel (outra pessoa consegue seguir e chegar nos mesmos resultados) Possui um pouco de teoria, sem aprofundamento Possui refer\u00eancias externas","title":"Rubrica"},{"location":"Sobre/","text":"Metodologia \u00b6 A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos. Objetivos de Aprendizagem \u00b6 Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional) Avalia\u00e7\u00e3o \u00b6 Entregas das APS Tutorial","title":"Sobre"},{"location":"Sobre/#metodologia","text":"A disciplina \u00e9 baseada em tutoriais, onde os conceitos te\u00f3ricos e pr\u00e1ticos s\u00e3o apresentados. O aluno deve seguir o material conforme \u00e9 apresentado (na sequ\u00eancia) pois o mesmo foi concebido de maneira incremental. Cada tutorial (ou s\u00e9rie de) possui uma entrega (APS) que deve ser realizada, o tutorial \u00e9 ponto de entrada para a entrega, por\u00e9m vai al\u00e9m em compreens\u00e3o e conceitos.","title":"Metodologia"},{"location":"Sobre/#objetivos-de-aprendizagem","text":"Formular solu\u00e7\u00f5es que satisfazem requisitos de hardware e software de projetos com FPGA-SoC (System-on-a-chip) Integrar em um prot\u00f3tipo solu\u00e7\u00e3o para um sistema embarcado com requisitos de processamento e/ou tempo real via FPGA-SoC Interfacear diferentes m\u00f3dulos em um sistema embarcado (processadores, firmware e sistema operacional)","title":"Objetivos de Aprendizagem"},{"location":"Sobre/#avaliacao","text":"Entregas das APS Tutorial","title":"Avalia\u00e7\u00e3o"},{"location":"Tutorial-FPGA-NIOS-IP/","text":"Tutorial 3 - FPGA - IP \u00b6 Nesse tutorial deseja-se desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa, o perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\". Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Tutorial-FPGA-NIOS-IP IP Cores \u00b6 Intelectual Proprety Core (IP Core) s\u00e3o componentes descritos em HDL que possibilitam ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m da centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Altera IP cores Platform Desginer \u00b6 O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido a padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento. Barramentos \u00b6 A Altera define dois tipos de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no plataform designer. Avalon \u00b6 Documenta\u00e7\u00e3o completa dos tipos do barramento AVALON : https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o : Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity. Projeto \u00b6 Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto : Tutorial-FPGA-NIOS e renomeei para: Tutorial-FPGA-NIOS-IP . Iremos agora trabalhar nessa nova pasta. Criando um perif\u00e9rico \u00b6 Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver (.c e .h) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1rio uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 claramente um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio. Avalon Slave Memory Mapped \u00b6 Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset (`reset), lembre que projeto digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixado em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)? Especifica\u00e7\u00e3o \u00b6 Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....). Gerar HDL que representa o perif\u00e9rico com interface Avalon \u00b6 Partindo da entidade fornecida (peripheral_MM), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse generic poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Tutorial-FPGA-NIOS-IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto. Configurando path \u00b6 Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fontes que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente) Criando componente \u00b6 S\u00f3 adicionar o arquivo HDL ( .vhd ou .v verilog) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso : File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente. Files \u00b6 Na aba Files adicione o arquivo peripheral-LED.vhd : Files Syntesis Files add file peripheral-LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral-LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese. Signals & Interfaces \u00b6 Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir : Finalizando \u00b6 Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC : Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus : tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral-LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd E edite para: add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd Utilizando o componente no PD \u00b6 Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como : Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model Utilizando o componente no topLevel.vhd \u00b6 Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no topLevel.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o topLevel.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 . Firmware \u00b6 Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um novo BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral-LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m). Executando \u00b6 Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1. Simulando \u00b6 Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem : 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado. Configurando o bsp \u00b6 Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!! ModelSim \u00b6 No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Altera. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo. Entrega 3 \u00b6 Siga para a terceira entrega: Entega 3","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#tutorial-3-fpga-ip","text":"Nesse tutorial deseja-se desenvolver um perif\u00e9rico customizado para o processador NIOS, esse perif\u00e9rico ser\u00e1 dedicado ao controle dos LEDs da placa, o perif\u00e9rico ter\u00e1 um banco de registradores interno para seu controle, e interface de \"I/O mapeado em mem\u00f3ria\".","title":"Tutorial 3 - FPGA - IP"},{"location":"Tutorial-FPGA-NIOS-IP/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Modelsim Simulator Entrega no git: Pasta: Tutorial-FPGA-NIOS-IP","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-NIOS-IP/#ip-cores","text":"Intelectual Proprety Core (IP Core) s\u00e3o componentes descritos em HDL que possibilitam ser utilizados em m\u00faltiplos projetos de Hardware. O Platform Designer (PD) fornece al\u00e9m da interface visual de conex\u00e3o um padr\u00e3o de comunica\u00e7\u00e3o entre os componentes, facilitando assim o uso desses IPs. Al\u00e9m da centenas de projetos espalhados pela internet (github), existe um reposit\u00f3rio muito completo de IP cores opensource que concentra grande variedade de projeto: opencores As empresas tamb\u00e9m disponibilizando IPs, pagos e gratuitos: Altera IP cores","title":"IP Cores"},{"location":"Tutorial-FPGA-NIOS-IP/#platform-desginer","text":"O PD \u00e9 uma ferramenta integradora de IPs, com ela \u00e9 muito simples inserirmos e criarmos componentes que ser\u00e3o utilizados para formar um sistema mais completo. Como no caso do tutorial passado onde usamos uma s\u00e9rie de componentes para criar nosso projeto. Esses componentes s\u00e3o de certa forma IPs (simples como o PIO e complexo como o NIOS). A integra\u00e7\u00e3o dos IPs no PD se da devido a padroniza\u00e7\u00e3o da comunica\u00e7\u00e3o entre esses componentes, que \u00e9 dada via o barramento.","title":"Platform Desginer"},{"location":"Tutorial-FPGA-NIOS-IP/#barramentos","text":"A Altera define dois tipos de barramento de dados para o PD: Avalon e AXI . O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que tamb\u00e9m \u00e9 utilizado no plataform designer.","title":"Barramentos"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon","text":"Documenta\u00e7\u00e3o completa dos tipos do barramento AVALON : https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/manual/mnl_avalon_spec.pdf O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o : Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Streaming Interface (Avalon-ST) \u2014 an interface that supports the unidirectional flow of data, including multiplexed streams, packets, and DSP data. Avalon Memory Mapped Interface (Avalon-MM) \u2014 an address-based read/write interface typical of master\u2013slave connections. Avalon Conduit Interfae \u2014 an interface type that accommodates individual signals or groups of signals that do not fit into any of the other Avalon types. You can connect conduit interfaces inside a Platform Designer system. Or, you can export them to make connections to other modules in the design or to FPGA pins. Avalon Tri-State Conduit Interface (an interface to support connections to off-chip peripherals. Multiple peripherals can share pins through signal multiplexing, reducing the pin count of the FPGA and the number of traces on the PCB. Avalon Interrupt Interface \u2014 an interface that allows components to signal events to other components. Avalon Clock Interface \u2014 an interface that drives or receives clocks. Avalon Reset Interface \u2014 an interface that provides reset connectivity.","title":"Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#projeto","text":"Note Vamos melhorar o projeto passado, fa\u00e7a uma c\u00f3pia da pasta do projeto : Tutorial-FPGA-NIOS e renomeei para: Tutorial-FPGA-NIOS-IP . Iremos agora trabalhar nessa nova pasta.","title":"Projeto"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-um-periferico","text":"Vamos criar um novo componente que ser\u00e1 capaz de controlar os LEDs com maior autonomia. Roteiro a ser seguido: Especifica\u00e7\u00e3o Gerar HDL que representa o perif\u00e9rico com interface Avalon Criar o componente no Platform Designer Associar arquivos ao componente Defini\u00e7\u00f5es gerais Associar as portas do componente com os sinais do barramento Usar componente no projeto Criar driver (.c e .h) Simular Implementar/ Testar Rever especifica\u00e7\u00e3o (1.) Primeiramente precisamos definir o papel principal desse perif\u00e9rico e seu fluxo de dados. Com isso ser\u00e1 poss\u00edvel definir se o perif\u00e9rico \u00e9 do tipo: Master ou Slave e se sua interface \u00e9 do tipo Memory Mapped ou Streaming . Um perif\u00e9rico pode possuir mais de uma interface, por exemplo: Um perif\u00e9rico que ir\u00e1 processar um \u00e1udio em tempo real pode ter at\u00e9 tr\u00eas interfaces: O mesmo ir\u00e1 receber o \u00e1udio via a interface streaming e retornar o dado por outra interface de streaming , por\u00e9m ser\u00e1 necess\u00e1rio uma terceira interface para controle desse perif\u00e9rico, muito provavelmente do tipo Memory Mapped . \u00c9 poss\u00edvel transmitir pacotes de comando pela interface streaming, mas isso torna o projeto mais complexo. O nosso simples perif\u00e9rico ir\u00e1 simplesmente receber configura\u00e7\u00f5es para acionar o LED, sem nenhum fluxo cont\u00ednuo ou intenso de dados, sendo a interface mais apropriada a do perif\u00e9rico mapeado em mem\u00f3ria . Al\u00e9m disso, nosso perif\u00e9rico exclusivo para controle do LED \u00e9 claramente um slave do sistema, j\u00e1 que ele deve ser controlado por outra parte do sistema (no nosso caso o uC) para agir conforme necess\u00e1rio.","title":"Criando um perif\u00e9rico"},{"location":"Tutorial-FPGA-NIOS-IP/#avalon-slave-memory-mapped","text":"Para nosso perif\u00e9rico se comunicar com o processador precisamos implementar o padr\u00e3o de comunica\u00e7\u00e3o utilizado pelo NIOS. Podemos optar por implementar o padr\u00e3o completo ou apenas uma parte de sua especifica\u00e7\u00e3o. Por exemplo, se nosso perif\u00e9rico n\u00e3o faz uso do waitrequest ou byteenable podemos optar por n\u00e3o implementar esses sinais. A seguir um exemplo dos sinais de um perif\u00e9rico mapeado em mem\u00f3ria que possui como interface com o Avalon-MM-Slave . entity peripheral_MM is port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- Avalon Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_MM ; Note que a primeira parte do componente define um sinal de clock ( clk ) e um sinal de reset (`reset), lembre que projeto digitais em FPGA devem ser na maioria das vezes s\u00edncronos. A segunda parte \u00e9 a defini\u00e7\u00e3o dos sinais que ir\u00e3o ser conectados no barramento para acesso de outros perif\u00e9ricos. Lembrem que estamos criando um componente mapeado em mem\u00f3ria, logo o mesmo deve ter comportamento e interface similar ao de uma mem\u00f3ria. avs_address : Endere\u00e7o de acesso ao componente, no caso, 4 bits. avs_read : Indica que \u00e9 um acesso de leitura avs_readdata : Dado que ser\u00e1 retornado ao Master dado um acesso de leitura. avs_write : Indica que \u00e9 um acesso de escrita avs_writedata : Dado que \u00e9 transmitido ao componente dado um acesso de escrita. O tamanho da palavra do avs_readdata e do avs_writadata \u00e9 definido pelo componente e n\u00e3o \u00e9 fixado em 32 bits como no exemplo, pode assumir outros valores. Uma escrita ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo O endere\u00e7o que o master escreve no perif\u00e9rico \u00e9 composto por: addr offset por\u00e9m o slave s\u00f3 possui acesso ao offset . Perif\u00e9rico recebe: avs_address , avs_write = '1' e avs_writedata . Uma leitura ao perif\u00e9rico \u00e9 dada da seguinte forma: Master endere\u00e7a perif\u00e9rico Endere\u00e7o absoluto \u00e9 traduzido em relativo Perif\u00e9rico recebe: avs_adddress e avs_read = '1' Perif\u00e9rico atualiza: avs_readdata Perguntas O barramento AVALON define outros sinais, responda a seguir sobre alguns desses sinais: waitrequest Qual o papel do waitrequest? Quem aciona o waitrequest (Slave ou Master)? byteenable Qual o papel do byteenable? Quem aciona o byteenable (Slave ou Master)?","title":"Avalon Slave Memory Mapped"},{"location":"Tutorial-FPGA-NIOS-IP/#especificacao","text":"Nosso perif\u00e9rico ser\u00e1 no come\u00e7o bem simples, apenas para entendermos todo o processo de desenvolvimento de um perif\u00e9rico e o seu uso. O perif\u00e9rico que iremos desenvolver ser\u00e1 um substituto ao perif\u00e9rico PIO fornecido pela Altera, utilizado no projeto do pisca LED com o NIOS. Nosso perif\u00e9rico ser\u00e1 mapeado em mem\u00f3ria e possuir\u00e1 um conduit (sa\u00edda) onde ser\u00e1 realizada o acionamento dos LEDs: O acesso ao nosso perif\u00e9rico ser\u00e1 por uma palavra de 32 bits (para mater um padr\u00e3o com o NIOS) e ter\u00e1 dois registradores REG_CONFIG e REG_DATA : REG_CONIFG : Registrador que controla o perif\u00e9rico, no nosso caso, ir\u00e1 ter somente um bit de: Enable / Disable ( bit0 Enable/Disable ) REG_DATA : Registrador que possui o valor de cada LED ( bit0 LED0 ; bit1 LED1 ....).","title":"Especifica\u00e7\u00e3o"},{"location":"Tutorial-FPGA-NIOS-IP/#gerar-hdl-que-representa-o-periferico-com-interface-avalon","text":"Partindo da entidade fornecida (peripheral_MM), podemos criar um componente que implementa parcialmente a especifica\u00e7\u00e3o anterior, nessa implementa\u00e7\u00e3o n\u00e3o temos os dois registradores ( REG_CONFIG e REG_DATA ), temos apenas a funcionalidade do REG_DATA . Note que a implementa\u00e7\u00e3o faz uso de um generic para definir a quantidade de LEDs que esse perif\u00e9rico controla. Esse generic poder\u00e1 ser configurado pela interface gr\u00e1fica do Plataform Designer, tornando um componente customizado. Info Crie um arquivo chamado: peripheral_LED.vhd e salve na pasta do projeto : Tutorial-FPGA-NIOS-IP/IP/ Ser\u00e1 necess\u00e1rio criar a pasta IP library IEEE ; use IEEE.std_logic_1164. all ; use IEEE.std_logic_unsigned. all ; use IEEE.numeric_std. all ; use work. all ; entity peripheral_LED is generic ( LEN : natural := 4 ); port ( -- Gloabals clk : in std_logic := '0' ; reset : in std_logic := '0' ; -- I/Os LEDs : out std_logic_vector ( LEN - 1 downto 0 ) := ( others => '0' ); -- Avalion Memmory Mapped Slave avs_address : in std_logic_vector ( 3 downto 0 ) := ( others => '0' ); avs_read : in std_logic := '0' ; avs_readdata : out std_logic_vector ( 31 downto 0 ) := ( others => '0' ); avs_write : in std_logic := '0' ; avs_writedata : in std_logic_vector ( 31 downto 0 ) := ( others => '0' ) ); end entity peripheral_LED ; architecture rtl of peripheral_LED is begin process ( clk ) begin if ( reset = '1' ) then LEDs <= ( others => '0' ); elsif ( rising_edge ( clk )) then if ( avs_address = \"0001\" ) then -- REG_DATA if ( avs_write = '1' ) then LEDs <= avs_writedata ( LEN - 1 downto 0 ); end if ; end if ; end if ; end process ; end rtl ; Limita\u00e7\u00f5es dessa implementa\u00e7\u00e3o N\u00e3o possui um registrador de configura\u00e7\u00e3o: REG_CONFIG N\u00e3o \u00e9 poss\u00edvel ler: REG_DATA via barramento Avalon impede a aplica\u00e7\u00e3o de m\u00e1scaras! Poder\u00edamos j\u00e1 nessa etapa testar o componente, criando um testbench para excitar o m\u00f3dulo e verificar seu comportamento. Grande parte do desenvolvimento de um projeto de hardware \u00e9 gasto nos testes, que podem ser t\u00e3o complexos quanto o pr\u00f3prio m\u00f3dulo. Vamos pular essa etapa aqui, iremos simular em um n\u00edvel mais alto.","title":"Gerar HDL que representa o perif\u00e9rico com interface Avalon"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-path","text":"Agora iremos adicionar o nosso perif\u00e9rico no Platform Designer , esse novo componente que ser\u00e1 criado ser\u00e1 incorporado na ferramenta, para isso: Precisamos indicar para o PD o local que ele deve buscar para encontrar por c\u00f3digos fontes que n\u00e3o fazem parte do cat\u00e1logo padr\u00e3o, para isso: Tools Options IP Search Path Adicione a pasta IP rec\u00e9m criada. E agora remova o componente PIO: Remova o PIO que controlava os LEDs (agora iremos fazer o controle pelo nosso componente)","title":"Configurando path"},{"location":"Tutorial-FPGA-NIOS-IP/#criando-componente","text":"S\u00f3 adicionar o arquivo HDL ( .vhd ou .v verilog) n\u00e3o \u00e9 suficiente para o PD reconhecer o componente, precisamos criar um segundo arquivo ( *_hw.tcl ) que \u00e9 lido pelo PD, esse arquivo possuir\u00e1 todas as configura\u00e7\u00f5es e descri\u00e7\u00f5es do novo componente. Para isso : File New Component E uma interface gr\u00e1fica de configura\u00e7\u00e3o do componente ser\u00e1 exibida. A primeira parte \u00e9 referente a descri\u00e7\u00e3o do pr\u00f3prio componente. De o nome desse componente de : peripheral_LED e preencha sua descri\u00e7\u00e3o. J\u00e1 na aba Files temos as informa\u00e7\u00f5es de quais arquivos pertencem ao componente.","title":"Criando componente"},{"location":"Tutorial-FPGA-NIOS-IP/#files","text":"Na aba Files adicione o arquivo peripheral-LED.vhd : Files Syntesis Files add file peripheral-LED.vhd Clique em Analyze Synthesis Files : isso far\u00e1 com que a ferramenta fa\u00e7a uma breve an\u00e1lise dos arquivos HDL e detecte as interfaces do componente. Note o atributo do arquivo: Top-level File , isso indica que o peripheral-LED.vhd \u00e9 o arquivo principal desse componente, se tiv\u00e9ssemos um desenvolvimento hier\u00e1rquico do componente, nessa etapa adicionar\u00edamos v\u00e1rios arquivos e dever\u00edamos configurar qual deles \u00e9 o toplevel. Na sec\u00e7\u00e3o VHDL Simulation Files Copy from Synthesis Files Note que se n\u00e3o adicionarmos esse arquivo nessa sec\u00e7\u00e3o, na hora de simular o projeto o componente estaria vazio. Porqu\u00ea o padr\u00e3o n\u00e3o \u00e9 o de automaticamente copiar os arquivos da s\u00edntese para a simula\u00e7\u00e3o? Pois nem sempre conseguimos simular o que ser\u00e1 sintetizado. Pense no caso desse componente ser um controlador de mem\u00f3ria, se formos simular n\u00e3o teremos a mem\u00f3ria f\u00edsica para o controlador acessar e a simula\u00e7\u00e3o n\u00e3o funcionar\u00e1. Uma solu\u00e7\u00e3o seria de ter dois componentes, um para simula\u00e7\u00e3o (que imita a mem\u00f3ria) e outro para s\u00edntese.","title":"Files"},{"location":"Tutorial-FPGA-NIOS-IP/#signals-interfaces","text":"Nessa sec\u00e7\u00e3o iremos configurar as interfaces do nosso componente, e como o PD ir\u00e1 interpret\u00e1-las quando formos conectar ao resto do sistema. Note que algumas interfaces j\u00e1 foram detectadas pelo PD, por\u00e9m temos um erro que ser\u00e1 corrigido. Nas interfaces padr\u00f5es note que o Component Editor j\u00e1 detectou uma interface: avalon_slave_0 clock reset Isso aconteceu pelos nomes da entidade do peripheral_led . Vamos primeiramente editar o avalon_slave_0 . Clique na interface e note que a ferramenta indica um erro : Failure Error: avalon_slave_0_1: Interface must have an associated reset Vamos associar ter que associar um sinal der reset a interface (parte sequ\u00eancia do IP), para isso : avalon_slave_0 Associated Reset reset Podemos notar ainda pelo diagrama (e pela mensagem de erro) que a ferramenta interpretou de forma errada o nosso sinal LEDs , pertencente a entidade do componente: -- I/Os LEDs : out std_logic_vector(LEN - 1 downto 0) := (others => '0'); Note pelo diagrama de blocos que o PD atribui essa sa\u00edda como sendo parte do barramento Avalon: writerequestvalid_n , o que n\u00e3o \u00e9 verdade. Para corrigir isso, precisamos de uma nova aba que n\u00e3o \u00e9 padr\u00e3o de exibi\u00e7\u00e3o, no component builder clique em: Component builder View Signals Essa nova aba permite verificarmos (e associarmos) as entradas e sa\u00eddas da entidade (toplevel) com sinais e tipos de sinais definido pelo PD. Iremos indicar agora para a ferramenta que o sinal LEDs deve ser interpretado como um conduite , edite os sinais como na figura a seguir :","title":"Signals &amp; Interfaces"},{"location":"Tutorial-FPGA-NIOS-IP/#finalizando","text":"Verifique os sinais e o diagrama de bloco antes de continuar e clique em Finish . Quando o componente for gerado, ele automaticamente ir\u00e1 aparecer no cat\u00e1logo de componentes que podem ser inseridos no SoC : Por\u00e9m o arquivo de configura\u00e7\u00e3o desse componente (.tcl) foi salvo na pasta raiz do projeto do Quartus : tutorial-SoftProcessor-IP/peripheral_LED_hw.tcl Esse arquivo .tcl descreve todas as configura\u00e7\u00f5es realizadas anteriormente no componente. O mais natural \u00e9 que esse arquivo esteja na mesma localidade (pasta IP) que os c\u00f3digos HDL. Mova essa arquivo para: tutorial-SoftProcessor-IP/IP/peripheral_LED_hw.tcl Agora precisamos editar o arquivo .tcl para atualizarmos o local do arquivo peripheral-LED.vhd , procure pela sec\u00e7\u00e3o files set : Antes add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH IP / peripheral-LED.vhd E edite para: add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd TOP_LEVEL_FILE ... add_fileset_file peripheral-LED.vhd VHDL PATH peripheral-LED.vhd","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-pd","text":"Agora adicione o componente no projeto e fa\u00e7a as conex\u00f5es corretas (como se fosse outro componente), exporte o sinal dos LEDs, o resultado final deve ser algo como : Gere o componente: Clique em Generate HDL Generate . Marque a op\u00e7\u00e3o: \u2705 Create a Simulation Model","title":"Utilizando o componente no PD"},{"location":"Tutorial-FPGA-NIOS-IP/#utilizando-o-componente-no-toplevelvhd","text":"Precisamos agora modificar o componente inserido no topLevel, para isso no PD gere novamente o template de utiliza\u00e7\u00e3o : No Platform Designer: Generate Show Instatiation Template VHDL No meu caso o resultado foi: component niosHello is port ( buts_export : in std_logic_vector(2 downto 0) := (others => 'X'); -- export clk_clk : in std_logic := 'X'; -- clk reset_reset_n : in std_logic := 'X'; -- reset_n leds_name : out std_logic_vector(3 downto 0) -- name ); end component niosHello; u0 : component niosHello port map ( buts_export => CONNECTED_TO_buts_export, -- buts.export clk_clk => CONNECTED_TO_clk_clk, -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n, -- reset.reset_n leds_name => CONNECTED_TO_leds_name -- leds.name ); Devemos inserir agora esse componente com a nova interface ( leds_name ) no topLevel.vhd . Voc\u00ea deve fazer essa etapa com cuidado. Esses nomes podem alterar entre vers\u00f5es da ferramenta. Editando o topLevel.vhd : Recompile Salve, compile o projeto e programe a FPGA Podemos analisar agora o RTL do projeto e mais especificamente o do componente criado: Verificamos que a ferramenta inferiu um registrador de 4 bits para armazenar o valor dos LEDs, um Mux para indicar se os registradores ser\u00e3o ou n\u00e3o atualizados com um novo valor e um comparador para verificar se o endere\u00e7o \u00e9 equivalente a 0x01 .","title":"Utilizando o componente no topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS-IP/#firmware","text":"Devemos agora escrever um firmware que ser\u00e1 executado no NIOS e que acesse e controle nosso perif\u00e9rico. Para isso ser\u00e1 necess\u00e1rio criarmos um novo BSP para o projeto. Abra o NIOS II Software Build ... e refa\u00e7a a etapa do tutorial anterior com o novo SoC e adicione o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ //#define SIM // LED Peripheral #define REG_DATA_OFFSET 1 int main ( void ){ unsigned int led = 0 ; unsigned int * p_led = ( unsigned int * ) PERIPHERAL_LED_0_BASE ; #ifndef SIM printf ( \"Embarcados++ \\n \" ); #endif while ( 1 ){ if ( led < 4 ){ * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); #ifndef SIM usleep ( 500000 ); // remover durante a simula\u00e7\u00e3o #endif } else { led = 0 ; } }; return 0 ; } O firmware utiliza o peripheral-LED para controlar os LEDs da placa, note que o acesso dessa vez \u00e9 feito pelo ponteiro p_led e n\u00e3o mais pela fun\u00e7\u00e3o da Alteara IOWR_32DIRECT (deveria funcionar tamb\u00e9m).","title":"Firmware"},{"location":"Tutorial-FPGA-NIOS-IP/#executando","text":"Execute o firmware no kit de desenvolvimento e verifique se sua funcionalidade est\u00e1 correta. Lembre que o HW j\u00e1 deve estar programado (via quartus), caso contr\u00e1rio n\u00e3o funcionar\u00e1.","title":"Executando"},{"location":"Tutorial-FPGA-NIOS-IP/#simulando","text":"Uma das grandes vantagens de trabalharmos com SoftProcessor \u00e9 que temos acesso ao seu c\u00f3digo fonte (criptografado ou n\u00e3o) e isso possibilita que possamos simular todo o sistema, verificando suas funcionalidades internas, comunica\u00e7\u00e3o da CPU com os perif\u00e9ricos, interface do firmware com o resto do sistema. Vamos nessa etapa simular a interface do NIOS com o nosso perif\u00e9rico e verificar se est\u00e1 tudo certo. Note que no c\u00f3digo anterior, o printf foi comentando, assim como o delay de 50000 us, que no lugar foi inserido um de 1us. Isso foi feito para acelerar a simula\u00e7\u00e3o e verificarmos mais rapidamente o acesso do NIOS ao perif\u00e9rico, que acontece na linha : * ( p_led + REG_DATA_OFFSET ) = ( 0x1 << led ++ ); Nesse momento, o NIOS envia um comando ao barramento no endere\u00e7o PERIPHERAL_LED_0_BASE + REG_DATA_OFFSET , o comando carrega a mensagem : 0x01 << led , gravando no registrador REG_DATA qual LED deve ser acionado.","title":"Simulando"},{"location":"Tutorial-FPGA-NIOS-IP/#configurando-o-bsp","text":"Para obtermos um resultado mais r\u00e1pido \u00e9 poss\u00edvel ativarmos uma op\u00e7\u00e3o no bsp chamada de: enable_sim_opitimize . Quando ativada, o bin\u00e1rio compilado s\u00f3 poder\u00e1 ser usado para simula\u00e7\u00e3o, n\u00e3o pode ser embarcado no HW! . Com essa op\u00e7\u00e3o temos um ganho significativo no tempo de execu\u00e7\u00e3o do modelo no modelsim. Al\u00e9m de configurarmos a otimiza\u00e7\u00e3o durante a simula\u00e7\u00e3o, iremos desativar o stdin, stdout, stderr para a simula\u00e7\u00e3o ficar ainda mais r\u00e1pida, caso contr\u00e1rio teremos que esperar por muito tempo at\u00e9 verificarmos o resultado do c\u00f3digo. Note que a simula\u00e7\u00e3o abrange todo o HW desde o processador at\u00e9 o barramento e perif\u00e9ricos. Note Para simularmos 1 ms de execu\u00e7\u00e3o do HW ser\u00e1 necess\u00e1rio muito mais que 1 ms de esfor\u00e7o computacional! O tempo pode chegar a unidades de hora!!","title":"Configurando o bsp"},{"location":"Tutorial-FPGA-NIOS-IP/#modelsim","text":"No Eclipse , ap\u00f3s ter compilado o projeto: Run Run configuration Nios II ModelSim O simulador a ser utilizado \u00e9 o modelsim da Mentor, o mais completo do mercado e fornecido com algumas customiza\u00e7\u00f5es pela Altera. No modelsim, iremos adicionar os sinais que desejamos visualizar, para isso, siga o que indica a figura a seguir: Ap\u00f3s adicionar todos os sinais que fazem parte do perif\u00e9rico led_peripheral iremos executar 500 us de simula\u00e7\u00e3o: Ap\u00f3s a simula\u00e7\u00e3o finalizar, note os valore dos sinais avs_write , avs_writedata , avs_LEDs e como eles mudam no tempo em respeito ao que foi feito no c\u00f3digo.","title":"ModelSim"},{"location":"Tutorial-FPGA-NIOS-IP/#entrega-3","text":"Siga para a terceira entrega: Entega 3","title":"Entrega 3"},{"location":"Tutorial-FPGA-NIOS/","text":"Tutorial 2 - FPGA - NIOS \u00b6 Nesse tutorial iremos criar e customizar um soft processor (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado. Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-NIOS Soft processor \u00b6 Projetos em HDL n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 algo imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um c\u00f3digo em HDL: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA,..) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente/ open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Existem SoCs que n\u00e3o s\u00e3o implementados em FPGAs, mas ainda assim concentram uma s\u00e9rie de outros componentes em um \u00fanico chip, \u00e9 o caso dos SoCs utilizados em celulares. Esses dispositivos, muitas vezes utilizam SoCs que possuem al\u00e9m da parte de processamento, sistemas respons\u00e1veis pela comunica\u00e7\u00e3o pela: interface gr\u00e1fica; gest\u00e3o des c\u00e2meras; comunica\u00e7\u00e3o 4g; .... A Qualcomm \u00e9 uma das empresas lideres do setor com o dispositivo SnapDragon . Plataform Designer \u00b6 O Platform Designer era chamado de QSYS, ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela INtel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar **Intellectual property cores ** (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Quer se aprofundar? Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer NIOS \u00b6 NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits e controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas a seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: Combinacional; Multiciclo; Estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Para maiores detalhes consulte o documento : Nios II Custom Instruction User Guide Criando um simples SoC \u00b6 Nesse etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta do projeto da Entrega-1 renomeando para Tutorial-FPGA-NIOS Abra essa nova pasta Tutorial-FPGA-NIOS no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos: On-Chip Memmory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Type: NIOS II/e Voc\u00ea deve obter algo similar a: Conectando Clock e Reset \u00b6 Os perif\u00e9ricos do Qsys s\u00e3o como sistemas independentes (pensem em cada bloco \u00e9 como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel muito mais superior. O Qsys ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 , conforme figura a seguir: Conectando barramento \u00b6 A Altera define dois tipos de barramento de dados para o Qsys: Avalon e AXI. O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Interface Specifications O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transforma uma forma de comunica\u00e7\u00e3o na outra. Em um futuro breve n\u00f3s iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Melhorando o entendimento do sistema. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado no MIPS harvard ele possui dois barramentos, um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware, s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a principio compartilhada entre o dado e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Vamos portanto conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e vamos conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir: Mapa de mem\u00f3ria \u00b6 Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. S\u00e3o duas as maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map Configurando NIOS \u00b6 Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a aba: Parameters . Em Vector configure : Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos). Export \u00b6 A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados para fora do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal. Finalizando \u00b6 Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosHello.qsys na pasta do projeto e clique em Generate HDL , para o Qsys gerar o projeto. Utilizando o componente \u00b6 Ainda no Qsys, clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Anote isso, iremos utilizar na pr\u00f3xima etapa! component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; u0 : component niosHello port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no Qsys possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces: Finalizando \u00b6 Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foi configurado. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no Qsys: No Quartus: Project Add/remove files in project e adicione o arquivo: niosHello/synthesis/niosHello.qip Resultando em: Modificando o topLevel.vhd \u00b6 Agora \u00e9 necess\u00e1rio modificar o topLevel.vhd para incluir o componente niosHello rec\u00e9m criado. Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). library IEEE ; use IEEE.std_logic_1164. all ; entity topLevel is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity topLevel ; architecture rtl of topLevel is component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; begin u0 : component niosHello port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Compilando e gravando Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA. Programando o NIOS - Soft processor \u00b6 Agora que temos o projeto criado e a FPGA gravada com o novo hardware, que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H**ardware **A**bstraction **L**ayer - HAL) ou como a Intel chama: **B**oard **S**uport **P**ackage (BSP), na qual extrai-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no **NIOS II - Eclipse , dois projetos ser\u00e3o criados: Um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT Criando o projeto \u00b6 No Quartus Tools NIOS II - Eclipse No NIOS II - Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosHello.sopc Esse arquivo \u00e9 criado pelo Qsys quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name: niosHello Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosHello : firmware a ser embarcado niosHello_bsp : Board support package para o firmware Analisando e configurando o bsp \u00b6 No Project Explorer do Eclipse, clique com o bot\u00e3o direito no: Project Explorer niosHello_bsp NIOS II bsp Editor Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas : sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA). Jtag-UART small driver \u00b6 Note que no nosso projeto no QSYS o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver Gerando o bsp \u00b6 Toda vez que o bsp for editado ou o hardware alterado (qsys) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosHello_bsp NIOS II Generate BSP Embarcando! \u00b6 Com o bsp editado abra agora a pasta niosHello e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console : Blink LED \u00b6 Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS! Entrega 2 \u00b6 Siga para a Entrega 2","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#tutorial-2-fpga-nios","text":"Nesse tutorial iremos criar e customizar um soft processor (sistema embarcado com um processador e perif\u00e9rico), embarcar na FPGA e escrever um c\u00f3digo para ele. Ao final, vamos ter os mesmos LEDs que do projeto anterior, com opera\u00e7\u00e3o simular, mas agora sendo controlados por um programa e n\u00e3o por um hardware dedicado.","title":"Tutorial 2 - FPGA - NIOS"},{"location":"Tutorial-FPGA-NIOS/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-NIOS","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-NIOS/#soft-processor","text":"Projetos em HDL n\u00e3o s\u00e3o muito flex\u00edveis, cada altera\u00e7\u00e3o no projeto implica na modifica\u00e7\u00e3o do Hardware o que n\u00e3o \u00e9 algo t\u00e3o simples. Al\u00e9m da dificuldade de implementar as modifica\u00e7\u00f5es, temos o tempo de teste e compila\u00e7\u00e3o do projeto que n\u00e3o \u00e9 algo imediato. Uma solu\u00e7\u00e3o para tornar o projeto mais flex\u00edvel \u00e9 o de tornar os LEDs controlados n\u00e3o por uma l\u00f3gica dedicada mas sim por um hardware que possa executar uma s\u00e9rie de instru\u00e7\u00f5es: um microcontrolador. Como a FPGA pode implementar circuitos l\u00f3gicos digitais, \u00e9 poss\u00edvel sintetizarmos um microcontrolador na FPGA e fazermos esse uC controlar os LEDS (Sim!! o uC \u00e9 um hardware descrito em HDL). Agora a altera\u00e7\u00e3o na l\u00f3gica de controle depende do programa que ser\u00e1 executado no uC, tornando o projeto muito mais flex\u00edvel. O ARM tamb\u00e9m \u00e9 um c\u00f3digo em HDL: https://www.arm.com/about/newsroom/arm-offers-free-access-to-cortex-m0-processor-ip-to-streamline-embedded-soc-design.php Processadores que s\u00e3o sintetiz\u00e1veis em dispositivos l\u00f3gicos program\u00e1veis (FPGA,..) s\u00e3o chamados de Soft Processor . Diversos s\u00e3o os Soft Processors dispon\u00edveis comercialmente/ open source: NIOS II: Intel MicroBlazer: Xilinx LEON: Gaisler (aerospacial/ SPARCV8) dentre outros A adi\u00e7\u00e3o de perif\u00e9ricos e funcionalidades extras ao Soft Processor (podemos por exemplo colocar um gerenciador de mem\u00f3ria, timers, controlador de rede, ...) faz com que o sistema passe a ser chamado de System On Chip (SoC). Hard Processor s\u00e3o os microprocessadores tradicionais, que n\u00e3o sofrem altera\u00e7\u00e3o de HW. Existem SoCs que n\u00e3o s\u00e3o implementados em FPGAs, mas ainda assim concentram uma s\u00e9rie de outros componentes em um \u00fanico chip, \u00e9 o caso dos SoCs utilizados em celulares. Esses dispositivos, muitas vezes utilizam SoCs que possuem al\u00e9m da parte de processamento, sistemas respons\u00e1veis pela comunica\u00e7\u00e3o pela: interface gr\u00e1fica; gest\u00e3o des c\u00e2meras; comunica\u00e7\u00e3o 4g; .... A Qualcomm \u00e9 uma das empresas lideres do setor com o dispositivo SnapDragon .","title":"Soft processor"},{"location":"Tutorial-FPGA-NIOS/#plataform-designer","text":"O Platform Designer era chamado de QSYS, ainda da para achar muitas coisas com essa refer\u00eancia O Platform Designer \u00e9 um software dispon\u00edvel pela INtel e integrado no Quartus que possibilita desenvolvermos sistemas complexos de forma simples e visual. Com ele podemos adicionar e conectar **Intellectual property cores ** (IP Core) para desenvolvermos uma aplica\u00e7\u00e3o de maneira r\u00e1pida e visual. Os IP cores podem ser da pr\u00f3pria Intel , de terceiros ou propriet\u00e1rios. Quer se aprofundar? Tem um curso online que mostra como o PD funciona: Introduction to Platform Designer","title":"Plataform Designer"},{"location":"Tutorial-FPGA-NIOS/#nios","text":"NIOS \u00e9 o soft processor fornecido pela Altera-Intel e integrado na ferramenta. O NIOS \u00e9 baseado na arquitetura do MIPS com arquitetura de 32 bits e controle de exce\u00e7\u00f5es, barramento de comunica\u00e7\u00e3o, controle de mem\u00f3ria, ... . A figura a seguir descreve os componentes essenciais do NIOS (azul) e o que \u00e9 customiz\u00e1vel (cinza). Processor Architecture O NIOS suporta que novas instru\u00e7\u00f5es sejam adicionadas a seu instruction set, essas instru\u00e7\u00f5es s\u00e3o implementadas em HDL e inseridas no core de forma transparente ao desenvolvedor. Existem graus de instru\u00e7\u00f5es customizadas: Combinacional; Multiciclo; Estendidas; Que faz uso do banco de registradores original ou aquelas que adicionam novos registradores. Para maiores detalhes consulte o documento : Nios II Custom Instruction User Guide","title":"NIOS"},{"location":"Tutorial-FPGA-NIOS/#criando-um-simples-soc","text":"Nesse etapa iremos adicionar um processador e a infraestrutura m\u00ednima necess\u00e1ria para sua opera\u00e7\u00e3o, iremos incluir no projeto: Uma interface de clock Uma mem\u00f3ria (de dados e programa) O processador (NIOS II) Um perif\u00e9rico PIO (para gerenciar sa\u00eddas digitais) Um JTAG-UART, para suportar debug via print. Para come\u00e7armos: Copie a pasta do projeto da Entrega-1 renomeando para Tutorial-FPGA-NIOS Abra essa nova pasta Tutorial-FPGA-NIOS no Quartus Abra o Platform Designer: Quartus Tools Platform Designer Adicione os seguintes perif\u00e9ricos: On-Chip Memmory (RAM or ROM Intel FPGA IP) Type: RAM Total Memory size: 32768 bytes JTAG UART Intel FPGA IP Default PIO (Parallel I/O) Intel FPGA IP Width: 6 Direction: Output NIOS II Type: NIOS II/e Voc\u00ea deve obter algo similar a:","title":"Criando um simples SoC"},{"location":"Tutorial-FPGA-NIOS/#conectando-clock-e-reset","text":"Os perif\u00e9ricos do Qsys s\u00e3o como sistemas independentes (pensem em cada bloco \u00e9 como um chip), que necessitam ser conectados no m\u00ednimo a um Clock e a um Reset. O sistema pode operar em diversos dom\u00ednios de clocks e resets diferentes, portanto essa conex\u00e3o deve ser feita pelo desenvolvedor. Pense nessa etapa como sendo similar ao port map do VHDL, por\u00e9m em um n\u00edvel muito mais superior. O Qsys ser\u00e1 respons\u00e1vel por fazer a compatibilidade dos sinais para n\u00f3s. Conecte todos os sinais de clocks e reset aos sinais clk e clk_rst do perif\u00e9rico clk_0 , conforme figura a seguir:","title":"Conectando Clock e Reset"},{"location":"Tutorial-FPGA-NIOS/#conectando-barramento","text":"A Altera define dois tipos de barramento de dados para o Qsys: Avalon e AXI. O barramento Avalon \u00e9 a principal maneira de conectar um perif\u00e9rico ao NIOS (processador), j\u00e1 o AXI \u00e9 o padr\u00e3o de barramento do ARM, que ser\u00e1 utilizado posteriormente. O barramento Avalon define basicamente dois tipos de comunica\u00e7\u00e3o: Memory Mapped (MM) e Avalon Streaming Interface (ST) , conforme descri\u00e7\u00e3o a seguir extra\u00eddo da documenta\u00e7\u00e3o : Avalon Interface Specifications O principal barramento do NIOS \u00e9 o memory mapped , e todo perif\u00e9rico conectado ao NIOS (processador) dever\u00e1 possuir esse barramento. A Altera disponibiliza conversores e adaptadores para podermos transforma uma forma de comunica\u00e7\u00e3o na outra. Em um futuro breve n\u00f3s iremos desenvolver um perif\u00e9rico propriet\u00e1rio que ser\u00e1 conectado nesse barramento. Melhorando o entendimento do sistema. Note que o NIOS possui dois barramentos do tipo MM : data_master e intruction_master . Como o NIOS II \u00e9 um processador baseado no MIPS harvard ele possui dois barramentos, um para dados e outro para o programa (instru\u00e7\u00e3o). Nessa nossa topologia de hardware, s\u00f3 possu\u00edmos uma \u00fanica mem\u00f3ria ( on_chip_memory ) que ser\u00e1 a principio compartilhada entre o dado e programa (temos uma perda de efici\u00eancia aqui, j\u00e1 que a mem\u00f3ria s\u00f3 poder\u00e1 ser acessada por um barramento por vez), depois vamos melhorar isso! Vamos portanto conectar todos os perif\u00e9ricos ( PIO , UART e OnChip Memory ) ao barramento data_master e vamos conectar somente a mem\u00f3ria ( OnChip Memory ) ao barramento de instru\u00e7\u00e3o ( instruction_master ), resultando na montagem a seguir:","title":"Conectando barramento"},{"location":"Tutorial-FPGA-NIOS/#mapa-de-memoria","text":"Ap\u00f3s realizarmos as conex\u00f5es, devemos especificar o endere\u00e7o de mem\u00f3ria de cada perif\u00e9rico. S\u00e3o duas as maneiras de realizarmos isso: manual ou autom\u00e1tica. Na manual, pode-se alocar os perif\u00e9ricos em endere\u00e7os de mem\u00f3ria a sua escolha, tomando os cuidados para n\u00e3o haver sobreposi\u00e7\u00e3o dos endere\u00e7os. Na autom\u00e1tica, deixamos para a ferramenta alocar os perif\u00e9ricos nos endere\u00e7os corretos. Para realizar a aloca\u00e7\u00e3o autom\u00e1tica: System Assign Base Addrress . Para visualizar o resultado, clique na aba: Address Map","title":"Mapa de mem\u00f3ria"},{"location":"Tutorial-FPGA-NIOS/#configurando-nios","text":"Agora precisamos configurar o NIOS para utilizar a mem\u00f3ria rec\u00e9m conectada a ele, de um clique duplo no NIOS, para abrir a aba: Parameters . Em Vector configure : Reset vector memory: onchip_memory Execption vector memory: onchip_memory Dica O nome onchip_memory pode alterar de acordo com o seu projeto e o endere\u00e7o tamb\u00e9m (isso depende da ordem na qual os componentes foram inseridos).","title":"Configurando NIOS"},{"location":"Tutorial-FPGA-NIOS/#export","text":"A coluna export do Platform Designer indica quais sinais ser\u00e3o exportados para fora do sistema, pense nesses sinais como sendo os que ter\u00e3o contato com o mundo externo (ser\u00e3o mapeados para os pinos no topLevel). De um clique duplo na coluna export na linha do sinal external_connection do component PIO e de o nome de LEDs para esse sinal.","title":"Export"},{"location":"Tutorial-FPGA-NIOS/#finalizando","text":"Ao final de tudo voc\u00ea deve obter algo como a figura a seguir: Salve o projeto com o nome niosHello.qsys na pasta do projeto e clique em Generate HDL , para o Qsys gerar o projeto.","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#utilizando-o-componente","text":"Ainda no Qsys, clique em: Generate Show Instatiation Template , selecione VHDL como linguagem HDL. E voc\u00ea deve obter algo como: Dica Anote isso, iremos utilizar na pr\u00f3xima etapa! component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; u0 : component niosHello port map ( clk_clk => CONNECTED_TO_clk_clk , -- clk.clk reset_reset_n => CONNECTED_TO_reset_reset_n , -- reset.reset_n leds_export => CONNECTED_TO_leds_export -- leds.export ); Isso \u00e9 um atalho de como devemos utilizar esse componente no nosso projeto. Esse trecho de c\u00f3digo indica que o projeto rec\u00e9m criado no Qsys possui tr\u00eas interfaces externas: clk_clk , reset_reset_n e leds_export . Esse sinais ter\u00e3o que ser mapeados no topLevel para seus respectivos pinos. Esse nomes podem mudar no seu projeto! O esquem\u00e1tico (gerado pelo Platform Designer View Schematic ) ilustra o SoC rec\u00e9m criado e suas interfaces:","title":"Utilizando o componente"},{"location":"Tutorial-FPGA-NIOS/#finalizando_1","text":"Clique em finish e deixe tudo como o padr\u00e3o, agora o qsys ir\u00e1 criar o sistema e todos os componentes que nele foi configurado. O Quartus dar\u00e1 uma alerta indicando que \u00e9 necess\u00e1rio incluir alguns arquivos no Quartus para que ele tenha acesso ao projeto rec\u00e9m criado no Qsys: No Quartus: Project Add/remove files in project e adicione o arquivo: niosHello/synthesis/niosHello.qip Resultando em:","title":"Finalizando"},{"location":"Tutorial-FPGA-NIOS/#modificando-o-toplevelvhd","text":"Agora \u00e9 necess\u00e1rio modificar o topLevel.vhd para incluir o componente niosHello rec\u00e9m criado. Note que n\u00e3o estamos utilizando o sinal de reset (o _n indica que o reset \u00e9 negativo, ou seja, em 0 ). library IEEE ; use IEEE.std_logic_1164. all ; entity topLevel is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- clock.clk -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity topLevel ; architecture rtl of topLevel is component niosHello is port ( clk_clk : in std_logic := 'X' ; -- clk reset_reset_n : in std_logic := 'X' ; -- reset_n leds_export : out std_logic_vector ( 5 downto 0 ) -- export ); end component niosHello ; begin u0 : component niosHello port map ( clk_clk => fpga_clk_50 , -- clk.clk reset_reset_n => '1' , -- reset.reset_n leds_export => fpga_led_pio -- leds.export ); end rtl ; Compilando e gravando Compile o projeto e analise o RTL, verifique se est\u00e1 de acordo com o esperado. Grave o projeto na FPGA.","title":"Modificando o topLevel.vhd"},{"location":"Tutorial-FPGA-NIOS/#programando-o-nios-soft-processor","text":"Agora que temos o projeto criado e a FPGA gravada com o novo hardware, que inclui o processador NIOS. Precisamos gerar e gravar um programa que realiza o controle dos LEDs. Para isso iremos abrir a IDE NIOS Software Build for Eclipse (SBT) que possui todo o toolchain necess\u00e1rio para desenvolvermos firmware para o NIOS. No Quartus: Tools Nios II Software Build ... e uma interface do eclipse ser\u00e1 aberta. Quando desenvolvemos projetos para sistemas SoCs temos um problema: o hardware n\u00e3o \u00e9 padronizado. Como tudo \u00e9 customizado existe um problema que deve-se ser tratado, a interface entre o hardware criado e o toolchain de software (compilador, linker...). A Altera resolveu isso criando uma camada de abstra\u00e7\u00e3o de hardware ( H**ardware **A**bstraction **L**ayer - HAL) ou como a Intel chama: **B**oard **S**uport **P**ackage (BSP), na qual extrai-se informa\u00e7\u00f5es do Platform Designer para ser utilizado pela toolchain de compila\u00e7\u00e3o (GCC). Quando formos criar um projeto no **NIOS II - Eclipse , dois projetos ser\u00e3o criados: Um que cont\u00e9m o firmware a ser gravado no NIOS e outro (BSP) que cont\u00e9m informa\u00e7\u00f5es relevantes sobre o Hardware para uso no firmware e toolchain. Para mais informa\u00e7\u00f5es: https://www.altera.com/products/processors/design-tools.html#SBT","title":"Programando o NIOS - Soft processor"},{"location":"Tutorial-FPGA-NIOS/#criando-o-projeto","text":"No Quartus Tools NIOS II - Eclipse No NIOS II - Eclipse File NIOS II Application and BSP from template SOPC Information File Name : Na pasta do projeto, procure pelo arquivo : niosHello.sopc Esse arquivo \u00e9 criado pelo Qsys quando o projeto \u00e9 compilado, e est\u00e1 na pasta do projeto. Project name: niosHello Ap\u00f3s avan\u00e7ar o SBT ir\u00e1 criar duas pastas de projeto : niosHello : firmware a ser embarcado niosHello_bsp : Board support package para o firmware","title":"Criando o projeto"},{"location":"Tutorial-FPGA-NIOS/#analisando-e-configurando-o-bsp","text":"No Project Explorer do Eclipse, clique com o bot\u00e3o direito no: Project Explorer niosHello_bsp NIOS II bsp Editor Isso abrir\u00e1 uma interface de configura\u00e7\u00e3o para o bsp. Diversas s\u00e3o as op\u00e7\u00f5es de configura\u00e7\u00f5es, algumas delas : sys_clk_timer : perif\u00e9rico utilizado para bibliotecas de delay (n\u00e3o inserimos no Platform Designer) timestamp_timer : perif\u00e9rico que seria utilizado pelo timestamp stdin , stdout , sterr : perif\u00e9rico utilizado pelo stantard IO do C, no nosso caso: jtat_uart_0 (poderia ser outro). Note Note que a regi\u00e3o de mem\u00f3ria do stack j\u00e1 est\u00e1 configurada para a onchip_memory . Aqui ter\u00edamos a op\u00e7\u00e3o de mapear para outro local (no caso do sistema possuir outras mem\u00f3rias, tais como mem\u00f3rias DDR externas a FPGA).","title":"Analisando e configurando o bsp"},{"location":"Tutorial-FPGA-NIOS/#jtag-uart-small-driver","text":"Note que no nosso projeto no QSYS o perif\u00e9rico jtag-uart n\u00e3o teve seu sinal de interrup\u00e7\u00e3o conectado no NIOS, isso dificulta o acesso a uart, j\u00e1 que o firmware n\u00e3o ser\u00e1 interrompido caso um novo dado chegue (gets) ou na transmiss\u00e3o (puts). O driver deve ficar fazendo um polling no perif\u00e9rico para verificar o envio e recep\u00e7\u00e3o dos dados. Para isso funcionar, devemos ativar uma op\u00e7\u00e3o no driver do jtag_avalon no bsp: BSP Editor Drivers jtag_uart enable_small_driver","title":"Jtag-UART small driver"},{"location":"Tutorial-FPGA-NIOS/#gerando-o-bsp","text":"Toda vez que o bsp for editado ou o hardware alterado (qsys) deve-se regenerar o bsp : De volta no eclipse, devemos gerar os arquivos bsp. Para isso clique em: niosHello_bsp NIOS II Generate BSP","title":"Gerando o bsp"},{"location":"Tutorial-FPGA-NIOS/#embarcando","text":"Com o bsp editado abra agora a pasta niosHello e note que existe inicializada com um arquivo: hello_world.c que imprime via JTAG-UART uma string. Insira o c\u00f3digo a seguir no eclipse: #include <stdio.h> int main () { printf ( \"Hello from Nios II! \\n \" ); return 0 ; } Com o hello_word.c aberto (\u00e9 necess\u00e1rio para o eclipse saber qual projeto voc\u00ea quer embarcar), clique em: Run Run NIOS II Hardware . Isso far\u00e1 com que a aplica\u00e7\u00e3o seja descarregada na mem\u00f3ria do Qsys que alocamos para o Nios e que o hardware seja reiniciado para executar o firmware. Quando o firmware for executado, abra a aba do eclipse NIOS II console :","title":"Embarcando!"},{"location":"Tutorial-FPGA-NIOS/#blink-led","text":"Edite main para conter o c\u00f3digo a seguir: #include <stdio.h> #include \"system.h\" #include <alt_types.h> #include <io.h> /* Leiutura e escrita no Avalon */ int delay ( int n ){ unsigned int delay = 0 ; while ( delay < n ){ delay ++ ; } } int main ( void ){ unsigned int led = 0 ; printf ( \"Embarcados++ \\n \" ); while ( 1 ){ if ( led <= 5 ){ IOWR_32DIRECT ( PIO_0_BASE , 0 , 0x01 << led ++ ); usleep ( 50000 ); } else { led = 0 ; } }; return 0 ; } Embarque no NIOS e veja o resultado nos LEDS!","title":"Blink LED"},{"location":"Tutorial-FPGA-NIOS/#entrega-2","text":"Siga para a Entrega 2","title":"Entrega 2"},{"location":"Tutorial-FPGA-RTL/","text":"Tutorial 1 - FPGA - RTL \u00b6 Nessa primeira etapa do projeto iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. Iremos passar por todo o processo de desenvolvimento de um projeto em FPGA, desde sua cria\u00e7\u00e3o at\u00e9 a valida\u00e7\u00e3o no HW. Pr\u00e9-requisitos \u00b6 Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-RTL Quartus \u00b6 Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como RTL_Blink_LED Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA : Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Outra refer\u00eancia Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf Criando o topLevel \u00b6 TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: RTL_Blink_LED.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity RTL_Blink_LED is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity RTL_Blink_LED ; architecture rtl of RTL_Blink_LED is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim por ora. Configurando o topLevel \u00b6 No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar. Verificando \u00b6 Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo. I/Os \u00b6 Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes. Pin Assigment \u00b6 Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel. LEDs \u00b6 No manual da placa (p\u00e1gina 22( temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: Essa tabela define o sinal (que voc\u00ea pode dar qualquer nome), o pino na FPGA na qual est\u00e1 conectado, uma breve descri\u00e7\u00e3o e o n\u00edvel el\u00e9trico de sinal na qual o pino deve ser configurado. Note que a placa DE10-Standard possui 10 LEDs conectados a FPGA. Clocks \u00b6 Tamb\u00e9m temos a defini\u00e7\u00e3o do clock (sec. 3.5, manual da placa): Note que existem 5 diferentes clocks que podem ser utilizado, os FPGA_CLKx_50 s\u00e3o clocks de 50Mhz conectados a FPGA e os HPS_CLKx_25 s\u00e3o sinais de clocks conectados exclusivamente ao ARM (HPS). Como estamos desenvolvendo na FPGA e n\u00e3o temos ainda nenhum requisito de performance, podemos escolher qualquer pino de clock FPGA_CLKx_50 . Vamos usar (escolhido aleat\u00f3rio) o pino CLOCK3_50 . Dom\u00ednios de Clock Tenha em mente que a FPGA trabalha com diferentes dom\u00ednios de clock, quando o projeto possui temporaliza\u00e7\u00e3o cr\u00edtica, essa escolha n\u00e3o pode ser casual. Inserindo no Quartus \u00b6 Agora que temos os pinos referentes aos sinais da FPGA, devemos inserir essa informa\u00e7\u00e3o no Quartus. Existem duas maneiras de fazermos isso: Pin Planner Ferramenta gr\u00e1fica e interativa Assigments Pin Planer Assigments Editor Maneira mais completa e com maior flexibilidade Assigments Assigments Editor Iremos utilizar a princ\u00edpio o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do topLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Edite a coluna Location utilizando como refer\u00eancia a tabela anterior. Note que o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 \u00e9 o 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o Timing Requirements not met \u00b6 Note que ap\u00f3s compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes. Synopsys Design Constraints File \u00b6 Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : RTL_Blink_LED.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto. RTL Viewer \u00b6 RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em : Tools -> NetList Viewers -> RTL Viewer . Gravando \u00b6 Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra : Tools -> Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux . Exerc\u00edcios \u00b6 : F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade Entrega 1 \u00b6 Siga para a Entrega 1","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#tutorial-1-fpga-rtl","text":"Nessa primeira etapa do projeto iremos criar um hardware dedicado na FPGA para controlar os LEDs com base nos sinais de entradas dos bot\u00f5es. Iremos passar por todo o processo de desenvolvimento de um projeto em FPGA, desde sua cria\u00e7\u00e3o at\u00e9 a valida\u00e7\u00e3o no HW.","title":"Tutorial 1 - FPGA - RTL"},{"location":"Tutorial-FPGA-RTL/#pre-requisitos","text":"Para seguir esse tutorial, \u00e9 necess\u00e1rio: Hardware: DE10-Standard e acess\u00f3rios Softwares: Quartus 18.01 Documentos: DE10-Standard_User_manual.pdf Entrega no git: Pasta: Tutorial-FPGA-RTL","title":"Pr\u00e9-requisitos"},{"location":"Tutorial-FPGA-RTL/#quartus","text":"Primeiro, devemos criar um novo projeto no software Quartus. No Quartus: File \u27a1\ufe0f New Project Wizard Directory, Name, Top-Level Entity Escolha o destino como sendo seu reposit\u00f3rio. nomeio o projeto como RTL_Blink_LED Project Type Empty Project Add Files N\u00e3o vamos adicionar nenhum arquivo por enquanto. Family, Device & Board Settings Procure pela FPGA : Family: Cyclone V Name: 5CSXFC6D6F31C6 \ud83c\udd97 Finalize o Wizard Outra refer\u00eancia Se precisar de outro material como refer\u00eancia, tem um tutorial da Terasic: DE10-Standard_My_First_Fpga.pdf","title":"Quartus"},{"location":"Tutorial-FPGA-RTL/#criando-o-toplevel","text":"TopLevel \u00e9 o nome do m\u00f3dulo mais superior em desenvolvimento hier\u00e1rquico onde, geralmente os sinais da entidade (in/out,...) ser\u00e3o mapeados a pinos do hardware (conex\u00e3o com o mundo externo). Vamos adicionar um arquivo ao projeto rec\u00e9m criado: File New VHDL File File save as name: RTL_Blink_LED.vhd \ud83c\udd97 Inicialize o arquivo com o conte\u00fado a seguir: toplevel source file library IEEE ; use IEEE.std_logic_1164. all ; entity RTL_Blink_LED is port ( -- Gloabals fpga_clk_50 : in std_logic ; -- I/Os fpga_led_pio : out std_logic_vector ( 5 downto 0 ) ); end entity RTL_Blink_LED ; architecture rtl of RTL_Blink_LED is -- signal signal blink : std_logic := '0' ; begin process ( fpga_clk_50 ) variable counter : integer range 0 to 25000000 := 0 ; begin if ( rising_edge ( fpga_clk_50 )) then if ( counter < 10000000 ) then counter := counter + 1 ; else blink <= not blink ; counter := 0 ; end if ; end if ; end process ; fpga_led_pio ( 0 ) <= blink ; fpga_led_pio ( 1 ) <= blink ; fpga_led_pio ( 2 ) <= blink ; fpga_led_pio ( 3 ) <= blink ; fpga_led_pio ( 4 ) <= blink ; fpga_led_pio ( 5 ) <= blink ; end rtl ; Info Esse c\u00f3digo poderia ser mais elegante, mas vamos deixar assim por ora.","title":"Criando o topLevel"},{"location":"Tutorial-FPGA-RTL/#configurando-o-toplevel","text":"No Quartus devemos dizer qual entidade \u00e9 a topLevel, como o VHDL n\u00e3o define uma padr\u00e3o para isso, qualquer entidade pode ser configurada como top. No quartus: Project Set as Top-Level Entity Esse comando ir\u00e1 configurar o arquivo atual como sendo o topLevel do projeto. Note que o Quartus atribui ao topLevel a entidade como sendo o nome do arquivo, se por algum motivo (que acontece) o nome do arquivo n\u00e3o for igual ao da entidade isso n\u00e3o ir\u00e1 funcionar.","title":"Configurando o topLevel"},{"location":"Tutorial-FPGA-RTL/#verificando","text":"Vamos verificar se est\u00e1 tudo certo por enquanto realizando uma compila\u00e7\u00e3o completa no projeto. Para isso: Processing Start Compilation . Aguarde !! as compila\u00e7\u00f5es de HDL podem demorar bastante tempo.","title":"Verificando"},{"location":"Tutorial-FPGA-RTL/#ios","text":"Lembre que o topLevel \u00e9 a entidade que ser\u00e1 mapeada com o mundo externo, nesse caso os sinais: fpga_clk_50 ; fpga_led_pio ; devem ser conectados aos pinos da FPGA que est\u00e3o conectados nesses dispositivos (clock de 50 MHz; Seis LEDs). Note o erro que o Quartus gerou quando mandamos ele compilar o projeto ( \"Show Critical Warnings Messages\" ): Failure Critical Warning (169085): No exact pin location assignment(s) for 6 pins of 6 total pins. For the list of pins please refer to the I/O Assignment Warnings table in the fitter report. Esse erro indica que do topLevel 6 sinais n\u00e3o foram mapeados para os pinos correspondentes.","title":"I/Os"},{"location":"Tutorial-FPGA-RTL/#pin-assigment","text":"Devemos indicar para a ferramenta quais s\u00e3o os pinos e qual padr\u00e3o de sinal ele deve utilizar para cada um dos sinais definidos na entidade do topLevel.","title":"Pin Assigment"},{"location":"Tutorial-FPGA-RTL/#leds","text":"No manual da placa (p\u00e1gina 22( temos as defini\u00e7\u00f5es de como os pinos da FPGA foram utilizados na placa: Essa tabela define o sinal (que voc\u00ea pode dar qualquer nome), o pino na FPGA na qual est\u00e1 conectado, uma breve descri\u00e7\u00e3o e o n\u00edvel el\u00e9trico de sinal na qual o pino deve ser configurado. Note que a placa DE10-Standard possui 10 LEDs conectados a FPGA.","title":"LEDs"},{"location":"Tutorial-FPGA-RTL/#clocks","text":"Tamb\u00e9m temos a defini\u00e7\u00e3o do clock (sec. 3.5, manual da placa): Note que existem 5 diferentes clocks que podem ser utilizado, os FPGA_CLKx_50 s\u00e3o clocks de 50Mhz conectados a FPGA e os HPS_CLKx_25 s\u00e3o sinais de clocks conectados exclusivamente ao ARM (HPS). Como estamos desenvolvendo na FPGA e n\u00e3o temos ainda nenhum requisito de performance, podemos escolher qualquer pino de clock FPGA_CLKx_50 . Vamos usar (escolhido aleat\u00f3rio) o pino CLOCK3_50 . Dom\u00ednios de Clock Tenha em mente que a FPGA trabalha com diferentes dom\u00ednios de clock, quando o projeto possui temporaliza\u00e7\u00e3o cr\u00edtica, essa escolha n\u00e3o pode ser casual.","title":"Clocks"},{"location":"Tutorial-FPGA-RTL/#inserindo-no-quartus","text":"Agora que temos os pinos referentes aos sinais da FPGA, devemos inserir essa informa\u00e7\u00e3o no Quartus. Existem duas maneiras de fazermos isso: Pin Planner Ferramenta gr\u00e1fica e interativa Assigments Pin Planer Assigments Editor Maneira mais completa e com maior flexibilidade Assigments Assigments Editor Iremos utilizar a princ\u00edpio o Pin Planner para inserir esses pinos, para isso: Assignments Pin Planner . A interface do Pin Planner exibe os pinos/ bancos dispon\u00edveis da FPGA para serem alocados aos sinais do topLevel. Note que a coluna Fitter Location j\u00e1 possui pinos alocados aos sinais, isso foi gerado automaticamente pelo Quartus na etapa de Filter , por\u00e9m eles n\u00e3o correspondem aos pinos reais que desejamos utilizar. Edite a coluna Location utilizando como refer\u00eancia a tabela anterior. Note que o I/O Standard n\u00e3o reflete o definido no manual que \u00e9 \u00e9 o 3.3V CMOS . Voc\u00ea deve alterar essa coluna de 2.5V CMOS (Default) para 3.3-V LVTTL . Flexibilidade FPGA Normalmente atribu\u00edmos a FPGA uma flexibilidade l\u00f3gica, mas note a flexibilidade que ela possui quanto a defini\u00e7\u00e3o de n\u00edvel de sinal de cada pino. Isso permite ao desenvolvedor de hardware in\u00fameras op\u00e7\u00f5es de uso e de novas configura\u00e7\u00f5es. Feche a ferramenta e abra o Assignment Editor : Assignments Assignments Editor . Note que as mesmas informa\u00e7\u00f5es inseridas anteriormente est\u00e3o nesse editor. Na verdade, todas as configura\u00e7\u00f5es da FPGA s\u00e3o exibidas no Assignments Editor e apenas algumas no Pin Planner . Recompile Recompile o projeto e note que n\u00e3o existe mais erros de aloca\u00e7\u00e3o","title":"Inserindo no Quartus"},{"location":"Tutorial-FPGA-RTL/#timing-requirements-not-met","text":"Note que ap\u00f3s compilar o projeto ainda possu\u00edmos um erro critico : Failure Critical Warning (332012): Synopsys Design Constraints File file not found. A Synopsys Design Constraints File is required by the TimeQuest Timing Analyzer to get proper timing constraints. Without it, the Compiler will not properly optimize the design. Critical Warning (332148): Timing requirements not met Info (11105): For recommendations on closing timing, run Report Timing Closure Recommendations in the TimeQuest Timing Analyzer. Esse erro \u00e9 referente a n\u00e3o termos indicado para o Quartus qual a frequ\u00eancia de opera\u00e7\u00e3o do nosso sistema. Como a frequ\u00eancia n\u00e3o est\u00e1 definida a etapa de Fitter and Assembler n\u00e3o consegue otimizar o projeto corretamente, resultando nesse erro. Assembler aqui \u00e9 diferente do assembler de um programa como C . De uma olhada nessa refer\u00eancia para maiores detalhes.","title":"Timing Requirements not met"},{"location":"Tutorial-FPGA-RTL/#synopsys-design-constraints-file","text":"Devemos adicionar um novo arquivo ao projeto que ir\u00e1 indicar para a ferramenta quais s\u00e3o as condi\u00e7\u00f5es de contorno do projeto. Para isso: File New File Synopsys Design Constraints File Save As : RTL_Blink_LED.sdc Adicione ao arquivo o seguinte conte\u00fado: # 50MHz board input clock create_clock -period 20 [get_ports fpga_clk_50] # Automatically apply a generate clock on the output of phase-locked loops (PLLs) derive_pll_clocks Essas linhas indicam para a ferramenta que o sinal fpga_clk_50 \u00e9 um sinal de clock com frequ\u00eancia 50MHz (20 ns de per\u00edodo) e \u00e9 para a inferir outros clocks autom\u00e1ticos (caso um PLL seja utilizado). 1^: https://www.altera.com/support/support-resources/design-examples/design-software/timinganalyzer/exm-tq-basic-sdc-template.html Recompile Recompile o projeto e note que n\u00e3o existe mais erros cr\u00edticos no projeto.","title":"Synopsys Design Constraints File"},{"location":"Tutorial-FPGA-RTL/#rtl-viewer","text":"RTL Viewer \u00e9 uma maneira gr\u00e1fica de verificar se o c\u00f3digo em HDL foi interpretado corretamente pela ferramenta, e uma \u00f3tima maneira de verificar se a descri\u00e7\u00e3o do hardware est\u00e1 correta. Para isso v\u00e1 em : Tools -> NetList Viewers -> RTL Viewer .","title":"RTL Viewer"},{"location":"Tutorial-FPGA-RTL/#gravando","text":"Conecte a FPGA no Host via o conector USB Blaster Com o projeto compilando o Quartus gera um arquivo bin\u00e1rio na pasta output_files com extens\u00e3o *.sof . Esse arquivo \u00e9 o que ser\u00e1 carregado na FPGA para executar o projeto. Para isso abra : Tools -> Programmmer . Nessa etapa voc\u00ea deve clicar em Auto Detect, essa etapa ir\u00e1 ler via JTAG todos os dispositivos que est\u00e3o conectados no JTAG chain , voc\u00ea ir\u00e1 notar que ir\u00e3o aparecer dois dispositivos: SOCVHPS : ARM Cortex A7 5CSXFC6D : FPGA Talvez seja necess\u00e1rio configurar o Linux para reconhecer o JTAG, siga os passos em: Configurando USB Blaster Linux .","title":"Gravando"},{"location":"Tutorial-FPGA-RTL/#exercicios","text":": F\u00e1cil Fa\u00e7a os LEDs piscarem mais devagar Adicione bot\u00f5es ao projeto e fa\u00e7a eles controlarem os LEDs Fa\u00e7a as chaves controlarem a frequ\u00eancia na qual os LEDs piscam Adicione um PWM aos LEDs para controlar sua intensidade","title":"Exerc\u00edcios"},{"location":"Tutorial-FPGA-RTL/#entrega-1","text":"Siga para a Entrega 1","title":"Entrega 1"},{"location":"Tutorial-HPS-BlinkLED/","text":"Tutorial 6 - HPS - BlinkLED \u00b6 Nesse tutorial iremos compilar um programa para o HPS (Arm Cortex A) que ser\u00e1 capaz de controlar os LEDs e ler os bot\u00f5es da placa que est\u00e3o conectados ao HPS. Note pelo diagrama anterior extra\u00eddo do manual do usu\u00e1rio, existem LEDs e bot\u00f5es conectados diretamente ao HPS, e outros conectados a FPGA. Duas s\u00e3o as poss\u00edveis abordagens para programarmos o HPS: baremetal \u00b6 Far\u00edamos um programa que seria executado no ARM HPS sem nenhum sistema operacional. Como detalhado no diagrama : Altera Bare Metal User Guide Nessa maneira, a aplica\u00e7\u00e3o deve ser capaz de realizar toda a inicializa\u00e7\u00e3o de HW necess\u00e1ria para que o processador rode corretamente. Se a aplica\u00e7\u00e3o for executada sobre um sistema operacional, toda essa etapa \u00e9 de compila\u00e7\u00e3o \u00e9 responsabilidade do SO. Para isso \u00e9 aconselh\u00e1vel utilizar a IDE da ARM chamada de DS-5 Sistema operacional \u00b6 Diversas s\u00e3o as alternativas de sistema operacional para embarcado, tudo ir\u00e1 depender da especifica\u00e7\u00e3o da aplica\u00e7\u00e3o. \u00c9 necess\u00e1rio saber se existem requisitos de tempo real, se sim, deve-se considerar utilizar um RTOS ou algum sistema operacional com essa funcionalidade (existe um patch no kernel do linux que o torna mais ou menos real time). Se \u00e9 uma aplica\u00e7\u00e3o que demanda rede, v\u00eddeo, processamento de dados, \u00e9 de se considerar utilizar um Linux da vida (ou BSD, Androuid), j\u00e1 que a facilidade de desenvolvimento de aplica\u00e7\u00f5es nessa plataforma \u00e9 mais f\u00e1cil (j\u00e1 tem muita coisa pronta e uma comunidade gigantesca). Com o uso de um sistema operacional a parte referente ao HW \u00e9 responsabilidade do kernel (ou dos desenvolvedores que est\u00e3o adequando o kernel ao HW, que \u00e9 o caso de voc\u00eas). Diversos s\u00e3o os ganhos de utilizar um sistema operacional do tipo Linux (as perdas tamb\u00e9m s\u00e3o grandes: maior ocupa\u00e7\u00e3o de mem\u00f3ria, maior lat\u00eancias, boot lento ...) tais como: Device drivers Portabilidade Seguran\u00e7a Rede Linux \u00b6 Nesse tutorial iremos compilar um programa e executar no Linux Embarcado. esse programa ser\u00e1 executado no user space . Para isso iremos utilizar a toolchain definida no tutorial anterior . Iremos utilizar como base o c\u00f3digo exemplo da Terasic que est\u00e1 localizado no CD do kit: DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC/my_first_hps E crosscopilar esse c\u00f3digo para o nosso HPS utilizando o Makefile da pasta. Note Esse Makefile s\u00f3 funciona porque configuramos o nosso bashrc com as vari\u00e1veis de sistemas que ele utiliza. Por exemplo, a linha SOCEDS_ROOT ?= $(SOCEDS_DEST_ROOT) usa a vari\u00e1vel SOCEDS_DEST_ROOT que foi configurara no tutorial anterior, assim como o arm-linux-gnueabihf- ... Executando no target \u00b6 Agora basta copiar o bin\u00e1rio criado pela compila\u00e7\u00e3o para o cart\u00e3o de mem\u00f3ria e testar o nosso programa no target (HPS). Note Com o cart\u00e3o de mem\u00f3ria no host copie o arquivo bin\u00e1rio: hps_gpio para a pasta: /root/ do cart\u00e3o de mem\u00f3ria. Sempre que manipular um dispositivo de mem\u00f3ria externo, ser\u00e1 necess\u00e1rio fazer um flush do cache para for\u00e7ar o linux alterar o dispositivo externo, caso contr\u00e1rio a altera\u00e7\u00e3o poder\u00e1 ficar s\u00f3 local ao PC. $ sync A fun\u00e7\u00e3o sync \u00e9 blocante, ficar\u00e1 travada enquanto o linux faz o flush dos dados. Modificando o c\u00f3digo Fa\u00e7a o programa ler apenas duas vezes o bot\u00e3o, e depois disso termina a aplica\u00e7\u00e3o ! Fluxo de desenvolvimento \u00b6 Esse fluxo de desenvolvimento n\u00e3o \u00e9 dos melhores n\u00e9? \u00c9 bom programar no host , mas esse esquema de ter que ficar tirando e colocando cart\u00e3o de mem\u00f3ria, esperar o linux do target subir, logar e testar n\u00e3o faz bem para ningu\u00e9m. Existem v\u00e1rias solu\u00e7\u00f5es para melhorar isso, cada qual com sua vantagem/desvantagem: build no pr\u00f3prio target (ruim para o programador, \u00f3timo para depend\u00eancias, f\u00e1cil de debugar, lento) criar uma vmw arm e compilar nela (bom para o programador, \u00f3timo para depend\u00eancias, +- f\u00e1cil de debugar, r\u00e1pido) crosscompilar (bom para o programador, ruim para depend\u00eancias, dif\u00edcil de debugar, r\u00e1pido) Na entrega 4 vamos aprimorar nosso sistema de compila\u00e7\u00e3o e testes.","title":"Tutorial 6 - HPS - BlinkLED"},{"location":"Tutorial-HPS-BlinkLED/#tutorial-6-hps-blinkled","text":"Nesse tutorial iremos compilar um programa para o HPS (Arm Cortex A) que ser\u00e1 capaz de controlar os LEDs e ler os bot\u00f5es da placa que est\u00e3o conectados ao HPS. Note pelo diagrama anterior extra\u00eddo do manual do usu\u00e1rio, existem LEDs e bot\u00f5es conectados diretamente ao HPS, e outros conectados a FPGA. Duas s\u00e3o as poss\u00edveis abordagens para programarmos o HPS:","title":"Tutorial 6 - HPS - BlinkLED"},{"location":"Tutorial-HPS-BlinkLED/#baremetal","text":"Far\u00edamos um programa que seria executado no ARM HPS sem nenhum sistema operacional. Como detalhado no diagrama : Altera Bare Metal User Guide Nessa maneira, a aplica\u00e7\u00e3o deve ser capaz de realizar toda a inicializa\u00e7\u00e3o de HW necess\u00e1ria para que o processador rode corretamente. Se a aplica\u00e7\u00e3o for executada sobre um sistema operacional, toda essa etapa \u00e9 de compila\u00e7\u00e3o \u00e9 responsabilidade do SO. Para isso \u00e9 aconselh\u00e1vel utilizar a IDE da ARM chamada de DS-5","title":"baremetal"},{"location":"Tutorial-HPS-BlinkLED/#sistema-operacional","text":"Diversas s\u00e3o as alternativas de sistema operacional para embarcado, tudo ir\u00e1 depender da especifica\u00e7\u00e3o da aplica\u00e7\u00e3o. \u00c9 necess\u00e1rio saber se existem requisitos de tempo real, se sim, deve-se considerar utilizar um RTOS ou algum sistema operacional com essa funcionalidade (existe um patch no kernel do linux que o torna mais ou menos real time). Se \u00e9 uma aplica\u00e7\u00e3o que demanda rede, v\u00eddeo, processamento de dados, \u00e9 de se considerar utilizar um Linux da vida (ou BSD, Androuid), j\u00e1 que a facilidade de desenvolvimento de aplica\u00e7\u00f5es nessa plataforma \u00e9 mais f\u00e1cil (j\u00e1 tem muita coisa pronta e uma comunidade gigantesca). Com o uso de um sistema operacional a parte referente ao HW \u00e9 responsabilidade do kernel (ou dos desenvolvedores que est\u00e3o adequando o kernel ao HW, que \u00e9 o caso de voc\u00eas). Diversos s\u00e3o os ganhos de utilizar um sistema operacional do tipo Linux (as perdas tamb\u00e9m s\u00e3o grandes: maior ocupa\u00e7\u00e3o de mem\u00f3ria, maior lat\u00eancias, boot lento ...) tais como: Device drivers Portabilidade Seguran\u00e7a Rede","title":"Sistema operacional"},{"location":"Tutorial-HPS-BlinkLED/#linux","text":"Nesse tutorial iremos compilar um programa e executar no Linux Embarcado. esse programa ser\u00e1 executado no user space . Para isso iremos utilizar a toolchain definida no tutorial anterior . Iremos utilizar como base o c\u00f3digo exemplo da Terasic que est\u00e1 localizado no CD do kit: DE10-Standard-v.1.3.0-SystemCD/Demonstration/SoC/my_first_hps E crosscopilar esse c\u00f3digo para o nosso HPS utilizando o Makefile da pasta. Note Esse Makefile s\u00f3 funciona porque configuramos o nosso bashrc com as vari\u00e1veis de sistemas que ele utiliza. Por exemplo, a linha SOCEDS_ROOT ?= $(SOCEDS_DEST_ROOT) usa a vari\u00e1vel SOCEDS_DEST_ROOT que foi configurara no tutorial anterior, assim como o arm-linux-gnueabihf- ...","title":"Linux"},{"location":"Tutorial-HPS-BlinkLED/#executando-no-target","text":"Agora basta copiar o bin\u00e1rio criado pela compila\u00e7\u00e3o para o cart\u00e3o de mem\u00f3ria e testar o nosso programa no target (HPS). Note Com o cart\u00e3o de mem\u00f3ria no host copie o arquivo bin\u00e1rio: hps_gpio para a pasta: /root/ do cart\u00e3o de mem\u00f3ria. Sempre que manipular um dispositivo de mem\u00f3ria externo, ser\u00e1 necess\u00e1rio fazer um flush do cache para for\u00e7ar o linux alterar o dispositivo externo, caso contr\u00e1rio a altera\u00e7\u00e3o poder\u00e1 ficar s\u00f3 local ao PC. $ sync A fun\u00e7\u00e3o sync \u00e9 blocante, ficar\u00e1 travada enquanto o linux faz o flush dos dados. Modificando o c\u00f3digo Fa\u00e7a o programa ler apenas duas vezes o bot\u00e3o, e depois disso termina a aplica\u00e7\u00e3o !","title":"Executando no target"},{"location":"Tutorial-HPS-BlinkLED/#fluxo-de-desenvolvimento","text":"Esse fluxo de desenvolvimento n\u00e3o \u00e9 dos melhores n\u00e9? \u00c9 bom programar no host , mas esse esquema de ter que ficar tirando e colocando cart\u00e3o de mem\u00f3ria, esperar o linux do target subir, logar e testar n\u00e3o faz bem para ningu\u00e9m. Existem v\u00e1rias solu\u00e7\u00f5es para melhorar isso, cada qual com sua vantagem/desvantagem: build no pr\u00f3prio target (ruim para o programador, \u00f3timo para depend\u00eancias, f\u00e1cil de debugar, lento) criar uma vmw arm e compilar nela (bom para o programador, \u00f3timo para depend\u00eancias, +- f\u00e1cil de debugar, r\u00e1pido) crosscompilar (bom para o programador, ruim para depend\u00eancias, dif\u00edcil de debugar, r\u00e1pido) Na entrega 4 vamos aprimorar nosso sistema de compila\u00e7\u00e3o e testes.","title":"Fluxo de desenvolvimento"},{"location":"Tutorial-HPS-BuildSystem/","text":"Tutorial 5 - HPS - Infra \u00b6 Vamos instalar o ferramental (compiladores) que ser\u00e1 utilizado para compilar o kernel e o filesystem. Deveremos instalar o socdes e o linaro-gcc . Intel SOCDES \u00b6 Voc\u00ea ir\u00e1 precisar ter o software SOCEDS instalado, e ele precisa ser a mesma vers\u00e3o do Quartus. Link para download: Intel SoC FPGA Embedded Development Suite Vamos precisar inserir no path do bash refer\u00eancia para uma s\u00e9rie de softwares a serem usados, modifique seu .bashrc inserindo: Ao fazer o download do soced deve-se verificar para ser a mesma vers\u00e3o do Quartus. export ALTERAPATH = ~/intelFPGA/18.1/ export ALTERAPATH = /home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR = $ALTERAPATH /quartus/ export PATH = $PATH : ${ ALTERAPATH } /quartus/bin export PATH = $PATH : ${ ALTERAPATH } /modelsim_ase/linuxaloem/ export PATH = $PATH : ${ ALTERAPATH } /quartus/sopc_builder/bin/ export PATH = $PATH : ${ ALTERAPATH } /embedded/ export PATH = $PATH : ${ ALTERAPATH } /embedded/host_tools/altera/preloadergen/ export PATH = $PATH : ${ ALTERAPATH } /hls/bin/ export LD_LIBRARY_PATH = ${ ALTERAPATH } /hls/host/linux64/lib/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT = ${ ALTERAPATH } /embedded export SOCEDS_HWLIB = ${ ALTERAPATH } /embedded/ip/altera/hps/altera_hps/hwlib/ Note Lembre de verificar se o ALTERAPATH desse exemplo \u00e9 o caminho correto da instala\u00e7\u00e3o do Quartus outros bashs Se estiver usando outro bash (zsh/ fish) ser\u00e1 necess\u00e1rio editar o arquivo de configura\u00e7\u00e3o referente. Testando \u00b6 Para testar, digite no terminal (ap\u00f3s abrir uma nova aba, ou executar source ~/.bashrc ): $ nios2_command_shell.sh ------------------------------------------------ Altera Nios2 Command Shell [ GCC 4 ] Version 16 .1, Build 196 ------------------------------------------------ $ exit Note Isso s\u00f3 testa uma parte da instala\u00e7\u00e3o (soceds) GCC toolchain \u00b6 Iremos utilizar o GCC cross compile fornecido pelo Linaro, esse mesmo GCC ser\u00e1 utilizado para compilar o Kernel, gerar o file system e compilar os programas que executar\u00e3o no Linux. Para facilitar a organiza\u00e7\u00e3o, iremos manter o toolchain na pasta ~/work/ . Wikipidia Linaro Linaro is an engineering organization that works on free and open-source software such as the Linux kernel, the GNU Compiler Collection, power management, graphics and multimedia interfaces for the ARM family of instruction sets and implementations thereof as well as for the Heterogeneous System Architecture. https://en.wikipedia.org/wiki/Linaro Do site de bin\u00e1rios do Linaro abaixe a vers\u00e3o gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz e extra\u00eda para alguma pasta no seu Linux. Quer baixar via terminal? Meus projetos ficam todos dentro da pasta: /home/corsi/work , por isso eu extra\u00ed para l\u00e1. Voc\u00ea pode escolher outro local. $ cd ~/work $ wget https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz $ tar xvf gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz De uma olhada na pasta rec\u00e9m extra\u00edda: $ cd gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf $ tree -L 1 ... + arm-linux-gnueabihf + bin + arm-linux-gnueabihf-addr2line + arm-linux-gnueabihf-ar + ... + arm-linux-gnueabihf-c++ + arm-linux-gnueabihf-g++ + arm-linux-gnueabihf-gcc + include + lib + libexec + share Temos todas as ferramentas necess\u00e1rias para compilar e linkar c\u00f3digos em C e C++ para o ARM. Note que no path do gcc temos o prefixo : gnueabihf . Pesquisa Qual a diferen\u00e7a entre eabi e hf Criando um atalho no bash \u00b6 Vamos criar um atalho para essa pasta no bash. Edite o arquivo ~/.bashrc para incluir a pasta ~/work/gcc-linaro.../bin/ na vari\u00e1vel do sistema: GCC_Linaro . # GCC Linaro on path export GCC_Linaro = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH = $PATH : ${ GCC_Linaro } Note Edite o comando para a pasta correta de onde Linaro foi extra\u00eddo: /home/... Agora temos um atalho para o gcc-arm, vamos testar : $ $GCC_Linaro /arm-linux-gnueabihf-gcc -v ... Using built-in specs. COLLECT_GCC = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/../libexec/gcc/arm-linux-gnueabihf/7.4.1/lto-wrapper E ele tamb\u00e9m deve estar no path, como arm-linux-* : Note \u00c9 poss\u00edvel instalar o arm-linux via apt install , mas n\u00e3o vamos fazer isso pois queremos ter controle da vers\u00e3o do compilador que estamos utilizando. bashrc ao final Eu n\u00e3o modifico meu bashrc , o que eu fa\u00e7o \u00e9 criar um arquivo com o nome: Quartus18.sh e coloco toda essa configura\u00e7\u00e3o nele, e quando eu quero trabalhar em embarcados avan\u00e7ados eu s\u00f3 preciso dar source Quartus18.sh e tenho meu ambiente configurado. Com isso, eu tenho a vantagem de ter 'v\u00e1rias' vers\u00f5es instaladas e selecionar a que eu quero trabalhar. Isso tamb\u00e9m funciona pois eu tenho ambientes diferentes, com base nas disciplinas: Elementos tem um e Avan\u00e7ados outro. Meu Quartus18.sh \u00e9 o seguinte: echo \"INTEL FPGA QUARTUS 18.1\" export MGLS_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat export LM_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat #export MGLS_LICENSE_FILE=27001@35.172.191.36 #export LM_LICENSE_FILE=27001@35.172.191.3 export ALTERAPATH=/home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR=$ALTERAPATH/quartus/ export PATH=$PATH:${ALTERAPATH}/quartus/bin export PATH=$PATH:${ALTERAPATH}/modelsim_ase/linuxaloem/ export PATH=$PATH:${ALTERAPATH}/quartus/sopc_builder/bin/ export PATH=$PATH:${ALTERAPATH}/embedded/ export PATH=$PATH:${ALTERAPATH}/embedded/host_tools/altera/preloadergen/ export PATH=$PATH:${ALTERAPATH}/hls/bin/ export LD_LIBRARY_PATH=${ALTERAPATH}/hls/host/linux64/lib/ export PATH=$PATH:${ALTERAPATH}/nios2eds/ export PATH=$PATH:${ALTERAPATH}/nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT=${ALTERAPATH}/embedded export SOCEDS_HWLIB=${ALTERAPATH}/embedded/ip/altera/hps/altera_hps/hwlib/ export GCC_Linaro=/home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH=$PATH:${GCC_Linaro}","title":"Tutorial 5 - HPS - Infra"},{"location":"Tutorial-HPS-BuildSystem/#tutorial-5-hps-infra","text":"Vamos instalar o ferramental (compiladores) que ser\u00e1 utilizado para compilar o kernel e o filesystem. Deveremos instalar o socdes e o linaro-gcc .","title":"Tutorial 5 - HPS - Infra"},{"location":"Tutorial-HPS-BuildSystem/#intel-socdes","text":"Voc\u00ea ir\u00e1 precisar ter o software SOCEDS instalado, e ele precisa ser a mesma vers\u00e3o do Quartus. Link para download: Intel SoC FPGA Embedded Development Suite Vamos precisar inserir no path do bash refer\u00eancia para uma s\u00e9rie de softwares a serem usados, modifique seu .bashrc inserindo: Ao fazer o download do soced deve-se verificar para ser a mesma vers\u00e3o do Quartus. export ALTERAPATH = ~/intelFPGA/18.1/ export ALTERAPATH = /home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR = $ALTERAPATH /quartus/ export PATH = $PATH : ${ ALTERAPATH } /quartus/bin export PATH = $PATH : ${ ALTERAPATH } /modelsim_ase/linuxaloem/ export PATH = $PATH : ${ ALTERAPATH } /quartus/sopc_builder/bin/ export PATH = $PATH : ${ ALTERAPATH } /embedded/ export PATH = $PATH : ${ ALTERAPATH } /embedded/host_tools/altera/preloadergen/ export PATH = $PATH : ${ ALTERAPATH } /hls/bin/ export LD_LIBRARY_PATH = ${ ALTERAPATH } /hls/host/linux64/lib/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/ export PATH = $PATH : ${ ALTERAPATH } /nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT = ${ ALTERAPATH } /embedded export SOCEDS_HWLIB = ${ ALTERAPATH } /embedded/ip/altera/hps/altera_hps/hwlib/ Note Lembre de verificar se o ALTERAPATH desse exemplo \u00e9 o caminho correto da instala\u00e7\u00e3o do Quartus outros bashs Se estiver usando outro bash (zsh/ fish) ser\u00e1 necess\u00e1rio editar o arquivo de configura\u00e7\u00e3o referente.","title":"Intel SOCDES"},{"location":"Tutorial-HPS-BuildSystem/#testando","text":"Para testar, digite no terminal (ap\u00f3s abrir uma nova aba, ou executar source ~/.bashrc ): $ nios2_command_shell.sh ------------------------------------------------ Altera Nios2 Command Shell [ GCC 4 ] Version 16 .1, Build 196 ------------------------------------------------ $ exit Note Isso s\u00f3 testa uma parte da instala\u00e7\u00e3o (soceds)","title":"Testando"},{"location":"Tutorial-HPS-BuildSystem/#gcc-toolchain","text":"Iremos utilizar o GCC cross compile fornecido pelo Linaro, esse mesmo GCC ser\u00e1 utilizado para compilar o Kernel, gerar o file system e compilar os programas que executar\u00e3o no Linux. Para facilitar a organiza\u00e7\u00e3o, iremos manter o toolchain na pasta ~/work/ . Wikipidia Linaro Linaro is an engineering organization that works on free and open-source software such as the Linux kernel, the GNU Compiler Collection, power management, graphics and multimedia interfaces for the ARM family of instruction sets and implementations thereof as well as for the Heterogeneous System Architecture. https://en.wikipedia.org/wiki/Linaro Do site de bin\u00e1rios do Linaro abaixe a vers\u00e3o gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz e extra\u00eda para alguma pasta no seu Linux. Quer baixar via terminal? Meus projetos ficam todos dentro da pasta: /home/corsi/work , por isso eu extra\u00ed para l\u00e1. Voc\u00ea pode escolher outro local. $ cd ~/work $ wget https://releases.linaro.org/components/toolchain/binaries/latest-7/arm-linux-gnueabihf/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz $ tar xvf gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf.tar.xz De uma olhada na pasta rec\u00e9m extra\u00edda: $ cd gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf $ tree -L 1 ... + arm-linux-gnueabihf + bin + arm-linux-gnueabihf-addr2line + arm-linux-gnueabihf-ar + ... + arm-linux-gnueabihf-c++ + arm-linux-gnueabihf-g++ + arm-linux-gnueabihf-gcc + include + lib + libexec + share Temos todas as ferramentas necess\u00e1rias para compilar e linkar c\u00f3digos em C e C++ para o ARM. Note que no path do gcc temos o prefixo : gnueabihf . Pesquisa Qual a diferen\u00e7a entre eabi e hf","title":"GCC toolchain"},{"location":"Tutorial-HPS-BuildSystem/#criando-um-atalho-no-bash","text":"Vamos criar um atalho para essa pasta no bash. Edite o arquivo ~/.bashrc para incluir a pasta ~/work/gcc-linaro.../bin/ na vari\u00e1vel do sistema: GCC_Linaro . # GCC Linaro on path export GCC_Linaro = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH = $PATH : ${ GCC_Linaro } Note Edite o comando para a pasta correta de onde Linaro foi extra\u00eddo: /home/... Agora temos um atalho para o gcc-arm, vamos testar : $ $GCC_Linaro /arm-linux-gnueabihf-gcc -v ... Using built-in specs. COLLECT_GCC = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER = /home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin/../libexec/gcc/arm-linux-gnueabihf/7.4.1/lto-wrapper E ele tamb\u00e9m deve estar no path, como arm-linux-* : Note \u00c9 poss\u00edvel instalar o arm-linux via apt install , mas n\u00e3o vamos fazer isso pois queremos ter controle da vers\u00e3o do compilador que estamos utilizando. bashrc ao final Eu n\u00e3o modifico meu bashrc , o que eu fa\u00e7o \u00e9 criar um arquivo com o nome: Quartus18.sh e coloco toda essa configura\u00e7\u00e3o nele, e quando eu quero trabalhar em embarcados avan\u00e7ados eu s\u00f3 preciso dar source Quartus18.sh e tenho meu ambiente configurado. Com isso, eu tenho a vantagem de ter 'v\u00e1rias' vers\u00f5es instaladas e selecionar a que eu quero trabalhar. Isso tamb\u00e9m funciona pois eu tenho ambientes diferentes, com base nas disciplinas: Elementos tem um e Avan\u00e7ados outro. Meu Quartus18.sh \u00e9 o seguinte: echo \"INTEL FPGA QUARTUS 18.1\" export MGLS_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat export LM_LICENSE_FILE=/home/corsi/opt/intelFPGA/1-MBTRJ3_License.dat #export MGLS_LICENSE_FILE=27001@35.172.191.36 #export LM_LICENSE_FILE=27001@35.172.191.3 export ALTERAPATH=/home/corsi/opt/intelFPGA/18.1 export QUARTUS_ROOTDIR=$ALTERAPATH/quartus/ export PATH=$PATH:${ALTERAPATH}/quartus/bin export PATH=$PATH:${ALTERAPATH}/modelsim_ase/linuxaloem/ export PATH=$PATH:${ALTERAPATH}/quartus/sopc_builder/bin/ export PATH=$PATH:${ALTERAPATH}/embedded/ export PATH=$PATH:${ALTERAPATH}/embedded/host_tools/altera/preloadergen/ export PATH=$PATH:${ALTERAPATH}/hls/bin/ export LD_LIBRARY_PATH=${ALTERAPATH}/hls/host/linux64/lib/ export PATH=$PATH:${ALTERAPATH}/nios2eds/ export PATH=$PATH:${ALTERAPATH}/nios2eds/sdk2/bin/ export SOCEDS_DEST_ROOT=${ALTERAPATH}/embedded export SOCEDS_HWLIB=${ALTERAPATH}/embedded/ip/altera/hps/altera_hps/hwlib/ export GCC_Linaro=/home/corsi/work/gcc-linaro-7.4.1-2019.02-x86_64_arm-linux-gnueabihf/bin export PATH=$PATH:${GCC_Linaro}","title":"Criando um atalho no bash"},{"location":"Tutorial-HPS-Buildroot/","text":"Tutorial 8 - HPS -Buildroot \u00b6 Buildroot wikipidia Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system ref: https://en.wikipedia.org/wiki/Buildroot Iremos utilizar o buildroot para gerar o filesystem ( /bin , /etc , ...) do nosso sistema embarcado. No buildroot teremos a op\u00e7\u00e3o de configurar quais softwares queremos no dispositivo. Por exemplo, se desejarmos acessar o HPS via ssh, teremos que no buildroot adicionar um ssh server para ser compilado e adicionado ao filesystem e executado no boot. O buildroot \u00e9 uma alternativa a outro projeto bem conhecido: Yocto. O v\u00eddeo a seguir s\u00e3o dois desenvolvedores, um de cada projeto, fazendo a compara\u00e7\u00e3o entre as duas ferramentas: Note O Yocto est\u00e1 se consolidando como ferramenta padr\u00e3o da industria, tomando o lugar do buildroot. A escolha pelo buildroot na eletiva \u00e9 pela facilidade de criar um sistema, o yocto \u00e9 mais complexo e cheio de terminologias. Nessa eletiva iremos trabalhar com o buildroot, mas para quem quer se aprofundar/especializar no tema, tem que aprender o yocto. buildroot \u00b6 Leitura recomendada https://buildroot.org/downloads/manual/manual.html#_getting_started Download \u00b6 Primeiramente devemos fazer o download do buildroot : $ git clone https://github.com/buildroot/buildroot $ cd buildroot/ O buildroot possui uma ferramenta de configura\u00e7\u00e3o similar ao do kernel do linux ( menuconfig / nconfig ) iremos utilizar-la para configurar o filesystem assim como quais programas ser\u00e3o compilados e inseridos no /root/ . Lembre que j\u00e1 possu\u00edmos um toolchain (o que compilamos o kernel) configurado no .bashrc , iremos o utilizar para a compila\u00e7\u00e3o de todos os programas que iremos carregar no embarcado. O buildroot tem a op\u00e7\u00e3o de fazer o download do toolchain (ele tamb\u00e9m pode compilar o kernel e gerar o uboot, \u00e9 uma ferramenta bem completa), mas dessa vez iremos utilizar o que j\u00e1 temos (para manter a compatibilidade). Configurando \u00b6 Na pasta do buildroot rec\u00e9m clonada, execute o seguinte comando: $ make ARCH = arm menuconfig Ele ir\u00e1 abrir uma tela de configura\u00e7\u00e3o a seguir: para voltar para essa tela, basta aperta duas vezes a tecla <ESC> 1. Target Options \u00b6 A primeira parte que iremos configurar \u00e9 o alvo da gera\u00e7\u00e3o do filesystem ( Target options ), devemos informar para o buildroot que ele est\u00e1 gerando arquivos para um ARM e indicar algumas op\u00e7\u00f5es do nosso compilador. Para isso: Config. final Menu principal Target Options Target Architecture: ARM (little endian) Essa op\u00e7\u00e3o j\u00e1 deve estar certa pois passamos via a chamada do make (make ARCH=ARM ...) Target Architecture Variant: cortex-A9 Enable NEON SIMD extension support Enable VFP extension support Floating point strategy: NEON https://developer.arm.com/technologies/neon Target ABI: EABIhf Indicamos ao buildroot que nossa arquitetura possui ponto flutuante em HW. 2. Build options \u00b6 Config. Final Deixe padr\u00e3o como o padr\u00e3o. 3. Toolchain \u00b6 config. Final Vamos indicar agora para o buildroot qual toolchain que ele deve utilizar e suas configura\u00e7\u00f5es: Menu principal Toolchain Toolchain type: External toolchain o buildroot ir\u00e1 usar o toolchain que especificarmos. Note que dentro dessa op\u00e7\u00e3o existe a : Buildroot toolchain , que se ativada faria com que o buildroot baixasse de forma autom\u00e1tica todo o toolchain. Toolchain: Custom toolchain Toolchain path: $(ARM_GCC) o buildroot ir\u00e1 usar essa vari\u00e1vel do sistema como path do toolchain. Temos duas op\u00e7\u00f5es aqui : Podemos declarar essa vari\u00e1vel no bash Podemos editar essa op\u00e7\u00e3o j\u00e1 com o path do nosso toolchain Vamos escolher por hora a op\u00e7\u00e3o 1. Toolchain prefix: $(ARCH)-linux-gnueabihf o prefix \u00e9 como o toolchain ir\u00e1 ser chamado, por exemplo para acessar o gcc: $(ARM_GCC)/bin/$(ARCH)-linux-gnueabihf-gcc Sendo : ARM_GCC = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf ARCH = arm (passado no call do make) Resulta em: /home/corsi/work/gcc-linaro-7.1-2017.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc Toolchain gcc version: 7.x Toolchain kernel headers series: 4.10.x External toolchain C library: glibc/eglibc Ativar : Toolchain has SSP support Ativar : Toolchain has SSP support Ativar : Toolchain has RCP support Ativar : Toolchain has C++ support 4. System Configuration \u00b6 config. Final Nessa etapa vamos configurar informa\u00e7\u00f5es como: hostname, user, password gerenciador de inicializa\u00e7\u00e3o (init)... Menu principal System Configuration System hostname: SoC-Corsi (escolha o que preferir) System banner: Embarcados Avancados!! SoC Cyclone V Init system: BusyBox systemd \u00e9 uma alternativa, s\u00f3 que mais complexa! Root password: 1234 (escolha o que preferir) /bin/sh: busybox O shell a ser inserido no sistema, temos v\u00e1rias outras op\u00e7\u00f5es: bash, zsh. Todas elas ir\u00e3o aumentar o tamanho e a complexidade da imagem. 5. Kernel / bootloader \u00b6 O busybox pode baixar e compilar o kernel e o uboot para n\u00f3s. N\u00e3o vamos usar essa configura\u00e7\u00e3o. Menu principal Kernel 6. Target packages \u00b6 Nesse menu temos a op\u00e7\u00e3o de quais programas e sistemas ser\u00e3o inseridos na imagem para o target. Se quisermos por exemplo inserir um webserver (apache ?) no nosso linux embarcado, devemos selecionar aqui. Vamos deixar como padr\u00e3o por hora. Mais tarde iremos voltar a essa etapa mais tarde. 7. Filesystem images \u00b6 Menu principal Filesystem images Selecionar: tar the root filesystem Esse menu descreve para o busybox como deve ser a sa\u00edda final da imagem do filesystem gerada. O busybox necessita gerar filesystem que \u00e9 capaz de configurar as permiss\u00f5es dos arquivos corretamente (ele n\u00e3o pode simplesmente gerar uma pasta com todos os arquivos e programas). 8. Finalizando \u00b6 Salve a sua configura\u00e7\u00e3o (ESC ESC save) e volte ao terminal. Vamos agora gerar a imagem do nosso filesystem. Compilando \u00b6 Para compilar e gerar o filesystem : $ make all -j 4 Nessa etapa o buildroot ir\u00e1 baixar da web todos os pacotes e programas que foram selecionados no menu de configura\u00e7\u00e3o, e ir\u00e1 compilar o source code com o toolchain que passamos para ele. Isso pode levar um tempinho . Gr\u00e1ficos ! \u00b6 Uma vez acabado o processo de gera\u00e7\u00e3o do FS, podemos gerar alguns gr\u00e1ficos muito importantes: https://buildroot.org/downloads/manual/manual.html#_graphing_the_filesystem_size_contribution_of_packages Depend\u00eancia dos pacotes: make graph-depends Tempo de compila\u00e7\u00e3o: make graph-build Contribui\u00e7\u00e3o do tamanho do FS de cada pacote: make graph-size Os gr\u00e1ficos s\u00e3o salvos na pasta: output/graphs/ Gere os tr\u00eas gr\u00e1ficos e analise os resultados Exemplo do gr\u00e1fico do tamanho dos pacotes no fs: Outputs \u00b6 Existem duas sa\u00eddas do buildroot na pasta: buildroot/output/** O arquivo ./images/rootfs.tar : que cont\u00e9m o fileSystem do target (com as permiss\u00f5es corretas) A pasta ./images/target/ : com os arquivos contidos no .tar mas sem as permiss\u00f5es corretas para executar no target. Inclusive essa pasta possui um arquivo: Warning THIS_IS_NOT_YOUR_ROOT_FILESYSTEM Warning! This directory does not contain the root filesystem that you can use on your embedded system. Since Buildroot does not run as root, it cannot create device files and set the permissions and ownership of files correctly in this directory to make it usable as a root filesystem. .... Para testarmos no nosso sistema embarcados, temos que extrair o arquivo rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. Testando \u00b6 Siga o tutorial em SDCard - FileSystem . L\u00e1 est\u00e1 comentando como extrair o rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. o boot ficou mais r\u00e1pido? Tente plugar um pendrive, funciona? Estudando \u00b6 Responda: descreva o que \u00e9 o root file system initd process para que serve e como funciona o /linuxrc para que serve o /proc Refer\u00eancias \u00b6 dtb : https://rocketboards.org/foswiki/Documentation/HOWTOCreateADeviceTree Generating and Compiling the Preloader : https://rocketboards.org/foswiki/Documentation/GSRD141Preloader Compilando o kernel : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8","title":"Tutorial 8 - HPS -Buildroot"},{"location":"Tutorial-HPS-Buildroot/#tutorial-8-hps-buildroot","text":"Buildroot wikipidia Buildroot is a set of Makefiles and patches that simplifies and automates the process of building a complete and bootable Linux environment for an embedded system, while using cross-compilation to allow building for multiple target platforms on a single Linux-based development system. Buildroot can automatically build the required cross-compilation toolchain, create a root file system, compile a Linux kernel image, and generate a boot loader for the targeted embedded system, or it can perform any independent combination of these steps. For example, an already installed cross-compilation toolchain can be used independently, while Buildroot only creates the root file system ref: https://en.wikipedia.org/wiki/Buildroot Iremos utilizar o buildroot para gerar o filesystem ( /bin , /etc , ...) do nosso sistema embarcado. No buildroot teremos a op\u00e7\u00e3o de configurar quais softwares queremos no dispositivo. Por exemplo, se desejarmos acessar o HPS via ssh, teremos que no buildroot adicionar um ssh server para ser compilado e adicionado ao filesystem e executado no boot. O buildroot \u00e9 uma alternativa a outro projeto bem conhecido: Yocto. O v\u00eddeo a seguir s\u00e3o dois desenvolvedores, um de cada projeto, fazendo a compara\u00e7\u00e3o entre as duas ferramentas: Note O Yocto est\u00e1 se consolidando como ferramenta padr\u00e3o da industria, tomando o lugar do buildroot. A escolha pelo buildroot na eletiva \u00e9 pela facilidade de criar um sistema, o yocto \u00e9 mais complexo e cheio de terminologias. Nessa eletiva iremos trabalhar com o buildroot, mas para quem quer se aprofundar/especializar no tema, tem que aprender o yocto.","title":"Tutorial 8 - HPS -Buildroot"},{"location":"Tutorial-HPS-Buildroot/#buildroot","text":"Leitura recomendada https://buildroot.org/downloads/manual/manual.html#_getting_started","title":"buildroot"},{"location":"Tutorial-HPS-Buildroot/#download","text":"Primeiramente devemos fazer o download do buildroot : $ git clone https://github.com/buildroot/buildroot $ cd buildroot/ O buildroot possui uma ferramenta de configura\u00e7\u00e3o similar ao do kernel do linux ( menuconfig / nconfig ) iremos utilizar-la para configurar o filesystem assim como quais programas ser\u00e3o compilados e inseridos no /root/ . Lembre que j\u00e1 possu\u00edmos um toolchain (o que compilamos o kernel) configurado no .bashrc , iremos o utilizar para a compila\u00e7\u00e3o de todos os programas que iremos carregar no embarcado. O buildroot tem a op\u00e7\u00e3o de fazer o download do toolchain (ele tamb\u00e9m pode compilar o kernel e gerar o uboot, \u00e9 uma ferramenta bem completa), mas dessa vez iremos utilizar o que j\u00e1 temos (para manter a compatibilidade).","title":"Download"},{"location":"Tutorial-HPS-Buildroot/#configurando","text":"Na pasta do buildroot rec\u00e9m clonada, execute o seguinte comando: $ make ARCH = arm menuconfig Ele ir\u00e1 abrir uma tela de configura\u00e7\u00e3o a seguir: para voltar para essa tela, basta aperta duas vezes a tecla <ESC>","title":"Configurando"},{"location":"Tutorial-HPS-Buildroot/#1-target-options","text":"A primeira parte que iremos configurar \u00e9 o alvo da gera\u00e7\u00e3o do filesystem ( Target options ), devemos informar para o buildroot que ele est\u00e1 gerando arquivos para um ARM e indicar algumas op\u00e7\u00f5es do nosso compilador. Para isso: Config. final Menu principal Target Options Target Architecture: ARM (little endian) Essa op\u00e7\u00e3o j\u00e1 deve estar certa pois passamos via a chamada do make (make ARCH=ARM ...) Target Architecture Variant: cortex-A9 Enable NEON SIMD extension support Enable VFP extension support Floating point strategy: NEON https://developer.arm.com/technologies/neon Target ABI: EABIhf Indicamos ao buildroot que nossa arquitetura possui ponto flutuante em HW.","title":"1. Target Options"},{"location":"Tutorial-HPS-Buildroot/#2-build-options","text":"Config. Final Deixe padr\u00e3o como o padr\u00e3o.","title":"2. Build options"},{"location":"Tutorial-HPS-Buildroot/#3-toolchain","text":"config. Final Vamos indicar agora para o buildroot qual toolchain que ele deve utilizar e suas configura\u00e7\u00f5es: Menu principal Toolchain Toolchain type: External toolchain o buildroot ir\u00e1 usar o toolchain que especificarmos. Note que dentro dessa op\u00e7\u00e3o existe a : Buildroot toolchain , que se ativada faria com que o buildroot baixasse de forma autom\u00e1tica todo o toolchain. Toolchain: Custom toolchain Toolchain path: $(ARM_GCC) o buildroot ir\u00e1 usar essa vari\u00e1vel do sistema como path do toolchain. Temos duas op\u00e7\u00f5es aqui : Podemos declarar essa vari\u00e1vel no bash Podemos editar essa op\u00e7\u00e3o j\u00e1 com o path do nosso toolchain Vamos escolher por hora a op\u00e7\u00e3o 1. Toolchain prefix: $(ARCH)-linux-gnueabihf o prefix \u00e9 como o toolchain ir\u00e1 ser chamado, por exemplo para acessar o gcc: $(ARM_GCC)/bin/$(ARCH)-linux-gnueabihf-gcc Sendo : ARM_GCC = /home/corsi/work/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf ARCH = arm (passado no call do make) Resulta em: /home/corsi/work/gcc-linaro-7.1-2017.11-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc Toolchain gcc version: 7.x Toolchain kernel headers series: 4.10.x External toolchain C library: glibc/eglibc Ativar : Toolchain has SSP support Ativar : Toolchain has SSP support Ativar : Toolchain has RCP support Ativar : Toolchain has C++ support","title":"3. Toolchain"},{"location":"Tutorial-HPS-Buildroot/#4-system-configuration","text":"config. Final Nessa etapa vamos configurar informa\u00e7\u00f5es como: hostname, user, password gerenciador de inicializa\u00e7\u00e3o (init)... Menu principal System Configuration System hostname: SoC-Corsi (escolha o que preferir) System banner: Embarcados Avancados!! SoC Cyclone V Init system: BusyBox systemd \u00e9 uma alternativa, s\u00f3 que mais complexa! Root password: 1234 (escolha o que preferir) /bin/sh: busybox O shell a ser inserido no sistema, temos v\u00e1rias outras op\u00e7\u00f5es: bash, zsh. Todas elas ir\u00e3o aumentar o tamanho e a complexidade da imagem.","title":"4. System Configuration"},{"location":"Tutorial-HPS-Buildroot/#5-kernel-bootloader","text":"O busybox pode baixar e compilar o kernel e o uboot para n\u00f3s. N\u00e3o vamos usar essa configura\u00e7\u00e3o. Menu principal Kernel","title":"5. Kernel / bootloader"},{"location":"Tutorial-HPS-Buildroot/#6-target-packages","text":"Nesse menu temos a op\u00e7\u00e3o de quais programas e sistemas ser\u00e3o inseridos na imagem para o target. Se quisermos por exemplo inserir um webserver (apache ?) no nosso linux embarcado, devemos selecionar aqui. Vamos deixar como padr\u00e3o por hora. Mais tarde iremos voltar a essa etapa mais tarde.","title":"6. Target packages"},{"location":"Tutorial-HPS-Buildroot/#7-filesystem-images","text":"Menu principal Filesystem images Selecionar: tar the root filesystem Esse menu descreve para o busybox como deve ser a sa\u00edda final da imagem do filesystem gerada. O busybox necessita gerar filesystem que \u00e9 capaz de configurar as permiss\u00f5es dos arquivos corretamente (ele n\u00e3o pode simplesmente gerar uma pasta com todos os arquivos e programas).","title":"7. Filesystem images"},{"location":"Tutorial-HPS-Buildroot/#8-finalizando","text":"Salve a sua configura\u00e7\u00e3o (ESC ESC save) e volte ao terminal. Vamos agora gerar a imagem do nosso filesystem.","title":"8. Finalizando"},{"location":"Tutorial-HPS-Buildroot/#compilando","text":"Para compilar e gerar o filesystem : $ make all -j 4 Nessa etapa o buildroot ir\u00e1 baixar da web todos os pacotes e programas que foram selecionados no menu de configura\u00e7\u00e3o, e ir\u00e1 compilar o source code com o toolchain que passamos para ele. Isso pode levar um tempinho .","title":"Compilando"},{"location":"Tutorial-HPS-Buildroot/#graficos","text":"Uma vez acabado o processo de gera\u00e7\u00e3o do FS, podemos gerar alguns gr\u00e1ficos muito importantes: https://buildroot.org/downloads/manual/manual.html#_graphing_the_filesystem_size_contribution_of_packages Depend\u00eancia dos pacotes: make graph-depends Tempo de compila\u00e7\u00e3o: make graph-build Contribui\u00e7\u00e3o do tamanho do FS de cada pacote: make graph-size Os gr\u00e1ficos s\u00e3o salvos na pasta: output/graphs/ Gere os tr\u00eas gr\u00e1ficos e analise os resultados Exemplo do gr\u00e1fico do tamanho dos pacotes no fs:","title":"Gr\u00e1ficos !"},{"location":"Tutorial-HPS-Buildroot/#outputs","text":"Existem duas sa\u00eddas do buildroot na pasta: buildroot/output/** O arquivo ./images/rootfs.tar : que cont\u00e9m o fileSystem do target (com as permiss\u00f5es corretas) A pasta ./images/target/ : com os arquivos contidos no .tar mas sem as permiss\u00f5es corretas para executar no target. Inclusive essa pasta possui um arquivo: Warning THIS_IS_NOT_YOUR_ROOT_FILESYSTEM Warning! This directory does not contain the root filesystem that you can use on your embedded system. Since Buildroot does not run as root, it cannot create device files and set the permissions and ownership of files correctly in this directory to make it usable as a root filesystem. .... Para testarmos no nosso sistema embarcados, temos que extrair o arquivo rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria.","title":"Outputs"},{"location":"Tutorial-HPS-Buildroot/#testando","text":"Siga o tutorial em SDCard - FileSystem . L\u00e1 est\u00e1 comentando como extrair o rootfs.tar para o nosso cart\u00e3o de mem\u00f3ria. o boot ficou mais r\u00e1pido? Tente plugar um pendrive, funciona?","title":"Testando"},{"location":"Tutorial-HPS-Buildroot/#estudando","text":"Responda: descreva o que \u00e9 o root file system initd process para que serve e como funciona o /linuxrc para que serve o /proc","title":"Estudando"},{"location":"Tutorial-HPS-Buildroot/#referencias","text":"dtb : https://rocketboards.org/foswiki/Documentation/HOWTOCreateADeviceTree Generating and Compiling the Preloader : https://rocketboards.org/foswiki/Documentation/GSRD141Preloader Compilando o kernel : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8","title":"Refer\u00eancias"},{"location":"Tutorial-HPS-FPGA-BlinkLED (copy)/","text":"Tutorial - HPS-FPGA - Blink LED \u00b6 Nesse tutorial vamos ver como interfacear o ARM com a FPGA (fabric). Nesse tutorial, optei por deixar voc\u00eas seguirem o tutorial oficial da Terasic: Examples for using both HPS SoC and FGPA [cap\u00edtulo 7], que se encontra no manual do usu\u00e1rio, no CD do kit. Note Retomar a essa p\u00e1gina quando acabar o tutorial da Terasic, ele n\u00e3o cobre tudo. https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/tree/master/Manual Execute Copie o bin\u00e1rio compilado no tutorial HPS_FPGA_LED para o SDCard Esse tutorial n\u00e3o \u00e9 completo, ele pula uma coisa muito importante: Como programar a FPGA automaticamente para quando o Linux inicializar, o hardware j\u00e1 estar programando para poder executar o programa HPS_FPGA_LED . Como o Kernel do linux sabe em qual hardware ele est\u00e1 sendo executado? (Possui v\u00eddeo? Ethernet? ...) A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons Gerando o .rbf (imagem da FPGA) \u00b6 O rbf \u00e9 o arquivo .sof gerado pelo Quartus na compila\u00e7\u00e3o s\u00f3 que comprimido e com algumas modifica\u00e7\u00f5es. Para gerar o arquivo .rbf a partir do .sof basta executarmos na pasta output_files : Note Voc\u00ea deve executar esse comando na pasta output_files do seu projeto Quartus! $ cd output_files $ quartus_cpf -c DE10_Standard_FB.sof -o bitstream_compression = on soc_system.rbf Note note que o arquivo gerado pelo Quartus chama DE10_Standard_FB.sof , voc\u00ea deve editar para o seu caso. Com o arquivo soc_system.rbf criado, \u00e9 s\u00f3 copiarmos ele para o SDCARD, substituindo o anterior. Execute Gere o soc_system.rbf do projeto Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel) dtb (informa\u00e7\u00f5es de hardware para o Kernel) \u00b6 O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico mudar, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! Ser\u00e1 necess\u00e1rio seguir os passos a seguir: Gere o .sopcinfo (platform designer) ( j\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer ) Gere o dts Compile o dts para dtb Gerando o dts \u00b6 Eu consegui esse comando via trocado com engenheiros da Terasic, os exemplos que encontrava nos tutorias da internet n\u00e3o funcionavam. Note Para funcionar \u00e9 necess\u00e1rio realizar o comando via o shell do embedded Execute os seguintes comandos: Note Voc\u00ea deve executar esse comando na pasta raiz do seu projeto Quartus! Agora com o .dts gerado, vamos dar uma olhada em seu conte\u00fado e como o interpretar. O dts possui a anatomia a seguir: - ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = <1>; #size-cells = <0>; enable-method = \"altr,socfpga-smp\"; /* appended from boardinfo */ hps_0_arm_a9_0: cpu@0x0 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000000>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1: cpu@0x1 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000001>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\", \"snps,dw-apb-uart\"; reg = <0xffc02000 0x00000100>; interrupt-parent = <&hps_0_arm_gic_0>; interrupts = <0 162 4>; clocks = <&l4_sp_clk>; reg-io-width = <4>; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg-shift = <2>; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\"; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 !!! note \"Para mais informa\u00e7\u00f5es sobre o `dts\": - https://elinux.org/Device_Tree_Usage - https://elinux.org/Device_Tree_Reference - https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy - https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf ### Gerando o dtb Execute os seguintes comandos (ainda dentro do embedded shell) $ dtc -I dts -O dtb -o soc_system.dtb soc_system.dts $ #Agora voc\u00ea pode sair do embedded shell: $ exit Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel) Testando \u00b6 Agora plugue o SDcard no kit de desenvolvimento, e ap\u00f3s inicializa\u00e7\u00e3o do kernel execute o programa blink led e veja os LEDs da FPGA piscarem! Interessante n\u00e9? Agora vamos fazer algo mais \u00fatil com isso..","title":"Tutorial - HPS-FPGA - Blink LED"},{"location":"Tutorial-HPS-FPGA-BlinkLED (copy)/#tutorial-hps-fpga-blink-led","text":"Nesse tutorial vamos ver como interfacear o ARM com a FPGA (fabric). Nesse tutorial, optei por deixar voc\u00eas seguirem o tutorial oficial da Terasic: Examples for using both HPS SoC and FGPA [cap\u00edtulo 7], que se encontra no manual do usu\u00e1rio, no CD do kit. Note Retomar a essa p\u00e1gina quando acabar o tutorial da Terasic, ele n\u00e3o cobre tudo. https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/tree/master/Manual Execute Copie o bin\u00e1rio compilado no tutorial HPS_FPGA_LED para o SDCard Esse tutorial n\u00e3o \u00e9 completo, ele pula uma coisa muito importante: Como programar a FPGA automaticamente para quando o Linux inicializar, o hardware j\u00e1 estar programando para poder executar o programa HPS_FPGA_LED . Como o Kernel do linux sabe em qual hardware ele est\u00e1 sendo executado? (Possui v\u00eddeo? Ethernet? ...) A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons","title":"Tutorial - HPS-FPGA - Blink LED"},{"location":"Tutorial-HPS-FPGA-BlinkLED (copy)/#gerando-o-rbf-imagem-da-fpga","text":"O rbf \u00e9 o arquivo .sof gerado pelo Quartus na compila\u00e7\u00e3o s\u00f3 que comprimido e com algumas modifica\u00e7\u00f5es. Para gerar o arquivo .rbf a partir do .sof basta executarmos na pasta output_files : Note Voc\u00ea deve executar esse comando na pasta output_files do seu projeto Quartus! $ cd output_files $ quartus_cpf -c DE10_Standard_FB.sof -o bitstream_compression = on soc_system.rbf Note note que o arquivo gerado pelo Quartus chama DE10_Standard_FB.sof , voc\u00ea deve editar para o seu caso. Com o arquivo soc_system.rbf criado, \u00e9 s\u00f3 copiarmos ele para o SDCARD, substituindo o anterior. Execute Gere o soc_system.rbf do projeto Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Gerando o .rbf (imagem da FPGA)"},{"location":"Tutorial-HPS-FPGA-BlinkLED (copy)/#dtb-informacoes-de-hardware-para-o-kernel","text":"O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico mudar, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! Ser\u00e1 necess\u00e1rio seguir os passos a seguir: Gere o .sopcinfo (platform designer) ( j\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer ) Gere o dts Compile o dts para dtb","title":"dtb (informa\u00e7\u00f5es de hardware para o Kernel)"},{"location":"Tutorial-HPS-FPGA-BlinkLED (copy)/#gerando-o-dts","text":"Eu consegui esse comando via trocado com engenheiros da Terasic, os exemplos que encontrava nos tutorias da internet n\u00e3o funcionavam. Note Para funcionar \u00e9 necess\u00e1rio realizar o comando via o shell do embedded Execute os seguintes comandos: Note Voc\u00ea deve executar esse comando na pasta raiz do seu projeto Quartus! Agora com o .dts gerado, vamos dar uma olhada em seu conte\u00fado e como o interpretar. O dts possui a anatomia a seguir: - ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = <1>; #size-cells = <0>; enable-method = \"altr,socfpga-smp\"; /* appended from boardinfo */ hps_0_arm_a9_0: cpu@0x0 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000000>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1: cpu@0x1 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000001>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\", \"snps,dw-apb-uart\"; reg = <0xffc02000 0x00000100>; interrupt-parent = <&hps_0_arm_gic_0>; interrupts = <0 162 4>; clocks = <&l4_sp_clk>; reg-io-width = <4>; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg-shift = <2>; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\"; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 !!! note \"Para mais informa\u00e7\u00f5es sobre o `dts\": - https://elinux.org/Device_Tree_Usage - https://elinux.org/Device_Tree_Reference - https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy - https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf ### Gerando o dtb Execute os seguintes comandos (ainda dentro do embedded shell) $ dtc -I dts -O dtb -o soc_system.dtb soc_system.dts $ #Agora voc\u00ea pode sair do embedded shell: $ exit Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Gerando o dts"},{"location":"Tutorial-HPS-FPGA-BlinkLED (copy)/#testando","text":"Agora plugue o SDcard no kit de desenvolvimento, e ap\u00f3s inicializa\u00e7\u00e3o do kernel execute o programa blink led e veja os LEDs da FPGA piscarem! Interessante n\u00e9? Agora vamos fazer algo mais \u00fatil com isso..","title":"Testando"},{"location":"Tutorial-HPS-FPGA-BlinkLED/","text":"Tutorial - HPS+FPGA - Blink LED \u00b6 Nesse tutorial vamos ver como interfacear o ARM com a FPGA (fabric). Nesse tutorial, optei por deixar voc\u00eas seguirem o tutorial oficial da Terasic: Examples for using both HPS SoC and FGPA [cap\u00edtulo 7], que se encontra no manual do usu\u00e1rio, no CD do kit. Note Retomar a essa p\u00e1gina quando acabar o tutorial da Terasic, ele n\u00e3o cobre tudo. https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/tree/master/Manual Execute Copie o bin\u00e1rio compilado no tutorial HPS_FPGA_LED para o SDCard Entendendo o HW \u00b6 Muito importante voc\u00ea parar e refletir o que aconteceu, para isso segue algumas perguntas: Quais s\u00e3o as interfaces ente o ARM e a FPGA? (s\u00e3o 4 no total) Qual a diferen\u00e7a entre elas? Como o HPS aparece no Platform Designer (PD)? Voc\u00ea abriu as configura\u00e7\u00f5es do HPS no PD? O que pode ser configurado? Como essa interface \u00e9 utilizada no Platform Designer? Porque no projeto ele utilizou um clock bridge? Parte 2 \u00b6 Esse tutorial n\u00e3o \u00e9 completo, ele pula uma coisa muito importante: Como programar a FPGA automaticamente para quando o Linux inicializar, o hardware j\u00e1 estar programando para poder executar o programa HPS_FPGA_LED . Como o Kernel do linux sabe em qual hardware ele est\u00e1 sendo executado? (Possui v\u00eddeo? Ethernet? ...) A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons Gerando o .rbf (imagem da FPGA) \u00b6 O rbf \u00e9 o arquivo .sof gerado pelo Quartus na compila\u00e7\u00e3o s\u00f3 que comprimido e com algumas modifica\u00e7\u00f5es. Para gerar o arquivo .rbf a partir do .sof basta executarmos na pasta output_files : Note Voc\u00ea deve executar esse comando na pasta output_files do seu projeto Quartus! $ cd output_files $ quartus_cpf -c DE10_Standard_FB.sof -o bitstream_compression = on soc_system.rbf Note note que o arquivo gerado pelo Quartus chama DE10_Standard_FB.sof , voc\u00ea deve editar para o seu caso. Com o arquivo soc_system.rbf criado, \u00e9 s\u00f3 copiarmos ele para o SDCARD, substituindo o anterior. Execute Gere o soc_system.rbf do projeto Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel) dtb (informa\u00e7\u00f5es de hardware para o Kernel) \u00b6 O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico mudar, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! Ser\u00e1 necess\u00e1rio seguir os passos a seguir: Gere o .sopcinfo (platform designer) ( j\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer ) Gere o dts Compile o dts para dtb Gerando o dts \u00b6 Eu consegui esse comando via trocado com engenheiros da Terasic, os exemplos que encontrava nos tutorias da internet n\u00e3o funcionavam. Note Para funcionar \u00e9 necess\u00e1rio realizar o comando via o shell do embedded Execute os seguintes comandos: Note Voc\u00ea deve executar esse comando na pasta raiz do seu projeto Quartus! Agora com o .dts gerado, vamos dar uma olhada em seu conte\u00fado e como o interpretar. O dts possui a anatomia a seguir: - ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = <1>; #size-cells = <0>; enable-method = \"altr,socfpga-smp\"; /* appended from boardinfo */ hps_0_arm_a9_0: cpu@0x0 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000000>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1: cpu@0x1 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000001>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\", \"snps,dw-apb-uart\"; reg = <0xffc02000 0x00000100>; interrupt-parent = <&hps_0_arm_gic_0>; interrupts = <0 162 4>; clocks = <&l4_sp_clk>; reg-io-width = <4>; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg-shift = <2>; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\"; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 !!! note \"Para mais informa\u00e7\u00f5es sobre o `dts\": - https://elinux.org/Device_Tree_Usage - https://elinux.org/Device_Tree_Reference - https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy - https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf ### Gerando o dtb Execute os seguintes comandos (ainda dentro do embedded shell) $ dtc -I dts -O dtb -o soc_system.dtb soc_system.dts $ #Agora voc\u00ea pode sair do embedded shell: $ exit Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel) Testando \u00b6 Agora plugue o SDcard no kit de desenvolvimento, e ap\u00f3s inicializa\u00e7\u00e3o do kernel execute o programa blink led e veja os LEDs da FPGA piscarem! Interessante n\u00e9? Agora vamos fazer algo mais \u00fatil com isso..","title":"Tutorial - HPS+FPGA - Blink LED"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#tutorial-hpsfpga-blink-led","text":"Nesse tutorial vamos ver como interfacear o ARM com a FPGA (fabric). Nesse tutorial, optei por deixar voc\u00eas seguirem o tutorial oficial da Terasic: Examples for using both HPS SoC and FGPA [cap\u00edtulo 7], que se encontra no manual do usu\u00e1rio, no CD do kit. Note Retomar a essa p\u00e1gina quando acabar o tutorial da Terasic, ele n\u00e3o cobre tudo. https://github.com/Insper/DE10-Standard-v.1.3.0-SystemCD/tree/master/Manual Execute Copie o bin\u00e1rio compilado no tutorial HPS_FPGA_LED para o SDCard","title":"Tutorial - HPS+FPGA - Blink LED"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#entendendo-o-hw","text":"Muito importante voc\u00ea parar e refletir o que aconteceu, para isso segue algumas perguntas: Quais s\u00e3o as interfaces ente o ARM e a FPGA? (s\u00e3o 4 no total) Qual a diferen\u00e7a entre elas? Como o HPS aparece no Platform Designer (PD)? Voc\u00ea abriu as configura\u00e7\u00f5es do HPS no PD? O que pode ser configurado? Como essa interface \u00e9 utilizada no Platform Designer? Porque no projeto ele utilizou um clock bridge?","title":"Entendendo o HW"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#parte-2","text":"Esse tutorial n\u00e3o \u00e9 completo, ele pula uma coisa muito importante: Como programar a FPGA automaticamente para quando o Linux inicializar, o hardware j\u00e1 estar programando para poder executar o programa HPS_FPGA_LED . Como o Kernel do linux sabe em qual hardware ele est\u00e1 sendo executado? (Possui v\u00eddeo? Ethernet? ...) A programa\u00e7\u00e3o da FPGA \u00e9 realizada pelo u-boot, antes da inicializa\u00e7\u00e3o do Kernel do Linux. No nosso caso, o u-boot foi pr\u00e9 configurado para ler o arquivo soc_system.rbf que est\u00e1 na parti\u00e7\u00e3o do SDCARD junto com o kernel ( zImage ). Explica\u00e7\u00e3o do processo de boot - at\u00e9 1:50 minutos O u-boot antes de inicializar o kernel do Linux, busca esse arquivo na parti\u00e7\u00e3o do SDCARD, o extra\u00ed e programa \"magicamente\" a FPGA. Nessa mesma parti\u00e7\u00e3o temos mais dois arquivos: u-boot.scr e socfpga.dtb . O primeiro \u00e9 um script de inicializa\u00e7\u00e3o do boot na qual o u-boot l\u00ea para saber quais passos ele deve executar (se precisa carregar a fpga, onde est\u00e1 o kernel, ..., s\u00e3o os passos de inicializa\u00e7\u00e3o), j\u00e1 o socfpga.dtb \u00e9 o device tree do Linux , o dtb \u00e9 um bin\u00e1rio, que foi criado a partir de outro arquivo, o .dts , e ele cont\u00e9m informa\u00e7\u00f5es sobre o hardware que \u00e9 passado para o kernel no momento de inicializa\u00e7\u00e3o. Device Tree for Dummies! - Thomas Petazzoni, Free Electrons","title":"Parte 2"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#gerando-o-rbf-imagem-da-fpga","text":"O rbf \u00e9 o arquivo .sof gerado pelo Quartus na compila\u00e7\u00e3o s\u00f3 que comprimido e com algumas modifica\u00e7\u00f5es. Para gerar o arquivo .rbf a partir do .sof basta executarmos na pasta output_files : Note Voc\u00ea deve executar esse comando na pasta output_files do seu projeto Quartus! $ cd output_files $ quartus_cpf -c DE10_Standard_FB.sof -o bitstream_compression = on soc_system.rbf Note note que o arquivo gerado pelo Quartus chama DE10_Standard_FB.sof , voc\u00ea deve editar para o seu caso. Com o arquivo soc_system.rbf criado, \u00e9 s\u00f3 copiarmos ele para o SDCARD, substituindo o anterior. Execute Gere o soc_system.rbf do projeto Grave o novo rbf no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Gerando o .rbf (imagem da FPGA)"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#dtb-informacoes-de-hardware-para-o-kernel","text":"O dtb \u00e9 utilizado como ferramenta para indicar ao kernel quais s\u00e3o as configura\u00e7\u00f5es de hardware dispon\u00edveis, voc\u00ea n\u00e3o precisa recompilar o kernel caso o endere\u00e7o de mem\u00f3ria de algum perif\u00e9rico mudar, basta informar no dts . Essa ferramenta \u00e9 muito importante para sistemas embarcados, na qual, cada hardware possui sua especificidade. O dtb \u00e9 gerado a partir de arquivo texto no formato dts que \u00e9 ent\u00e3o gerado pelas informa\u00e7\u00f5es de hardware extra\u00edda do Platform Designer que s\u00e3o salvas no arquivo: .sopcinfo , o mesmo arquivo que \u00e9 utilizado pelo Eclipse-NIOS para gerar o BSP nos tutoriais passados. O BSP no Linux \u00e9 chamado de dts e possui um formato padr\u00e3o que deve ser seguido! Ser\u00e1 necess\u00e1rio seguir os passos a seguir: Gere o .sopcinfo (platform designer) ( j\u00e1 est\u00e1 pronto, n\u00e3o precisa mexer ) Gere o dts Compile o dts para dtb","title":"dtb (informa\u00e7\u00f5es de hardware para o Kernel)"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#gerando-o-dts","text":"Eu consegui esse comando via trocado com engenheiros da Terasic, os exemplos que encontrava nos tutorias da internet n\u00e3o funcionavam. Note Para funcionar \u00e9 necess\u00e1rio realizar o comando via o shell do embedded Execute os seguintes comandos: Note Voc\u00ea deve executar esse comando na pasta raiz do seu projeto Quartus! Agora com o .dts gerado, vamos dar uma olhada em seu conte\u00fado e como o interpretar. O dts possui a anatomia a seguir: - ref: https://developer.toradex.com/device-tree-customization O come\u00e7o do nosso .dts tem a defini\u00e7\u00e3o das CPUs que est\u00e3o dispon\u00edveis no CHIP: cpus { #address-cells = <1>; #size-cells = <0>; enable-method = \"altr,socfpga-smp\"; /* appended from boardinfo */ hps_0_arm_a9_0: cpu@0x0 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000000>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x0 (hps_0_arm_a9_0) hps_0_arm_a9_1: cpu@0x1 { device_type = \"cpu\"; compatible = \"arm,cortex-a9-16.1\", \"arm,cortex-a9\"; reg = <0x00000001>; next-level-cache = <&hps_0_L2>; /* appended from boardinfo */ }; //end cpu@0x1 (hps_0_arm_a9_1) }; //end cpus Vamos ver em mais detalhes o hps_0_uart0 do nosso dts : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-16.1\", \"snps,dw-apb-uart\"; reg = <0xffc02000 0x00000100>; interrupt-parent = <&hps_0_arm_gic_0>; interrupts = <0 162 4>; clocks = <&l4_sp_clk>; reg-io-width = <4>; /* embeddedsw.dts.params.reg-io-width type NUMBER */ reg-shift = <2>; /* embeddedsw.dts.params.reg-shift type NUMBER */ status = \"okay\"; /* embeddedsw.dts.params.status type STRING */ }; //end serial@0xffc02000 (hps_0_uart0) }; //end serial@0x100020000 (jtag_uart) Ele indica que no nosso hardware, temos um componente serial no endere\u00e7o 0xffc02000 que \u00e9 compat\u00edvel com os drivers: snps,dw-apb-uart-16.1 e.ou snps,dw-apb-uart , que \u00e9 implementado no Driver: 8250 no kernel do Linux: https://github.com/torvalds/linux/blob/master/drivers/tty/serial/8250/8250_dw.c . E esse driver est\u00e1 configurado como ativo no nosso kernel: E \u00e9 por conta disso que conseguimos acessar o kit com USB (screen). Par\u00e2metro CONFIG_SERIAL_8250_CONSOLE CONFIG_SERIAL_8250_CONSOLE: \u2502 \u2502 \u2502 \u2502 If you say Y here, it will be possible to use a serial port as the \u2502 \u2502 system console (the system console is the device which receives all \u2502 \u2502 kernel messages and warnings and which allows logins in single user \u2502 \u2502 mode). This could be useful if some terminal or printer is connected \u2502 \u2502 to that serial port. \u2502 \u2502 \u2502 \u2502 Even if you say Y here, the currently visible virtual console \u2502 \u2502 (/dev/tty0) will still be used as the system console by default, but \u2502 \u2502 you can alter that using a kernel command line option such as \u2502 \u2502 \"console=ttyS1\". (Try \"man bootparam\" or see the documentation of \u2502 \u2502 your boot loader (grub or lilo or loadlin) about how to pass options \u2502 \u2502 to the kernel at boot time.) \u2502 \u2502 \u2502 \u2502 If you don't have a VGA card installed and you say Y here, the \u2502 \u2502 kernel will automatically use the first serial line, /dev/ttyS0, as \u2502 \u2502 system console. \u2502 \u2502 \u2502 \u2502 You can set that using a kernel command line option such as \u2502 \u2502 \"console=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"console=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 and it will switch to normal serial console when the corresponding \u2502 \u2502 port is ready. \u2502 \u2502 \"earlycon=uart8250,io,0x3f8,9600n8\" \u2502 \u2502 \"earlycon=uart8250,mmio,0xff5e0000,115200n8\". \u2502 \u2502 it will not only setup early console. \u2502 \u2502 \u2502 \u2502 If unsure, say N. \u2502 \u2502 \u2502 \u2502 Symbol: SERIAL_8250_CONSOLE [=y] \u2502 \u2502 Type : boolean \u2502 \u2502 Prompt: Console on 8250/16550 and compatible serial port \u2502 Location: \u2502 \u2502 -> Device Drivers \u2502 \u2502 -> Character devices \u2502 \u2502 -> Serial drivers \u2502 \u2502 -> 8250/16550 and compatible serial support (SERIAL_8250 [=y]) \u2502 \u2502 Defined at drivers/tty/serial/8250/Kconfig:60 \u2502 \u2502 Depends on: TTY [=y] && HAS_IOMEM [=y] && SERIAL_8250 [=y]=y \u2502 \u2502 Selects: SERIAL_CORE_CONSOLE [=y] && SERIAL_EARLYCON [=y] \u2502 \u2502 !!! note \"Para mais informa\u00e7\u00f5es sobre o `dts\": - https://elinux.org/Device_Tree_Usage - https://elinux.org/Device_Tree_Reference - https://developer.toradex.com/device-tree-customization#Device_Tree_Anatomy - https://bootlin.com/pub/conferences/2014/elc/petazzoni-device-tree-dummies/petazzoni-device-tree-dummies.pdf ### Gerando o dtb Execute os seguintes comandos (ainda dentro do embedded shell) $ dtc -I dts -O dtb -o soc_system.dtb soc_system.dts $ #Agora voc\u00ea pode sair do embedded shell: $ exit Execute Gere o soc_system.dtb do projeto Grave o novo soc_system.dtb no SDCard (mesma parti\u00e7\u00e3o do kernel)","title":"Gerando o dts"},{"location":"Tutorial-HPS-FPGA-BlinkLED/#testando","text":"Agora plugue o SDcard no kit de desenvolvimento, e ap\u00f3s inicializa\u00e7\u00e3o do kernel execute o programa blink led e veja os LEDs da FPGA piscarem! Interessante n\u00e9? Agora vamos fazer algo mais \u00fatil com isso..","title":"Testando"},{"location":"Tutorial-HPS-FPGA-vga/","text":"Tutorial - HPS-FPGA - VGA \u00b6 Vamos agora fazer com o que nosso sistema embarcado possua uma sa\u00edda de v\u00eddeo, no caso do kit DE10-Standard isso deve ser feito pela porta VGA que est\u00e1 conectada na parte da FPGA do SoC. Vamos precisar fazer alguns passos para que isso funcione, s\u00e3o eles: Configurar a FPGA com o IP de VGA Adicionar o driver no kernel do Linux compat\u00edvel com o dispositivo N\u00e3o \u00e9 nativo Configurar o kernel do Linux com framebuffer Adicionar no buildroot um programa para exibir imagens no fb Configuar IP VGA \u00b6","title":"Tutorial - HPS-FPGA - VGA"},{"location":"Tutorial-HPS-FPGA-vga/#tutorial-hps-fpga-vga","text":"Vamos agora fazer com o que nosso sistema embarcado possua uma sa\u00edda de v\u00eddeo, no caso do kit DE10-Standard isso deve ser feito pela porta VGA que est\u00e1 conectada na parte da FPGA do SoC. Vamos precisar fazer alguns passos para que isso funcione, s\u00e3o eles: Configurar a FPGA com o IP de VGA Adicionar o driver no kernel do Linux compat\u00edvel com o dispositivo N\u00e3o \u00e9 nativo Configurar o kernel do Linux com framebuffer Adicionar no buildroot um programa para exibir imagens no fb","title":"Tutorial - HPS-FPGA - VGA"},{"location":"Tutorial-HPS-FPGA-vga/#configuar-ip-vga","text":"","title":"Configuar IP VGA"},{"location":"Tutorial-HPS-Kernel/","text":"Tutorial 7 - HPS - Compilando o kernel \u00b6 Nesse tutorial iremos compilar o kernel do Linux para o ARM do nosso SoC usando o toolchain que j\u00e1 temos configurado. Kernel 4.4 \u00b6 Clone o kernel do linux : $ git clone https://git.kernel.org $ cd linux Vamos trabalhar com a vers\u00e3o 4.4 do kernel que \u00e9 uma vers\u00e3o com: Long Time Suport (LTS), ou seja, ser\u00e1 mantida por muito mais tempo que as outras vers\u00f5es. A vers\u00e3o 4.4 foi lan\u00e7ada em 10 de Janeiro e ser\u00e1 mantida oficialmente at\u00e9 2021, ela \u00e9 tamb\u00e9m a vers\u00e3o Super LTS, com suporte estendido at\u00e9 2036. Linux Pense que um desenvolvedor de um sistema embarcado, que vai criar toda uma infra dedicada n\u00e3o quer ficar ter que ajustando e validando tudo novamente s\u00f3 para ter a vers\u00e3o mais nova do kenrel. A ideia de usar uma com maior suporte \u00e9 minimizar esfor\u00e7os. O kernel utiliza o sistema de tag do git: $ git tag ... v2.6.11 v2.6.11-tree v2.6.12 v2.6.12-rc2 v2.6.12-rc3 v2.6.12-rc4 v2.6.12-rc5 v2.6.12-rc6 v2.6.13-rc2 v2.6.14-rc2 v2.6.14-rc3 ... Note que revis\u00f5es \u00edmpares s\u00e3o para Karnel em est\u00e1gio de desenvolvimento, e n\u00fameros pares para vers\u00e3o de produ\u00e7\u00e3o, exemplo : Linux 2.4.x - Produ\u00e7\u00e3o Linux 2.5.x - Desenvolvimento Linux 2.6.x - Produ\u00e7\u00e3o .... Vamos criar um branch da vers\u00e3o v4.4, para isso execute o comando a seguir: $ git checkout v4.4 $ git checkout -b 4 .4-SoC Configurando o kernel \u00b6 Uma vez no branch 4.4-SoC precisamos configurar o kernel para nosso processador (ARM) e fazer as configura\u00e7\u00f5es necess\u00e1rias no kernel. Primeiramente iremos gerar um arquivo de configura\u00e7\u00e3o .config padr\u00e3o para SoCs ARM Altera: $ export ARCH = arm # indica a arquitetura do Kernel $ make socfpga_defconfig # gera o arquivo padr\u00e3o de configura\u00e7\u00e3o para SoC Note As configura\u00e7\u00e3o do kernel ficam salvos no arquivo: .config na raiz do reposit\u00f3rio. Quando executamos o comando make socfpga_defconfig , o mesmo \u00e9 inicializado com algumas configura\u00e7\u00f5es padr\u00f5es. Voc\u00ea pode dar uma olhada na pasta: linux/arch/arm/configs/socfpga_defconfig . Agora vamos configurar alguns par\u00e2metros espec\u00edficos do Kernel para a nossa aplica\u00e7\u00e3o: $ make ARCH = arm menuconfig Note Talvez seja necess\u00e1rio instalar o pacote libncurses5-dev Esse comando ir\u00e1 abrir a interface de configura\u00e7\u00e3o do Kernel do Linux (existem outras op\u00e7\u00f5es: make xconfig ; make config ; make gconfig , ...). Essa interface permite selecionarmos v\u00e1rias configura\u00e7\u00f5es do Kernel. Agora iremos seguir o roteiro proposto no tutorial a seguir, traduzido de maneira reduzida nesse tutorial. https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide Configurando \u00b6 Automatically append version information to the version string General Setup Desabilite : Automatically append version information to the version string Exclude/ Include Para Desativar utilize a letra N do teclado, para incluir a letra Y D\u00favidas? A maioria dos par\u00e2metros possui uma explica\u00e7\u00e3o, basta apertar ? para ler a respeito. Note ref : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Go into the \u201cGeneral Setup\u201d menu. Uncheck \u201cAutomatically append version information to the version string\u201d. This will prevent the kernel from adding extra \u201cversion\u201d information to the kernel. Whenever we try to dynamically load a driver (also called kernel modules, as discussed in a later section) the kernel will check to see if the driver was built with the same version of the source code as itself. If it isn\u2019t, it will reject to load that driver. For development, it\u2019s useful to disable these options to make it easier to test out different versions of drivers. In a production system however, it\u2019s recommend to keep this option enabled and only use drivers that were compiled with the correct version of the kernel. I encourage you to peruse the options in the General Setup menu and see what\u2019s available to you (hitting \u201c?\u201d to view the help info for the highlighted option). Of particular importance to us is the \u201cEmbedded System\u201d option (turns on advanced features) and the type of SLAB allocator used (determines how memory will be dynamically allocated in the kernel). If you want to use an initial ram disk or ram filesystem that would be enabled here as well (these will be explained in the next section). (texto extra\u00eddo da refer\u00eancia) Enable loadable module support \u00b6 Volte para o menu principal ( <ESC> <ESC> ) Note que o Enable loadable module support est\u00e1 ativado. Isso permite que o kernel seja modificado (pelo carregamento de drivers) ap\u00f3s a sua execu\u00e7\u00e3o. Isso ser\u00e1 \u00fatil quando formos desenvolver nosso pr\u00f3prio device driver, sem a necessidade de recompilarmos o kernel toda vez que desejamos testar uma modifica\u00e7\u00e3o no c\u00f3digo. \u00c9 essa configura\u00e7\u00e3o que permite utilizarmos USBs, SSDs, placas de rede via a possibilidade do carregamento de drivers de forma din\u00e2mica pelo sistema operacional. Support for large (2TB+) block devices and files \u00b6 No menu principal Enable the block layer Ative : Support for large (2TB+) block devices and files Essa op\u00e7\u00e3o ir\u00e1 permitir a utiliza\u00e7\u00e3o de parti\u00e7\u00f5es do tipo EXT4. Se esquecer essa op\u00e7\u00e3o e o kernel tiver em uma parti\u00e7\u00e3o EXT4 a mesma ser\u00e1 montada como READ-ONLY. The Extended 4 (ext4) filesystem \u00b6 Menu principal File systems Ative : The Extended 4 (ext4) filesystem Essa op\u00e7\u00e3o ir\u00e1 possibilitar que o kernel monte dispositivos formatados em EXT4. Pretendemos usar isso no SDCARD. Altera SOCFPGA family \u00b6 Menu principal System Type Ative : Altera SOCFGPA family Isso indica para o kernel qual ser\u00e1 o dispositivo que o mesmo ser\u00e1 executado, note que esssa op\u00e7\u00e3o possui um novo menu onde podemos ativar ou n\u00e3o a suspens\u00e3o para RAM. Symmetric Multi-Processing \u00b6 Menu principal Kernel Features Ative : Symmmetric Multi-Processing Essa op\u00e7\u00e3o indica para o kernel que ele deve utilizar os dois cores presente no ARM HPS da FPGA. Device Drivers \u00b6 Menu principal Device Drivers Indica quais drivers ser\u00e3o compilados junto com o kernel, note que j\u00e1 temos configurado drivers de rede (Network device support); GPIO (GPIO Support); RTC; DMA; ... . Lembre que j\u00e1 inicializamos o .config com uma configura\u00e7\u00e3o padr\u00e3o para SoCs Altera. Salvando \u00b6 Aperte ESC duas vezes ( <ESC> <ESC> ) e salve as configura\u00e7\u00f5es no arquivo .config .config \u00b6 Note De uma olhada no arquivo .config gerado! As vezes \u00e9 mais f\u00e1cil editar direto nele, do que ter que abrir o menu de configura\u00e7\u00e3o e encontrar o local de ativar um m\u00f3dulo. Compilando \u00b6 O makefile utiliza a vari\u00e1vel CROSS_COMPILE para definir o toolchain que ir\u00e1 fazer a compila\u00e7\u00e3o do kernel, vamos definir como sendo o GCC do Linaro baixado recentemente: $ export CROSS_COMPILE = $GCC_Linaro /arm-linux-gnueabihf- Para compilarmos o kernel : make ARCH = arm LOCALVERSION = zImage -j 4 Note -j4 executa a compila\u00e7\u00e3o em 4 threads, voc\u00ea pode ajustar esse valor para adequar ao seu processador. Dica Adicione o export CROSS_COMPILE=.... ao seu .bashrc para n\u00e3o ter que ficar digitando isso sempre que tiver que compilar o kernel. Fail Caso aconte\u00e7a algum erro de build, deve-se verificar o path do CROSS_COMPILE ou se existe alguma depend\u00eancia que n\u00e3o foi satisfeita. Esse comando faz com que o kernel do linux seja compilado em uma vers\u00e3o compactada que \u00e9 auto-extra\u00edda. Outras op\u00e7\u00f5es seriam : Image : Bin\u00e1rio do kernel zImage: vers\u00e3o compactada que possui self-extracting uImage: uma vers\u00e3o que j\u00e1 possui o bootloader uboot 1^: https://stackoverflow.com/questions/22322304/image-vs-zimage-vs-uimage o zImage \u00e9 salvo em: arch/arm/boot/zImage zImage Esse arquivo \u00e9 o bin\u00e1rio que cont\u00e9m o kernel do linux e ser\u00e1 executado no sistema embarcado. Agora devemos atualizar o kernel que est\u00e1 no SDCard, para isso segue o tutorial no /info-SDcard.md/ : Atualizando o kernel Executando \u00b6 Para verificar se tudo est\u00e1 certo, basta colocar o cart\u00e3o de mem\u00f3ria no kit e verificar a vers\u00e3o do kernel em execu\u00e7\u00e3o: $ uname -a Linux buildroot 4 .14.0 #1 SMP Mon Jul 16 21:22:58 -03 2018 armv7l GNU/Linux Mouse/ Teclado \u00b6 Example Plugue um mouse USB na placa e verifique se a mesma funciona!","title":"Tutorial 7 - HPS - Compilando o kernel"},{"location":"Tutorial-HPS-Kernel/#tutorial-7-hps-compilando-o-kernel","text":"Nesse tutorial iremos compilar o kernel do Linux para o ARM do nosso SoC usando o toolchain que j\u00e1 temos configurado.","title":"Tutorial 7 - HPS - Compilando o kernel"},{"location":"Tutorial-HPS-Kernel/#kernel-44","text":"Clone o kernel do linux : $ git clone https://git.kernel.org $ cd linux Vamos trabalhar com a vers\u00e3o 4.4 do kernel que \u00e9 uma vers\u00e3o com: Long Time Suport (LTS), ou seja, ser\u00e1 mantida por muito mais tempo que as outras vers\u00f5es. A vers\u00e3o 4.4 foi lan\u00e7ada em 10 de Janeiro e ser\u00e1 mantida oficialmente at\u00e9 2021, ela \u00e9 tamb\u00e9m a vers\u00e3o Super LTS, com suporte estendido at\u00e9 2036. Linux Pense que um desenvolvedor de um sistema embarcado, que vai criar toda uma infra dedicada n\u00e3o quer ficar ter que ajustando e validando tudo novamente s\u00f3 para ter a vers\u00e3o mais nova do kenrel. A ideia de usar uma com maior suporte \u00e9 minimizar esfor\u00e7os. O kernel utiliza o sistema de tag do git: $ git tag ... v2.6.11 v2.6.11-tree v2.6.12 v2.6.12-rc2 v2.6.12-rc3 v2.6.12-rc4 v2.6.12-rc5 v2.6.12-rc6 v2.6.13-rc2 v2.6.14-rc2 v2.6.14-rc3 ... Note que revis\u00f5es \u00edmpares s\u00e3o para Karnel em est\u00e1gio de desenvolvimento, e n\u00fameros pares para vers\u00e3o de produ\u00e7\u00e3o, exemplo : Linux 2.4.x - Produ\u00e7\u00e3o Linux 2.5.x - Desenvolvimento Linux 2.6.x - Produ\u00e7\u00e3o .... Vamos criar um branch da vers\u00e3o v4.4, para isso execute o comando a seguir: $ git checkout v4.4 $ git checkout -b 4 .4-SoC","title":"Kernel 4.4"},{"location":"Tutorial-HPS-Kernel/#configurando-o-kernel","text":"Uma vez no branch 4.4-SoC precisamos configurar o kernel para nosso processador (ARM) e fazer as configura\u00e7\u00f5es necess\u00e1rias no kernel. Primeiramente iremos gerar um arquivo de configura\u00e7\u00e3o .config padr\u00e3o para SoCs ARM Altera: $ export ARCH = arm # indica a arquitetura do Kernel $ make socfpga_defconfig # gera o arquivo padr\u00e3o de configura\u00e7\u00e3o para SoC Note As configura\u00e7\u00e3o do kernel ficam salvos no arquivo: .config na raiz do reposit\u00f3rio. Quando executamos o comando make socfpga_defconfig , o mesmo \u00e9 inicializado com algumas configura\u00e7\u00f5es padr\u00f5es. Voc\u00ea pode dar uma olhada na pasta: linux/arch/arm/configs/socfpga_defconfig . Agora vamos configurar alguns par\u00e2metros espec\u00edficos do Kernel para a nossa aplica\u00e7\u00e3o: $ make ARCH = arm menuconfig Note Talvez seja necess\u00e1rio instalar o pacote libncurses5-dev Esse comando ir\u00e1 abrir a interface de configura\u00e7\u00e3o do Kernel do Linux (existem outras op\u00e7\u00f5es: make xconfig ; make config ; make gconfig , ...). Essa interface permite selecionarmos v\u00e1rias configura\u00e7\u00f5es do Kernel. Agora iremos seguir o roteiro proposto no tutorial a seguir, traduzido de maneira reduzida nesse tutorial. https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide","title":"Configurando o kernel"},{"location":"Tutorial-HPS-Kernel/#configurando","text":"Automatically append version information to the version string General Setup Desabilite : Automatically append version information to the version string Exclude/ Include Para Desativar utilize a letra N do teclado, para incluir a letra Y D\u00favidas? A maioria dos par\u00e2metros possui uma explica\u00e7\u00e3o, basta apertar ? para ler a respeito. Note ref : https://rocketboards.org/foswiki/Documentation/EmbeddedLinuxBeginnerSGuide#8 Go into the \u201cGeneral Setup\u201d menu. Uncheck \u201cAutomatically append version information to the version string\u201d. This will prevent the kernel from adding extra \u201cversion\u201d information to the kernel. Whenever we try to dynamically load a driver (also called kernel modules, as discussed in a later section) the kernel will check to see if the driver was built with the same version of the source code as itself. If it isn\u2019t, it will reject to load that driver. For development, it\u2019s useful to disable these options to make it easier to test out different versions of drivers. In a production system however, it\u2019s recommend to keep this option enabled and only use drivers that were compiled with the correct version of the kernel. I encourage you to peruse the options in the General Setup menu and see what\u2019s available to you (hitting \u201c?\u201d to view the help info for the highlighted option). Of particular importance to us is the \u201cEmbedded System\u201d option (turns on advanced features) and the type of SLAB allocator used (determines how memory will be dynamically allocated in the kernel). If you want to use an initial ram disk or ram filesystem that would be enabled here as well (these will be explained in the next section). (texto extra\u00eddo da refer\u00eancia)","title":"Configurando"},{"location":"Tutorial-HPS-Kernel/#enable-loadable-module-support","text":"Volte para o menu principal ( <ESC> <ESC> ) Note que o Enable loadable module support est\u00e1 ativado. Isso permite que o kernel seja modificado (pelo carregamento de drivers) ap\u00f3s a sua execu\u00e7\u00e3o. Isso ser\u00e1 \u00fatil quando formos desenvolver nosso pr\u00f3prio device driver, sem a necessidade de recompilarmos o kernel toda vez que desejamos testar uma modifica\u00e7\u00e3o no c\u00f3digo. \u00c9 essa configura\u00e7\u00e3o que permite utilizarmos USBs, SSDs, placas de rede via a possibilidade do carregamento de drivers de forma din\u00e2mica pelo sistema operacional.","title":"Enable loadable module support"},{"location":"Tutorial-HPS-Kernel/#support-for-large-2tb-block-devices-and-files","text":"No menu principal Enable the block layer Ative : Support for large (2TB+) block devices and files Essa op\u00e7\u00e3o ir\u00e1 permitir a utiliza\u00e7\u00e3o de parti\u00e7\u00f5es do tipo EXT4. Se esquecer essa op\u00e7\u00e3o e o kernel tiver em uma parti\u00e7\u00e3o EXT4 a mesma ser\u00e1 montada como READ-ONLY.","title":"Support for large (2TB+) block devices and files"},{"location":"Tutorial-HPS-Kernel/#the-extended-4-ext4-filesystem","text":"Menu principal File systems Ative : The Extended 4 (ext4) filesystem Essa op\u00e7\u00e3o ir\u00e1 possibilitar que o kernel monte dispositivos formatados em EXT4. Pretendemos usar isso no SDCARD.","title":"The Extended 4 (ext4) filesystem"},{"location":"Tutorial-HPS-Kernel/#altera-socfpga-family","text":"Menu principal System Type Ative : Altera SOCFGPA family Isso indica para o kernel qual ser\u00e1 o dispositivo que o mesmo ser\u00e1 executado, note que esssa op\u00e7\u00e3o possui um novo menu onde podemos ativar ou n\u00e3o a suspens\u00e3o para RAM.","title":"Altera SOCFPGA family"},{"location":"Tutorial-HPS-Kernel/#symmetric-multi-processing","text":"Menu principal Kernel Features Ative : Symmmetric Multi-Processing Essa op\u00e7\u00e3o indica para o kernel que ele deve utilizar os dois cores presente no ARM HPS da FPGA.","title":"Symmetric Multi-Processing"},{"location":"Tutorial-HPS-Kernel/#device-drivers","text":"Menu principal Device Drivers Indica quais drivers ser\u00e3o compilados junto com o kernel, note que j\u00e1 temos configurado drivers de rede (Network device support); GPIO (GPIO Support); RTC; DMA; ... . Lembre que j\u00e1 inicializamos o .config com uma configura\u00e7\u00e3o padr\u00e3o para SoCs Altera.","title":"Device Drivers"},{"location":"Tutorial-HPS-Kernel/#salvando","text":"Aperte ESC duas vezes ( <ESC> <ESC> ) e salve as configura\u00e7\u00f5es no arquivo .config","title":"Salvando"},{"location":"Tutorial-HPS-Kernel/#config","text":"Note De uma olhada no arquivo .config gerado! As vezes \u00e9 mais f\u00e1cil editar direto nele, do que ter que abrir o menu de configura\u00e7\u00e3o e encontrar o local de ativar um m\u00f3dulo.","title":".config"},{"location":"Tutorial-HPS-Kernel/#compilando","text":"O makefile utiliza a vari\u00e1vel CROSS_COMPILE para definir o toolchain que ir\u00e1 fazer a compila\u00e7\u00e3o do kernel, vamos definir como sendo o GCC do Linaro baixado recentemente: $ export CROSS_COMPILE = $GCC_Linaro /arm-linux-gnueabihf- Para compilarmos o kernel : make ARCH = arm LOCALVERSION = zImage -j 4 Note -j4 executa a compila\u00e7\u00e3o em 4 threads, voc\u00ea pode ajustar esse valor para adequar ao seu processador. Dica Adicione o export CROSS_COMPILE=.... ao seu .bashrc para n\u00e3o ter que ficar digitando isso sempre que tiver que compilar o kernel. Fail Caso aconte\u00e7a algum erro de build, deve-se verificar o path do CROSS_COMPILE ou se existe alguma depend\u00eancia que n\u00e3o foi satisfeita. Esse comando faz com que o kernel do linux seja compilado em uma vers\u00e3o compactada que \u00e9 auto-extra\u00edda. Outras op\u00e7\u00f5es seriam : Image : Bin\u00e1rio do kernel zImage: vers\u00e3o compactada que possui self-extracting uImage: uma vers\u00e3o que j\u00e1 possui o bootloader uboot 1^: https://stackoverflow.com/questions/22322304/image-vs-zimage-vs-uimage o zImage \u00e9 salvo em: arch/arm/boot/zImage zImage Esse arquivo \u00e9 o bin\u00e1rio que cont\u00e9m o kernel do linux e ser\u00e1 executado no sistema embarcado. Agora devemos atualizar o kernel que est\u00e1 no SDCard, para isso segue o tutorial no /info-SDcard.md/ : Atualizando o kernel","title":"Compilando"},{"location":"Tutorial-HPS-Kernel/#executando","text":"Para verificar se tudo est\u00e1 certo, basta colocar o cart\u00e3o de mem\u00f3ria no kit e verificar a vers\u00e3o do kernel em execu\u00e7\u00e3o: $ uname -a Linux buildroot 4 .14.0 #1 SMP Mon Jul 16 21:22:58 -03 2018 armv7l GNU/Linux","title":"Executando"},{"location":"Tutorial-HPS-Kernel/#mouse-teclado","text":"Example Plugue um mouse USB na placa e verifique se a mesma funciona!","title":"Mouse/ Teclado"},{"location":"Tutorial-HPS-Linux/","text":"Tutorial-HPS-Embarcando \u00b6 O HPS espera um SDCARD formatado com o esquema a seguir para que o possa carregar o boot loader e depois o kernel : Esse roteiro n\u00e3o trata a fundo a cria\u00e7\u00e3o das parti\u00e7\u00f5es no SDCARD, que podem ser facilmente geradas com o fsdisk do Linux. Aqui iremos usar uma imagem padr\u00e3o que j\u00e1 possui a formata\u00e7\u00e3o e atualizar o SDCARD com o nosso uboot / kernel e filesystem. Imagem padr\u00e3o \u00b6 Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem): O conte\u00fado da imagem e como a mesma foi criada \u00e9 detalhado no p\u00e1gina (acesse para fazer o download da iso): SDcard img base . Para usar, basta fazer o download e salvar no SDCard. Note que no comando DD deve-se substituir o SeuDevice pelo caminho que o seu Linux atribuiu ao dispositivo. Para saber basta verificar o dmesg: $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 Estamos interessados no: mmcblk0 . Agora vamos salvar a .iso no SDcard. Cuidado, se errar o dispositivo (of=/dev/mmcblk0) pode acontecer muitas coisas ruins $ sudo dd bs = 4M if = SDCardEmptyCycloneV of = /dev/mmcblk0 conv = fsync status = progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 819,2 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1,0 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 2121728 3799448 1677721 819 ,2M b W95 FAT32 /dev/mmcblk0p2 14336 2111488 2097153 1G 83 Linux /dev/mmcblk0p3 2048 4096 2049 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Pr\u00f3ximos passo \u00b6 Se \u00e9 a primeira vez nesse tutorial siga direto para o Tutorial HPS BlinkLED . Atualizando os arquivos \u00b6 Para atualizar o SDCARD com a vers\u00e3o rec\u00e9m gerada siga os passo a seguir. Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9 : /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildrrot. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6 $ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"Tutorial-HPS-Embarcando"},{"location":"Tutorial-HPS-Linux/#tutorial-hps-embarcando","text":"O HPS espera um SDCARD formatado com o esquema a seguir para que o possa carregar o boot loader e depois o kernel : Esse roteiro n\u00e3o trata a fundo a cria\u00e7\u00e3o das parti\u00e7\u00f5es no SDCARD, que podem ser facilmente geradas com o fsdisk do Linux. Aqui iremos usar uma imagem padr\u00e3o que j\u00e1 possui a formata\u00e7\u00e3o e atualizar o SDCARD com o nosso uboot / kernel e filesystem.","title":"Tutorial-HPS-Embarcando"},{"location":"Tutorial-HPS-Linux/#imagem-padrao","text":"Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem): O conte\u00fado da imagem e como a mesma foi criada \u00e9 detalhado no p\u00e1gina (acesse para fazer o download da iso): SDcard img base . Para usar, basta fazer o download e salvar no SDCard. Note que no comando DD deve-se substituir o SeuDevice pelo caminho que o seu Linux atribuiu ao dispositivo. Para saber basta verificar o dmesg: $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 Estamos interessados no: mmcblk0 . Agora vamos salvar a .iso no SDcard. Cuidado, se errar o dispositivo (of=/dev/mmcblk0) pode acontecer muitas coisas ruins $ sudo dd bs = 4M if = SDCardEmptyCycloneV of = /dev/mmcblk0 conv = fsync status = progress $ sync O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 819,2 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 1,0 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 2121728 3799448 1677721 819 ,2M b W95 FAT32 /dev/mmcblk0p2 14336 2111488 2097153 1G 83 Linux /dev/mmcblk0p3 2048 4096 2049 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot .","title":"Imagem padr\u00e3o"},{"location":"Tutorial-HPS-Linux/#proximos-passo","text":"Se \u00e9 a primeira vez nesse tutorial siga direto para o Tutorial HPS BlinkLED .","title":"Pr\u00f3ximos passo"},{"location":"Tutorial-HPS-Linux/#atualizando-os-arquivos","text":"Para atualizar o SDCARD com a vers\u00e3o rec\u00e9m gerada siga os passo a seguir.","title":"Atualizando os arquivos"},{"location":"Tutorial-HPS-Linux/#kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9 : /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/HPS-Linux/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Kernel"},{"location":"Tutorial-HPS-Linux/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildrrot. # Limpando fs antigo $ sudo rm -r /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /run/media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"Tutorial-HPS-Linux/#uboot-script-e-device-tree","text":"$ cp ~/work/HPS-Linux/u-boot.scr /run/media/corsi/B0DA-B234/ $ cp ~/work/HPS-Linux/socfpga.dtb /run/media/corsi/B0DA-B234/ $ sync","title":"uboot script e device tree"},{"location":"Tutorial-HPS-Running/","text":"Tutorial 4 - HPS - Linux embarcado \u00b6 Danger Nesse tutorial mexemos com grava\u00e7\u00e3o de disco, se errar o dispositivo pode corromper seus arquivos!!! Vamos nessa etapa executar um linux de exemplo fornecido pela Terasic, para isso, ser\u00e1 necess\u00e1rio programarmos um SDcard com a imagem. Esse Linux \u00e9 um ubuntu para sistemas embarcados. Vamos executar os seguintes passos: Download e gravar a Imagem padr\u00e3o (iso) no SDcard Insira o SDCard na FPGA Conecte o USB na porta UART (perto da porta Ethernet) Conecte a alimenta\u00e7\u00e3o Conecte-se ao terminal via UART Imagem padr\u00e3o (sdcard) \u00b6 Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem), essa imagem \u00e9 um ubuntu para ARM com algumas configura\u00e7\u00f5es espec\u00edficas para FPGA Cyclone V (vamos ver isso mais para frente). Download Fa\u00e7a o download da imagem Linux Console (Kernel 4.5) do site da terasic: - \"Linux BSP (Board Support Package): MicroSD Card Image\" Extraia o arquio de10_standard_linux_console.img do arquivo zipado, esse .img \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Agora temos que copiar o img para o cart\u00e3o de mem\u00f3ria. Insira o cart\u00e3o de mem\u00f3ria no computador Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg , que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: Cuidado, estou assumindo que nenhum dispositivo foi inserido ap\u00f3s o SDcard $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 O dmesg possui o log que o meu SDCARD foi alocado ao: /dev/mmclk0 , no seu linux pode ser outro nome! Warning Isso pode mudar de PC para PC! Agora vamos salvar a .iso no SDcard. Danger Cuidado, se errar o dispositivo (no meu caso: of=/dev/mmcblk0) pode acontecer coisas muito ruins com os seus dados $ sudo dd bs = 4M if = de10_standard_linux_console.img of = /dev/mmcblk0 conv = fsync status = progress $ sync dd O comando dd executa uma c\u00f3pia bit a bit de um arquivo de entrada input file: if para um output file: of O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 3,3 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 4096 1028095 1024000 500M b W95 FAT32 /dev/mmcblk0p2 1028096 7376895 6348800 3G 83 Linux /dev/mmcblk0p3 2048 4095 2048 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Success Agora remova o SDCard e o coloque na FPGA USB - UART \u00b6 O USB UART \u00e9 um conector que possibilita acessar a sa\u00edda serial do HPS via porta serial. No linux o driver \u00e9 reconhecido automaticamente, no Windows ser\u00e1 necess\u00e1rio instalar manualmente o driver da serial.. Uma vez conectado no linux host, verificamos que o mesmo foi mapeado para um dispositivo do tipo serial ( no meu caso com nome ttyUSB0 ): $ dmesg | tail .... [80473.426308] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected [80473.426333] usb 1-2: Detected FT232RL [80473.426456] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0 ... Warning Isso pode mudar de PC para PC! Para conectarmos nessa porta, precisamos usar um programa do tipo: emulador de terminal. No caso iremos utilizar o screen (verificar se possui instalado). Note que o comando a seguir deve ser modificado para o device ( /dev/ttyxxx ) na qual o seu linux associou a porta USB-Serial, extra\u00eddo do dmesg. $ screen /dev/ttyUSB0 115200,cs8 Para sair do terminal: ctrl+A : quit Linux \u00b6 Logue no linux com o usu\u00e1rio: root , sem senha. No linux verifique que existem um execut\u00e1vel chamado HPS_FPGA_LED na pasta /home/root/ . Esse programa faz com que os LEDs da FPGA pisquem. user e password user: root pass: `` Legal! Vamos agora descobrir como executar um kernel compilado por n\u00f3s!","title":"Tutorial 4 - HPS - Linux embarcado"},{"location":"Tutorial-HPS-Running/#tutorial-4-hps-linux-embarcado","text":"Danger Nesse tutorial mexemos com grava\u00e7\u00e3o de disco, se errar o dispositivo pode corromper seus arquivos!!! Vamos nessa etapa executar um linux de exemplo fornecido pela Terasic, para isso, ser\u00e1 necess\u00e1rio programarmos um SDcard com a imagem. Esse Linux \u00e9 um ubuntu para sistemas embarcados. Vamos executar os seguintes passos: Download e gravar a Imagem padr\u00e3o (iso) no SDcard Insira o SDCard na FPGA Conecte o USB na porta UART (perto da porta Ethernet) Conecte a alimenta\u00e7\u00e3o Conecte-se ao terminal via UART","title":"Tutorial 4 - HPS - Linux embarcado"},{"location":"Tutorial-HPS-Running/#imagem-padrao-sdcard","text":"Utilizaremos uma imagem (.iso) j\u00e1 gerado com as especifica\u00e7\u00f5es e que j\u00e1 possui todo o sistema necess\u00e1rio para executar o linux no HPS (incluindo boot loader, kernel e filesystem), essa imagem \u00e9 um ubuntu para ARM com algumas configura\u00e7\u00f5es espec\u00edficas para FPGA Cyclone V (vamos ver isso mais para frente). Download Fa\u00e7a o download da imagem Linux Console (Kernel 4.5) do site da terasic: - \"Linux BSP (Board Support Package): MicroSD Card Image\" Extraia o arquio de10_standard_linux_console.img do arquivo zipado, esse .img \u00e9 uma c\u00f3pia bit a bit do que deve ser salvo no SDCard. Agora temos que copiar o img para o cart\u00e3o de mem\u00f3ria. Insira o cart\u00e3o de mem\u00f3ria no computador Quando inserirmos um disco externo no linux o mesmo o associa a um 'device' na pasta '/dev/', para sabermos qual o nome do device que foi atribu\u00eddo ao SDcard, podemos usar o comando dmesg , que exibe o log do sistema operacional e nele podemos ver qual foi o \u00faltimo hardware detectado e qual device foi atribu\u00eddo: Cuidado, estou assumindo que nenhum dispositivo foi inserido ap\u00f3s o SDcard $ dmesg | tail 4789 .207972 ] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [ 4789 .211680 ] mmcblk0: mmc0:aaaa SL16G 14 .8 GiB [ 4789 .215857 ] mmcblk0: p1 p2 p3 [ 4988 .443942 ] mmcblk0: p1 p2 p3 O dmesg possui o log que o meu SDCARD foi alocado ao: /dev/mmclk0 , no seu linux pode ser outro nome! Warning Isso pode mudar de PC para PC! Agora vamos salvar a .iso no SDcard. Danger Cuidado, se errar o dispositivo (no meu caso: of=/dev/mmcblk0) pode acontecer coisas muito ruins com os seus dados $ sudo dd bs = 4M if = de10_standard_linux_console.img of = /dev/mmcblk0 conv = fsync status = progress $ sync dd O comando dd executa uma c\u00f3pia bit a bit de um arquivo de entrada input file: if para um output file: of O sync \u00e9 necess\u00e1rio para que o kernel fa\u00e7a um flush do cashe escrevendo realmente no SDCard todos os dados que foram endere\u00e7ados a ele. Essa etapa pode ser um pouco demorada. Agora basta montar no seu linux o SDCard rec\u00e9m escrito e devemos ter duas parti\u00e7\u00f5es vis\u00edveis: 524 MiB: FAT32 Script de configura\u00e7\u00e3o do uboot; Kernel comprimido; Device Tree Blob file u-boot.scr; zImage; socfpga.dtb 3,3 GiB: Filesystem (/) E outra parti\u00e7\u00e3o que n\u00e3o \u00e9 vis\u00edvel (cont\u00e9m o preloader e o uboot), para visualizar : $ sudo fdisk -l /dev/mmcblk0 ... Device Boot Start End Sectors Size Id Type /dev/mmcblk0p1 4096 1028095 1024000 500M b W95 FAT32 /dev/mmcblk0p2 1028096 7376895 6348800 3G 83 Linux /dev/mmcblk0p3 2048 4095 2048 1M a2 unknown ... Note que a parti\u00e7\u00e3o 3 (mmcblk0p3) \u00e9 do tipo unknown (a2) e possui 1M de espa\u00e7o. \u00c9 nela que temos salvo o preloader e o uboot . Success Agora remova o SDCard e o coloque na FPGA","title":"Imagem padr\u00e3o (sdcard)"},{"location":"Tutorial-HPS-Running/#usb-uart","text":"O USB UART \u00e9 um conector que possibilita acessar a sa\u00edda serial do HPS via porta serial. No linux o driver \u00e9 reconhecido automaticamente, no Windows ser\u00e1 necess\u00e1rio instalar manualmente o driver da serial.. Uma vez conectado no linux host, verificamos que o mesmo foi mapeado para um dispositivo do tipo serial ( no meu caso com nome ttyUSB0 ): $ dmesg | tail .... [80473.426308] ftdi_sio 1-2:1.0: FTDI USB Serial Device converter detected [80473.426333] usb 1-2: Detected FT232RL [80473.426456] usb 1-2: FTDI USB Serial Device converter now attached to ttyUSB0 ... Warning Isso pode mudar de PC para PC! Para conectarmos nessa porta, precisamos usar um programa do tipo: emulador de terminal. No caso iremos utilizar o screen (verificar se possui instalado). Note que o comando a seguir deve ser modificado para o device ( /dev/ttyxxx ) na qual o seu linux associou a porta USB-Serial, extra\u00eddo do dmesg. $ screen /dev/ttyUSB0 115200,cs8 Para sair do terminal: ctrl+A : quit","title":"USB - UART"},{"location":"Tutorial-HPS-Running/#linux","text":"Logue no linux com o usu\u00e1rio: root , sem senha. No linux verifique que existem um execut\u00e1vel chamado HPS_FPGA_LED na pasta /home/root/ . Esse programa faz com que os LEDs da FPGA pisquem. user e password user: root pass: `` Legal! Vamos agora descobrir como executar um kernel compilado por n\u00f3s!","title":"Linux"},{"location":"Tutorial-HPS-SDcard/","text":"Atualizando o SDCARD \u00b6 Premissas Atualizando o preload \u00b6 TBD Atualizando o uboot \u00b6 TBD uboot script \u00b6 $ cp u-boot.scr /run/media/corsi/B0DA-B234/ Atualizando Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. Atualizando o dts \u00b6 $ cp socfpga.dtb /run/media/corsi/B0DA-B234/ FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6","title":"Atualizando o SDCARD"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-sdcard","text":"Premissas","title":"Atualizando o SDCARD"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-preload","text":"TBD","title":"Atualizando o preload"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-uboot","text":"TBD","title":"Atualizando o uboot"},{"location":"Tutorial-HPS-SDcard/#uboot-script","text":"$ cp u-boot.scr /run/media/corsi/B0DA-B234/","title":"uboot script"},{"location":"Tutorial-HPS-SDcard/#atualizando-kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Atualizando Kernel"},{"location":"Tutorial-HPS-SDcard/#atualizando-o-dts","text":"$ cp socfpga.dtb /run/media/corsi/B0DA-B234/","title":"Atualizando o dts"},{"location":"Tutorial-HPS-SDcard/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"Tutorial-HPS-SDcard/#uboot-script-e-device-tree","text":"","title":"uboot script e device tree"},{"location":"Tutorial-HPS/","text":"Vis\u00e3o geral \u00b6 A FPGA contida no kit DE10-Standard \u00e9 um chip SoC que em um \u00fanico dispositivo que possui duas partes: o fabric da FPGA e um Hardware Process System (HPS). HPS \u00e9 o termo utilizado pela Intel-Altera para definir a parte da FPGA que \u00e9 fixa e relativa ao processador ARM A9 (pode ser outro ARM, depende da fam\u00edlia da FPGA). O HPS possui uma unidade de processamento com um ou dois Cores (depende do chip, no nosso caso \u00e9 dual core ) e alguns perif\u00e9ricos conectados em seu barramento (DMA, UART, USB, EMACS, ...). Al\u00e9m dos perif\u00e9ricos j\u00e1 contidos no HPS \u00e9 poss\u00edvel conectarmos novos perif\u00e9ricos sintetizados na FPGA via a interface HPS FPGA Interfaces . Ler Introdu\u00e7\u00e3o: 1 Introduction to Cyclone V Hard Processor System (HPS) Fam\u00edlia de FPGAs \u00b6 A Altera possui quatro fam\u00edlia de FPGAs-SoC : Stratix 10 SoC: High end, 14nm com ARM-Cortex-A53 de 64bits quad-core Arria 10 SoC: 20nm, Cortex A9 duas core com grande capacidade na FPGA Temos um kit no lab Arria V SoC: 28nm, Cortex A9 com foco em telecomunica\u00e7\u00f5es Cyclone V SoC : Fam\u00edlia low end com valor mais baixo e mais low power. Cortex A9 \u00b6 O Cortex A9 existente no HPS da Cyclone V possui as caracter\u00edsticas a seguir (extra\u00eddo do datasheet ): ARM Cortex-A9 MPCore One or two ARM Cortex-A9 processors in a cluster NEON SIMD coprocessor and VFPv3 per processor Snoop Control Unit (SCU) to ensure coherency within the cluster Accelerator coherency port (ACP) that accepts coherency memory access requests Interrupt controller One general-purpose timer and one watchdog timer per processor \u2022 Debug and trace features 32 KB instruction and 32 KB data level 1 (L1) caches per processor Memory management unit (MMU) per processor ARM L2-310 level 2 (L2) cache Shared 512 KB L2 cache A seguir um diagrama detalhado do HPS: Conex\u00e3o entre HPS e FPGA \u00b6 Note que existe no diagrama anterior algumas interfaces definidas no \"FPGA Portion\", essas interfaces permitem a ponte entre o Fabric da FPGA e o ARM hard core do chip. As interfaces s\u00e3o, resumidamente: FPGA to HPS: Barramento na qual um Master na FPGA (Platform Designer) acessa o ARM HPS to FPGA: Barramento pelo qual o ARM acessa um perif\u00e9rico (slave) na FPGA Lightweight HPS to FPGA: Barramento de menor banda que conecta o ARM em um perif\u00e9rico na FPGA (slave) 1-6 Masters SDRAM Controller: Permite a FPGA ler e escrever da mem\u00f3ria SDRAM externa ao chip AXI \u00b6 Os barramentos s\u00e3o todos do tipo AXI , um padr\u00e3o definido pela pr\u00f3pria ARM e usada em seus microcontroladores. AXI - AVALON Via Platform Designer podemos conectarmos perif\u00e9ricos com o barramento Avalon (mm) no barramento AXI do ARM, isso \u00e9 poss\u00edvel por uma \"m\u00e1gica\" que a PD faz convertendo um barramento no outro de forma transparente ao usu\u00e1rio. SDRAM \u00b6 A SDRAM deve ser usada com muita cautela pois ela ser\u00e1 compartilhada com o Linux que estar\u00e1 em execu\u00e7\u00e3o no ARM, caso um perif\u00e9rico da FPGA acesse \"aleatoriamente\" a mem\u00f3ria SDRAM ele pode sobrescrever dados importantes do kernel e crashar todo o sistema. Essa aloca\u00e7\u00e3o deve ser realizada no boot do Linux onde iremos dizer qual regi\u00e3o de mem\u00f3ria o kernel pode utilizar. Note Essa mem\u00f3ria que \u00e9 acess\u00edvel tanto pelo Linux quanto pela FPGA \u00e9 uma boa maneira de compartilhamento de dados a serem processados. Aplica\u00e7\u00f5es \u00b6 Com isso agora \u00e9 poss\u00edvel unir o melhor dos dois mundos: flexibilidade e paralelismo da FPGA com o melhor dos processadores embarcados ARM. Nos nossos projetos, o NIOS ser\u00e1 substitu\u00eddo pelo ARM, possibilitando maior poder de processamento e tamb\u00e9m suportando a execu\u00e7\u00e3o de sistemas mais complexos, tal como o Linux. Pense na aplica\u00e7\u00e3o de uma imagem que ser\u00e1 processada pela FPGA a fim de aumentar o throughtput do sistema. Essa imagem ser\u00e1 lida por exemplo por uma c\u00e2mera USB conectada no HPS, como geralmente o HPS executa um Linux, temos facilidade de acesso ao driver dessa c\u00e2mera USB. A imagem ser\u00e1 ent\u00e3o lida via o driver e ent\u00e3o alocada na mem\u00f3ria SDRAM, o endere\u00e7o da mem\u00f3ria assim como as propriedades do processamento ser\u00e3o transferidas para um perif\u00e9rico customizado no Fabric da FPGA via a interface LT-AXI. O perif\u00e9rico que est\u00e1 em modo wait, ap\u00f3s ser configurado, come\u00e7a a ler a imagem na mem\u00f3ria SDRAM, processar e salvar o resultado na pr\u00f3pria mem\u00f3ria. Ao final da convers\u00e3o uma interrup\u00e7\u00e3o \u00e9 gerada e o Linux ir\u00e1 tratar o dado. Enquanto o perif\u00e9rico processa o dado, a aplica\u00e7\u00e3o pode de forma concorrente, ler uma nova imagem e j\u00e1 alocar em um novo endere\u00e7o de mem\u00f3ria, pois o processamento e a aquisi\u00e7\u00e3o agora funcionam de forma simult\u00e2nea. Pr\u00f3ximos passos \u00b6 Vamos agora subir executar um Linux no ARM, iremos nesse momento trabalhar com uma imagem j\u00e1 pronto. Siga para o tutorial ter que configurar nossa infra para podermos gerar c\u00f3digos para o ARM, siga o para: Tutorial HPS BuildSystem .","title":"Vis\u00e3o geral"},{"location":"Tutorial-HPS/#visao-geral","text":"A FPGA contida no kit DE10-Standard \u00e9 um chip SoC que em um \u00fanico dispositivo que possui duas partes: o fabric da FPGA e um Hardware Process System (HPS). HPS \u00e9 o termo utilizado pela Intel-Altera para definir a parte da FPGA que \u00e9 fixa e relativa ao processador ARM A9 (pode ser outro ARM, depende da fam\u00edlia da FPGA). O HPS possui uma unidade de processamento com um ou dois Cores (depende do chip, no nosso caso \u00e9 dual core ) e alguns perif\u00e9ricos conectados em seu barramento (DMA, UART, USB, EMACS, ...). Al\u00e9m dos perif\u00e9ricos j\u00e1 contidos no HPS \u00e9 poss\u00edvel conectarmos novos perif\u00e9ricos sintetizados na FPGA via a interface HPS FPGA Interfaces . Ler Introdu\u00e7\u00e3o: 1 Introduction to Cyclone V Hard Processor System (HPS)","title":"Vis\u00e3o geral"},{"location":"Tutorial-HPS/#familia-de-fpgas","text":"A Altera possui quatro fam\u00edlia de FPGAs-SoC : Stratix 10 SoC: High end, 14nm com ARM-Cortex-A53 de 64bits quad-core Arria 10 SoC: 20nm, Cortex A9 duas core com grande capacidade na FPGA Temos um kit no lab Arria V SoC: 28nm, Cortex A9 com foco em telecomunica\u00e7\u00f5es Cyclone V SoC : Fam\u00edlia low end com valor mais baixo e mais low power.","title":"Fam\u00edlia de FPGAs"},{"location":"Tutorial-HPS/#cortex-a9","text":"O Cortex A9 existente no HPS da Cyclone V possui as caracter\u00edsticas a seguir (extra\u00eddo do datasheet ): ARM Cortex-A9 MPCore One or two ARM Cortex-A9 processors in a cluster NEON SIMD coprocessor and VFPv3 per processor Snoop Control Unit (SCU) to ensure coherency within the cluster Accelerator coherency port (ACP) that accepts coherency memory access requests Interrupt controller One general-purpose timer and one watchdog timer per processor \u2022 Debug and trace features 32 KB instruction and 32 KB data level 1 (L1) caches per processor Memory management unit (MMU) per processor ARM L2-310 level 2 (L2) cache Shared 512 KB L2 cache A seguir um diagrama detalhado do HPS:","title":"Cortex A9"},{"location":"Tutorial-HPS/#conexao-entre-hps-e-fpga","text":"Note que existe no diagrama anterior algumas interfaces definidas no \"FPGA Portion\", essas interfaces permitem a ponte entre o Fabric da FPGA e o ARM hard core do chip. As interfaces s\u00e3o, resumidamente: FPGA to HPS: Barramento na qual um Master na FPGA (Platform Designer) acessa o ARM HPS to FPGA: Barramento pelo qual o ARM acessa um perif\u00e9rico (slave) na FPGA Lightweight HPS to FPGA: Barramento de menor banda que conecta o ARM em um perif\u00e9rico na FPGA (slave) 1-6 Masters SDRAM Controller: Permite a FPGA ler e escrever da mem\u00f3ria SDRAM externa ao chip","title":"Conex\u00e3o entre HPS e FPGA"},{"location":"Tutorial-HPS/#axi","text":"Os barramentos s\u00e3o todos do tipo AXI , um padr\u00e3o definido pela pr\u00f3pria ARM e usada em seus microcontroladores. AXI - AVALON Via Platform Designer podemos conectarmos perif\u00e9ricos com o barramento Avalon (mm) no barramento AXI do ARM, isso \u00e9 poss\u00edvel por uma \"m\u00e1gica\" que a PD faz convertendo um barramento no outro de forma transparente ao usu\u00e1rio.","title":"AXI"},{"location":"Tutorial-HPS/#sdram","text":"A SDRAM deve ser usada com muita cautela pois ela ser\u00e1 compartilhada com o Linux que estar\u00e1 em execu\u00e7\u00e3o no ARM, caso um perif\u00e9rico da FPGA acesse \"aleatoriamente\" a mem\u00f3ria SDRAM ele pode sobrescrever dados importantes do kernel e crashar todo o sistema. Essa aloca\u00e7\u00e3o deve ser realizada no boot do Linux onde iremos dizer qual regi\u00e3o de mem\u00f3ria o kernel pode utilizar. Note Essa mem\u00f3ria que \u00e9 acess\u00edvel tanto pelo Linux quanto pela FPGA \u00e9 uma boa maneira de compartilhamento de dados a serem processados.","title":"SDRAM"},{"location":"Tutorial-HPS/#aplicacoes","text":"Com isso agora \u00e9 poss\u00edvel unir o melhor dos dois mundos: flexibilidade e paralelismo da FPGA com o melhor dos processadores embarcados ARM. Nos nossos projetos, o NIOS ser\u00e1 substitu\u00eddo pelo ARM, possibilitando maior poder de processamento e tamb\u00e9m suportando a execu\u00e7\u00e3o de sistemas mais complexos, tal como o Linux. Pense na aplica\u00e7\u00e3o de uma imagem que ser\u00e1 processada pela FPGA a fim de aumentar o throughtput do sistema. Essa imagem ser\u00e1 lida por exemplo por uma c\u00e2mera USB conectada no HPS, como geralmente o HPS executa um Linux, temos facilidade de acesso ao driver dessa c\u00e2mera USB. A imagem ser\u00e1 ent\u00e3o lida via o driver e ent\u00e3o alocada na mem\u00f3ria SDRAM, o endere\u00e7o da mem\u00f3ria assim como as propriedades do processamento ser\u00e3o transferidas para um perif\u00e9rico customizado no Fabric da FPGA via a interface LT-AXI. O perif\u00e9rico que est\u00e1 em modo wait, ap\u00f3s ser configurado, come\u00e7a a ler a imagem na mem\u00f3ria SDRAM, processar e salvar o resultado na pr\u00f3pria mem\u00f3ria. Ao final da convers\u00e3o uma interrup\u00e7\u00e3o \u00e9 gerada e o Linux ir\u00e1 tratar o dado. Enquanto o perif\u00e9rico processa o dado, a aplica\u00e7\u00e3o pode de forma concorrente, ler uma nova imagem e j\u00e1 alocar em um novo endere\u00e7o de mem\u00f3ria, pois o processamento e a aquisi\u00e7\u00e3o agora funcionam de forma simult\u00e2nea.","title":"Aplica\u00e7\u00f5es"},{"location":"Tutorial-HPS/#proximos-passos","text":"Vamos agora subir executar um Linux no ARM, iremos nesse momento trabalhar com uma imagem j\u00e1 pronto. Siga para o tutorial ter que configurar nossa infra para podermos gerar c\u00f3digos para o ARM, siga o para: Tutorial HPS BuildSystem .","title":"Pr\u00f3ximos passos"},{"location":"info-FPGA-e-Softwares/","text":"Infraestrutura / FPGA e SWs \u00b6 Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente. DE10-Standard \u00b6 Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic ao curso to $350 que possui em seu core uma FPGA Cyclone V com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip. Softwares \u00b6 Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Infraestrutura / FPGA e SWs"},{"location":"info-FPGA-e-Softwares/#infraestrutura-fpga-e-sws","text":"Ao longo do curso iremos trabalhar principalmente com FPGAs SoC da Intel, o principal kit de desenvolvimento \u00e9 o DE10-Standard que possui uma FPGA Cyclone V SoC. O software de desenvolvimento para FPGAs Intel chama Quartus, e ele possui v\u00e1rias e v\u00e1rias vers\u00f5es e varia\u00e7\u00f5es, baixar a indicada aqui para n\u00e3o correr o risco de ter que instalar tudo novamente.","title":"Infraestrutura / FPGA e SWs"},{"location":"info-FPGA-e-Softwares/#de10-standard","text":"Site do fabricante \u00c9 um kit de desenvolvimento fabricado pela Terasic ao curso to $350 que possui em seu core uma FPGA Cyclone V com grande capacidade de mem\u00f3ria e v\u00e1rias c\u00e9lulas l\u00f3gicas, possui diversos perif\u00e9ricos que podem ser controlados ou pela FPGA ou pelo ARM do chip.","title":"DE10-Standard"},{"location":"info-FPGA-e-Softwares/#softwares","text":"Devido a segunda parte do curso na qual iremos compilar e trabalhar com Linux embarcado a disciplina deve ser realizada (e os tutoriais v\u00e3o nessa linha) no Linux , Windows at\u00e9 funciona para a primeira parte, mas depois n\u00e3o da mais para usar, MAC n\u00e3o \u00e9 suportado pelo Quartus. Para o desenvolvimento na disciplina: Ubuntu 18.04 Quartus 18.01 Standard : e os softwares que j\u00e1 vem nesse pacote. SoC EDS Ap\u00f3s instalar, seguir roteiro em (para o quartus funcionar no ubuntu): https://github.com/Insper/Z01.1/wiki/Infraestrutura-Detalhada#3---quartus-prime-e-modelsim Linux Windows MAC","title":"Softwares"},{"location":"info-HPS-Serial/","text":"Info-HPS-Serial \u00b6 Possu\u00edmos algumas formas de acessar e utilizar esse sistema: Via terminal UART Via terminal ssh Se o linux possuir interface gr\u00e1fica, podemos usar um teclado e mouse. Interface gr\u00e1fica via ssh UART \u00b6 O linux no HPS \u00e9 geralmente configurado (no bootloader) para possuir um terminal redirecionado para uma porta UART, essa porta UART \u00e9 dispon\u00edvel via FTDI em um dos USBs da placa (o que estiver escrito UART) e ent\u00e3o pode ser acessado como uma UART. Para isso h\u00e1 uma porta USB espec\u00edfica (UART). Uma vez conectada a porta USB ao PC e energizada a placa, podemos verificar em qual device a porta serial foi mapeada (no host ): $ demsg | tail [ 95158 .497894 ] ftdi_sio 1 -1.1:1.0: device disconnected [ 95161 .649187 ] usb 1 -1.1: new full-speed USB device number 22 using xhci_hcd [ 95161 .748948 ] ftdi_sio 1 -1.1:1.0: FTDI USB Serial Device converter detected [ 95161 .749067 ] usb 1 -1.1: Detected FT232RL [ 95161 .756092 ] usb 1 -1.1: FTDI USB Serial Device converter now attached to ttyUSB0 No log, verificamos que um dispositivo FTDI USB Serial Device foi conectado a ttyUSB0 . E ent\u00e3o podemos abrir o terminal por qualquer programa de porta serial (PUTTY, ...), nesse exemplo utilizaremos o programa screen . $ screen /dev/ttyUSB0 115200 ,cs8 Para melhoramos a interface com o screen crie um arquivo ~/.screenrc e adicione o seguinte conte\u00fado a ele # Enable mouse scrolling and scroll bar history scrolling termcapinfo xterm* ti@:te@ talvez seja necess\u00e1rio instalar o screen. Feito isso, reinicie o target (religando a energia) para termos acesso a todo o log de inicializa\u00e7\u00e3o. notem que no meu caso o nome atribuido ao USB-UART foi o /dev/ttyUSB0 , isso pode mudar no PC de voc\u00eas Uma vez conectado, agora temos acesso a todas as funcionalidades do linux como um bash normal. Na verdade o terminal j\u00e1 \u00e9 configurado para funcionar j\u00e1 no boot, ou seja, conseguimos ter acesso as informa\u00e7\u00f5es do u-boot. Kernel e porta serial \u00b6 Como o kernel sabe qual porta ele deve utilizar para imprimir o log e usar como terminal ? Esse par\u00e2metro \u00e9 passado pelo u-boot para o kernel via o Device Tree : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-1.0\", \"snps,dw-apb-uart\"; reg = < 0xFFC02000 0x00001000 >; interrupt-parent = < &hps_0_arm_gic_0 >; interrupts = < 0 162 4 >; reg-io-width = < 4 >; reg-shift = < 2 >; clock-frequency = < 100000000 >; }; E ent\u00e3o passado com o argumento para o kernel: bootargs = \"console=ttyS0,115200\"; (esse exemplo n\u00e3o \u00e9 da nossa FPGA)","title":"Info-HPS-Serial"},{"location":"info-HPS-Serial/#info-hps-serial","text":"Possu\u00edmos algumas formas de acessar e utilizar esse sistema: Via terminal UART Via terminal ssh Se o linux possuir interface gr\u00e1fica, podemos usar um teclado e mouse. Interface gr\u00e1fica via ssh","title":"Info-HPS-Serial"},{"location":"info-HPS-Serial/#uart","text":"O linux no HPS \u00e9 geralmente configurado (no bootloader) para possuir um terminal redirecionado para uma porta UART, essa porta UART \u00e9 dispon\u00edvel via FTDI em um dos USBs da placa (o que estiver escrito UART) e ent\u00e3o pode ser acessado como uma UART. Para isso h\u00e1 uma porta USB espec\u00edfica (UART). Uma vez conectada a porta USB ao PC e energizada a placa, podemos verificar em qual device a porta serial foi mapeada (no host ): $ demsg | tail [ 95158 .497894 ] ftdi_sio 1 -1.1:1.0: device disconnected [ 95161 .649187 ] usb 1 -1.1: new full-speed USB device number 22 using xhci_hcd [ 95161 .748948 ] ftdi_sio 1 -1.1:1.0: FTDI USB Serial Device converter detected [ 95161 .749067 ] usb 1 -1.1: Detected FT232RL [ 95161 .756092 ] usb 1 -1.1: FTDI USB Serial Device converter now attached to ttyUSB0 No log, verificamos que um dispositivo FTDI USB Serial Device foi conectado a ttyUSB0 . E ent\u00e3o podemos abrir o terminal por qualquer programa de porta serial (PUTTY, ...), nesse exemplo utilizaremos o programa screen . $ screen /dev/ttyUSB0 115200 ,cs8 Para melhoramos a interface com o screen crie um arquivo ~/.screenrc e adicione o seguinte conte\u00fado a ele # Enable mouse scrolling and scroll bar history scrolling termcapinfo xterm* ti@:te@ talvez seja necess\u00e1rio instalar o screen. Feito isso, reinicie o target (religando a energia) para termos acesso a todo o log de inicializa\u00e7\u00e3o. notem que no meu caso o nome atribuido ao USB-UART foi o /dev/ttyUSB0 , isso pode mudar no PC de voc\u00eas Uma vez conectado, agora temos acesso a todas as funcionalidades do linux como um bash normal. Na verdade o terminal j\u00e1 \u00e9 configurado para funcionar j\u00e1 no boot, ou seja, conseguimos ter acesso as informa\u00e7\u00f5es do u-boot.","title":"UART"},{"location":"info-HPS-Serial/#kernel-e-porta-serial","text":"Como o kernel sabe qual porta ele deve utilizar para imprimir o log e usar como terminal ? Esse par\u00e2metro \u00e9 passado pelo u-boot para o kernel via o Device Tree : hps_0_uart0: serial@0xffc02000 { compatible = \"snps,dw-apb-uart-1.0\", \"snps,dw-apb-uart\"; reg = < 0xFFC02000 0x00001000 >; interrupt-parent = < &hps_0_arm_gic_0 >; interrupts = < 0 162 4 >; reg-io-width = < 4 >; reg-shift = < 2 >; clock-frequency = < 100000000 >; }; E ent\u00e3o passado com o argumento para o kernel: bootargs = \"console=ttyS0,115200\"; (esse exemplo n\u00e3o \u00e9 da nossa FPGA)","title":"Kernel e porta serial"},{"location":"info-HPS-ethernet/","text":"Info - HPS - Ethernet \u00b6 Cyclone V Hard Processor System Technical Reference Manual https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/cyclone-v/cv_54001.pdf Hardawre \u00b6 O ARM do nosso HPS possui um perif\u00e9rico Ethernet: E o nosso kit possui toda a parte eletr\u00f4nica que conecta o perif\u00e9rico ao conector Ethernet: Linux \u00b6 Com o HW da terasic preparado, e com um cabo ethernet conectado ao RJ45, precisamos configurar o Linux para utilizar essa \"porta\". No target , verifique que o linux detecta a placa de rede, com o comando ifconfig : Alterando o MAC \u00b6 Para conectar na rede do laborat\u00f3rio de Arq. ser\u00e1 necess\u00e1rio editar o MAC da placa, caso contr\u00e1rio o mesmo n\u00e3o poder\u00e1 se conectar. Para isso, execute os comandos a seguir: $ ifconfig eth0 down $ ifconfig eth0 hw ether 02 :01:02:03:04:08 $ ifconfig eth0 start Note Ser\u00e1 necess\u00e1rio editar o MAC 02:01:02:03:04:08 para o que foi fornecido pelo professor Warning Esse MAC s\u00f3 dever\u00e1 ser utilizado no kit de desenvolvimento e durante o desenvolvimento dos projetos. O uso indevido ser\u00e1 considerado c\u00f3digo de \u00e9tica. Requisitando IP (DHCP) \u00b6 Com o MAC configurado \u00e9 necess\u00e1rio buscar um IP no servidor de DHCP, para isso utilizaremos o programa udhcpc $ udhcpc eth0 Verifique o IP com o comando ifconfig e tente pingar algum site ping google.com . Automatizando no boot \u00b6 Essas configura\u00e7\u00f5es n\u00e3o s\u00e3o persistentes, se reiniciar o linux embarcados ter\u00e1 que fazer tudo novamente. Para facilitar nossa vida, vamos executar isso no boot. RC \u00b6 J\u00e1 reparou nas pastas /etc/rc* do seu sistema operacional? \u00c9 l\u00e1 que reside grande parte dos scripts que s\u00e3o executados no boot/ reboot/ halt. Cada distribui\u00e7\u00e3o utiliza de forma diferente os scripts, por exemplo, o debian utiliza da seguinte forma: https://wiki.debian.org/BootProcess runlevel directory meaning N none System bootup (NONE). There is no /etc/rcN.d/ directory. 0 /etc/rc0.d/ Halt the system. S /etc/rcS.d/ Single-user mode on boot. The lower case s can be used as alias. 1 /etc/rc1.d/ Single-user mode switched from multi-user mode. 2 .. 5 /etc/rc{2,3,4,5}.d/ Multi-user mode. The Debian system does not pre-assign any special meaning differences among these. 6 /etc/rc6.d/ Reboot the system. 7 .. 9 /etc/rc{7,8,9}.d/ Valid multi-user mode but traditional Unix variants don\u2019t use. Their /etc/rc?.d/ directories are not populated when packages are installed. Dentro de cada pasta rc.x os scripts possuem nomes que ditam a sequ\u00eancia na qual os scripts da pasta ser\u00e3o chamados. Adicionando script ao boot \u00b6 Crie um script com o nome macc.sh na pasta /etc/init.d e adicione: #!/bin/bash $ ifconfig eth0 down $ ifconfig eth0 hw ether 02:01:02:03:04:08 $ ifconfig eth0 start ref: https://forums.kali.org/showthread.php?21985-How-to-make-mac-address-random-at-each-boot-up","title":"Info - HPS - Ethernet"},{"location":"info-HPS-ethernet/#info-hps-ethernet","text":"Cyclone V Hard Processor System Technical Reference Manual https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/cyclone-v/cv_54001.pdf","title":"Info - HPS - Ethernet"},{"location":"info-HPS-ethernet/#hardawre","text":"O ARM do nosso HPS possui um perif\u00e9rico Ethernet: E o nosso kit possui toda a parte eletr\u00f4nica que conecta o perif\u00e9rico ao conector Ethernet:","title":"Hardawre"},{"location":"info-HPS-ethernet/#linux","text":"Com o HW da terasic preparado, e com um cabo ethernet conectado ao RJ45, precisamos configurar o Linux para utilizar essa \"porta\". No target , verifique que o linux detecta a placa de rede, com o comando ifconfig :","title":"Linux"},{"location":"info-HPS-ethernet/#alterando-o-mac","text":"Para conectar na rede do laborat\u00f3rio de Arq. ser\u00e1 necess\u00e1rio editar o MAC da placa, caso contr\u00e1rio o mesmo n\u00e3o poder\u00e1 se conectar. Para isso, execute os comandos a seguir: $ ifconfig eth0 down $ ifconfig eth0 hw ether 02 :01:02:03:04:08 $ ifconfig eth0 start Note Ser\u00e1 necess\u00e1rio editar o MAC 02:01:02:03:04:08 para o que foi fornecido pelo professor Warning Esse MAC s\u00f3 dever\u00e1 ser utilizado no kit de desenvolvimento e durante o desenvolvimento dos projetos. O uso indevido ser\u00e1 considerado c\u00f3digo de \u00e9tica.","title":"Alterando o MAC"},{"location":"info-HPS-ethernet/#requisitando-ip-dhcp","text":"Com o MAC configurado \u00e9 necess\u00e1rio buscar um IP no servidor de DHCP, para isso utilizaremos o programa udhcpc $ udhcpc eth0 Verifique o IP com o comando ifconfig e tente pingar algum site ping google.com .","title":"Requisitando IP (DHCP)"},{"location":"info-HPS-ethernet/#automatizando-no-boot","text":"Essas configura\u00e7\u00f5es n\u00e3o s\u00e3o persistentes, se reiniciar o linux embarcados ter\u00e1 que fazer tudo novamente. Para facilitar nossa vida, vamos executar isso no boot.","title":"Automatizando no boot"},{"location":"info-HPS-ethernet/#rc","text":"J\u00e1 reparou nas pastas /etc/rc* do seu sistema operacional? \u00c9 l\u00e1 que reside grande parte dos scripts que s\u00e3o executados no boot/ reboot/ halt. Cada distribui\u00e7\u00e3o utiliza de forma diferente os scripts, por exemplo, o debian utiliza da seguinte forma: https://wiki.debian.org/BootProcess runlevel directory meaning N none System bootup (NONE). There is no /etc/rcN.d/ directory. 0 /etc/rc0.d/ Halt the system. S /etc/rcS.d/ Single-user mode on boot. The lower case s can be used as alias. 1 /etc/rc1.d/ Single-user mode switched from multi-user mode. 2 .. 5 /etc/rc{2,3,4,5}.d/ Multi-user mode. The Debian system does not pre-assign any special meaning differences among these. 6 /etc/rc6.d/ Reboot the system. 7 .. 9 /etc/rc{7,8,9}.d/ Valid multi-user mode but traditional Unix variants don\u2019t use. Their /etc/rc?.d/ directories are not populated when packages are installed. Dentro de cada pasta rc.x os scripts possuem nomes que ditam a sequ\u00eancia na qual os scripts da pasta ser\u00e3o chamados.","title":"RC"},{"location":"info-HPS-ethernet/#adicionando-script-ao-boot","text":"Crie um script com o nome macc.sh na pasta /etc/init.d e adicione: #!/bin/bash $ ifconfig eth0 down $ ifconfig eth0 hw ether 02:01:02:03:04:08 $ ifconfig eth0 start ref: https://forums.kali.org/showthread.php?21985-How-to-make-mac-address-random-at-each-boot-up","title":"Adicionando script ao boot"},{"location":"info-SDcard/","text":"Atualizando o SDCARD \u00b6 Premissas Atualizando o preload \u00b6 TBD Atualizando o uboot \u00b6 TBD uboot script \u00b6 $ cp u-boot.scr /run/media/corsi/B0DA-B234/ Atualizando Kernel \u00b6 Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel. Atualizando o dts \u00b6 $ cp socfpga.dtb /run/media/corsi/B0DA-B234/ FileSystem \u00b6 Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync uboot script e device tree \u00b6","title":"Atualizando o SDCARD"},{"location":"info-SDcard/#atualizando-o-sdcard","text":"Premissas","title":"Atualizando o SDCARD"},{"location":"info-SDcard/#atualizando-o-preload","text":"TBD","title":"Atualizando o preload"},{"location":"info-SDcard/#atualizando-o-uboot","text":"TBD","title":"Atualizando o uboot"},{"location":"info-SDcard/#uboot-script","text":"$ cp u-boot.scr /run/media/corsi/B0DA-B234/","title":"uboot script"},{"location":"info-SDcard/#atualizando-kernel","text":"Para atualizar o kernel basta montar a parti\u00e7\u00e3o 1 (819,2 M). No meu caso o path \u00e9: /run/media/corsi/B0DA-B234/ e copiar o arquivo zImage para ela. O arquivo zImage fica localizado (dentro do reposit\u00f3rio do kernel) em: /arch/arm/boot/zImage Note Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. $ cp ~/work/linux/arch/arm/boot/zImage /run/media/corsi/B0DA-B234/ $ sync Quando fizer isso, ir\u00e1 reparar que a vers\u00e3o do kernel do Linux \u00e9 a que foi gerada na etapa de compila\u00e7\u00e3o do kernel.","title":"Atualizando Kernel"},{"location":"info-SDcard/#atualizando-o-dts","text":"$ cp socfpga.dtb /run/media/corsi/B0DA-B234/","title":"Atualizando o dts"},{"location":"info-SDcard/#filesystem","text":"Para insierirmos nosso fileSystem no SDCARD, primeiramente deve montar a parti\u00e7\u00e3o. no meu caso : /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ . Uma vez montada, devemos primeiramente excluir os arquivos ali salvo (apagar o fileSystem antigo) e ent\u00e3o extrair o que foi gerado pelo buildroot. Warning Voc\u00ea ir\u00e1 ter que editar para o caminho que a parti\u00e7\u00e3o foi montada no seu linux. Danger Se errar, pode ser destrutivo (para seus arquivos) # Limpando fs antigo $ sudo rm -r /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync # Extraindo novo fs $ sudo tar xvf rootfs.tar -C /media/corsi/9cb79fd9-69b8-43e3-bcfe-fa4582579e2c/ $ sync","title":"FileSystem"},{"location":"info-SDcard/#uboot-script-e-device-tree","text":"","title":"uboot script e device tree"},{"location":"info-VHDL/","text":"VHDL \u00b6 Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"},{"location":"info-VHDL/#vhdl","text":"Boas refer\u00eancias da linguagem: Livros (bibliografia): [DESCHAMPS, 2012] DESCHAMPS, J. P.; SUTTER, G. D.; CANT\u00d3 E. Guide to FPGA implementation of arithmetic functions. Springer Science & Business Media; 2012, Apr 5. [CHU, 2011] CHU, PONG P. Embedded SoPC design with Nios II processor and VHDL examples. John Wiley & Sons, 2011. [SIMPSON, 2015] Simpson, Philip Andrew; FPGA Design: Best Practices for Team-based Reuse 2 nd ed. Springer, 2015 Edition. Sites: http://esd.cs.ucr.edu/labs/tutorial/ http://github.com/insper/Z01.1/wiki","title":"VHDL"}]}